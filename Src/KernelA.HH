// Main TempleOS header

extern class CAOT;
extern class CAOTHeapGlbl;
extern class CAOTImportExport;
extern class CCPU;
extern class CDC;
extern class CDirContext;
extern class CDoc;
extern class CFile;
extern class CHashClass;
extern class CHashFun;
extern class CHeapCtrl;
extern class CIntermediateCode;
extern class CJobCtrl;
extern class CTask;

#define U8 U8i
#define I8 I8i
#define Bool U8
#define NULL	0
#define TRUE	1
#define FALSE	0
#define ON	1
#define OFF	0
#define I8_MIN (-0x80)
#define I8_MAX 0x7F
#define U8_MIN 0
#define U8_MAX 0xFF
#define I16_MIN (-0x8000)
#define I16_MAX 0x7FFF
#define U16_MIN 0
#define U16_MAX 0xFFFF
#define I32_MIN (-0x80000000)
#define I32_MAX 0x7FFFFFFF
#define U32_MIN 0
#define U32_MAX 0xFFFFFFFF
#define I64_MIN (-0x8000000000000000)
#define I64_MAX 0x7FFFFFFFFFFFFFFF
#define U64_MIN 0
#define U64_MAX 0xFFFFFFFFFFFFFFFF
#define INVALID_PTR	I64_MAX
#define STR_LEN 144

//(Int to F64 conversion is signed)
//Turn off 80-bit float constants with $LK,"OPTf_NO_BUILTIN_CONST",A="MN:OPTf_NO_BUILTIN_CONST"$.
#define U64_F64_MAX (0x43F0000000000000(F64))
#define F64_MAX (0x7FEFFFFFFFFFFFFF(F64))
#define F64_MIN (0xFFEFFFFFFFFFFFFF(F64))
#define inf	(0x7FF0000000000000(F64))
#ifndef BOOTSTRAP
#define ã	(0x400921FB54442D18(F64))
#endif
#define pi	(0x400921FB54442D18(F64))
#define exp_1	(0x4005BF0A8B145769(F64)) //The number "e"
#define log2_10 (0x400A934F0979A371(F64))
#define log2_e	(0x3FF71547652B82FE(F64))
#define log10_2	(0x3FD34413509F79FF(F64))
#define loge_2	(0x3FE62E42FEFA39EF(F64))
#define sqrt2	(0x3FF6A09E667F3BCD(F64))
#define eps	(0x3CB0000000000000(F64))

/*HolyC union structure is treated as a
whole if no member is specified,
similar to bit fields.

See $LK,"EndianI64",A="MN:EndianI64"$() and $LK,"::/Demo/SubIntAccess.HC"$.
*/
U16i union U16
{
  I8i	i8[2];
  U8i	u8[2];
};

I16i union I16
{
  I8i	i8[2];
  U8i	u8[2];
};

U32i union U32
{
  I8i	i8[4];
  U8i	u8[4];
  I16	i16[2];
  U16	u16[2];
};

I32i union I32
{
  I8i	i8[4];
  U8i	u8[4];
  I16	i16[2];
  U16	u16[2];
};

U64i union U64
{
  I8i	i8[8];
  U8i	u8[8];
  I16	i16[4];
  U16	u16[4];
  I32	i32[2];
  U32	u32[2];
};

I64i union I64
{
  I8i	i8[8];
  U8i	u8[8];
  I16	i16[4];
  U16	u16[4];
  I32	i32[2];
  U32	u32[2];
};

/*public */ class Complex
{
  F64	x,y;
};

/*public */ class CQue
{
  CQue	*next,*last;
};

/*public */ class CD3I32 //Three dimensional I32 pt
{
  I32	x,y,z;
};
/*public */ class CQueD3I32 //Que of three dimensional I32 pts
{
  CQueD3I32	*next,*last;
  CD3I32	p;
};
/*public */ class CD2I32 //Two dimensional I32 pt
{
  I32	x,y;
};
/*public */ class CD2I64 //Two dimensional I64 pt
{
  I64	x,y;
};
/*public */ class CD3I64 //Three dimensional I64 pt
{
  I64	x,y,z;
};
/*public */ class CD2 //Two dimensional F64 pt
{
  F64	x,y;
};

/*public */ class CD3 //Three dimensional F64 pt
{
  F64	x,y,z;
};

#define QUE_VECT_U8_CNT		512
/*public */ class CQueVectU8
{
  CQueVectU8	*next,*last;
  I64	total_cnt,node_cnt,min_idx;
  U8	body[QUE_VECT_U8_CNT];
};

/*public */ class CFifoU8
{
  U8	*buf;
  I64	mask,in_ptr,out_ptr;
};
/*public */ class CFifoI64
{
  I64	*buf;
  I64	mask,in_ptr,out_ptr;
};

#define CDATE_YEAR_DAYS		365.24225
#define CDATE_YEAR_DAYS_INT	36524225
#define CDATE_BASE_DAY_OF_WEEK	0
/*public */ I64 class CDate
{
  U32	time;
  I32	date;
};

/*public */ class CDateStruct
{
  U8	sec10000,sec100,sec,min,hour,
	day_of_week,day_of_mon,mon;
  I32	year;
};

/*public */ class COrder2D3
{
  F64	x,y,z,
	DxDt,DyDt,DzDt;
};

#define MSF_INACTIVE		1
#define MSF_FIXED		2
/*public */ class CMass
{
  CMass	*next,*last;
  COrder2D3 *state, //Point to entries in $LK,"CMathODE",A="MN:CMathODE"$.state[]
	*DstateDt;  //Point to entries in $LK,"CMathODE",A="MN:CMathODE"$.DstateDt[]

  U0	start;
  U32	flags,num;
  F64	mass,drag_profile_factor;
  U0	saved_state;
  F64	x,y,z,
	DxDt,DyDt,DzDt;
  U0	end;
};

#define SSF_INACTIVE		1
#define SSF_NO_COMPRESSION	2
#define SSF_NO_TENSION		4
/*public */ class CSpring
{
  CSpring *next,*last;
  CMass	*end1,*end2;
  F64	f,displacement; //set for you to check

  U0	start;
  U32	flags,num,
	end1_num,end2_num;
  F64	const,rest_len;
  U0	end;
};

//Ordinary Differential Equations
#define ODEF_HAS_MASSES	1
#define ODEF_PAUSED	2
#define ODEF_STARTED	4
#define ODEF_BUSY	8

#define ODEf_HAS_MASSES	0
#define ODEf_PAUSED	1
#define ODEf_STARTED	2
#define ODEf_BUSY	3

/*public */ class CMathODE
{
  CMathODE *next,*last;
  I64	flags,n,n_internal;
  CMass	*next_mass,*last_mass;
  CSpring *next_spring,*last_spring;
  F64	drag_v,  //drag proportional to velocity
	drag_v2, //drag proportional to velocity squared
	drag_v3, //drag proportional to velocity cubed
	acceleration_limit, //This clips acceleration
	base_t,
	t,t_scale,
	h,h_min,h_max;

  //This is not precise, just a ballpark.
  //TempleOS CMathODE's are for video games
  //not science.  It bails if it takes
  //too long.
  F64	min_tolerance,max_tolerance;

  F64	tolerance_internal,
	*array_base,
	*state,
	*state_internal,
	*DstateDt,
	*state_scale,
	*initial_state,
	*tmp0,*tmp1,*tmp2,*tmp3,
	*tmp4,*tmp5,*tmp6,*tmp7;
  CTask	*mem_task,*win_task;
  U0	(*derive)(CMathODE *o,F64 t,F64 *state,F64 *DstateDt);
  U0	(*mp_derive)(CMathODE *o,F64 t, //If break into parallel pieces.
		I64 cpu_num,F64 *state,F64 *DstateDt);
  CTask **slave_tasks;
  I64	mp_not_done_flags;
  F64	mp_t,*mp_state,*mp_DstateDt;

  I64	user_data;
};

//IDT entry types
#define IDTET_TASK		0x05
#define IDTET_IRQ		0x0E
#define IDTET_TRAP		0x0F //Same as IRQ but doesnt do CLI.

//Interrupts
//0x00-0x1F are reserved by Intel
#define I_DIV_ZERO		0x00
#define I_SINGLE_STEP		0x01
#define I_NMI			0x02
#define I_BPT			0x03
#define I_PAGE_FAULT		0x0E
//0x20-0x2F are used for hardware
#define I_TIMER			0x20
//Software Interrupts
#define I_MP_CRASH		0x30
#define I_WAKE			0x31
#define I_DBG			0x32
//See $LK,"ST_INT_NAMES",A="MN:ST_INT_NAMES"$

//You might want to start bwd from
//0xFF for your own interrupts.
#define I_USER			0x40

#define MP_PROCESSORS_NUM	128

#define SYS_START_CR0		0x0031

#define RFLAGf_CARRY		0
#define RFLAGf_PARITY		2
#define RFLAGf_AUX_CARRY	4
#define RFLAGf_ZERO		6
#define RFLAGf_SIGN		7
#define RFLAGf_TRAP		8 //Single Step
#define RFLAGf_INT		9
#define RFLAGf_DIR		10
#define RFLAGf_OVERFLOW		11
#define RFLAGf_IOPL0		12 // I/O Privilege Level
#define RFLAGf_IOPL1		13
#define RFLAGf_NESTED_TASK	14
#define RFLAGf_RESUME		16
#define RFLAGf_V8086		17
#define RFLAGf_ALIGN_CHECK	18
#define RFLAGf_VINT		19 //Virtual Interrupt
#define RFLAGf_VINT_PENDING	20
#define RFLAGf_ID		21

#define RFLAGG_START		0x0000
#define RFLAGG_NORMAL		(1<<RFLAGf_INT)

//Global Descriptor Table
class CGDTEntry
{
  U64	lo,hi;
};

class CGDT
{
  CGDTEntry null;
  CGDTEntry boot_ds;
  CGDTEntry boot_cs;
  CGDTEntry cs32;
  CGDTEntry cs64;	//The $LK,"Charter",A="FI:::/Doc/Charter.DD"$ says just ring-0.
  CGDTEntry cs64_ring3;	//$LK,"Ring3",A="FI:::/Demo/Lectures/Ring3.HC"$, in case you want to play around.
  CGDTEntry ds;
  CGDTEntry ds_ring3;
  CGDTEntry tr[MP_PROCESSORS_NUM];
  CGDTEntry tr_ring3[MP_PROCESSORS_NUM];
};

class CSysLimitBase
{
  U16	limit;	//Offset of last byte, not size.
  U8	*base;	//&GDT or &IDT
};

#define MEM_E820_ENTRIES_NUM	48
class CMemE820
{
  U8	*base;
  I64	len;
  U8	type,pad[3];
};

//Loader flags
#define LDF_NO_ABSS		1
#define LDF_JUST_LOAD		2
#define LDF_SILENT		4

#define BIN_SIGNATURE_VAL	'TOSB'
class CBinFile
{//$LK,"Bin File Header Generation",A="FF:::/Compiler/CMain.HC,16 ALIGN"$ by compiler.
  U16	jmp;
  U8	module_align_bits,
	reserved;
  U32	bin_signature;
  I64	org,
	patch_table_offset, //$LK,"Patch Table Generation",A="FF:::/Compiler/CMain.HC,IET_ABS_ADDR"$
	file_size;
};

class CPatchTableAbsAddr
{
  U8	eit_abs_addr;	//$LK,"IET_ABS_ADDR",A="MN:IET_ABS_ADDR"$
  U32	abs_addres_cnt;
  U8	zero;
  U32	abs_addres[1];
};

//$LK,"CAOTImportExport",A="MN:CAOTImportExport"$ Types. Used in PatchTable.
#define IET_END			0
//reserved
#define IET_REL_I0		2 //Fictitious
#define IET_IMM_U0		3 //Fictitious
#define IET_REL_I8		4
#define IET_IMM_U8		5
#define IET_REL_I16		6
#define IET_IMM_U16		7
#define IET_REL_I32		8
#define IET_IMM_U32		9
#define IET_REL_I64		10
#define IET_IMM_I64		11
#define IEF_IMM_NOT_REL		1
//reserved
#define IET_REL32_EXPORT	16
#define IET_IMM32_EXPORT	17
#define IET_REL64_EXPORT	18 //Not implemented
#define IET_IMM64_EXPORT	19 //Not implemented
#define IET_ABS_ADDR		20
#define IET_CODE_HEAP		21 //Not really used
#define IET_ZEROED_CODE_HEAP	22 //Not really used
#define IET_DATA_HEAP		23
#define IET_ZEROED_DATA_HEAP	24 //Not really used
#define IET_MAIN		25

class CKernel
{//Must match $LK,"OSStartUp",A="FF:::/Kernel/KStart16.HC,MEM_BOOT_BASE"$
  CBinFile h;
  U32	jmp,
	boot_src,
	boot_blk,
	boot_patch_table_base,
	sys_run_level;
  CDate	compile_time;

  U0	start;
  U32	boot_base;
  U16	mem_E801[2];
  CMemE820 mem_E820[MEM_E820_ENTRIES_NUM];
  U64	mem_physical_space;
  CSysLimitBase sys_gdt_ptr;
  U16	sys_pci_busses;
  CGDT	sys_gdt;
};

//Run-Levels
#define RLf_16BIT		0
#define RLf_VGA			1
#define RLf_32BIT		2
#define RLf_PATCHED		3
#define RLf_16MEG_SYS_CODE_BP	4
#define RLf_64BIT		5
#define RLf_16MEG_ADAM_HEAP_CTRL 6
#define RLf_FULL_HEAPS		7
#define RLf_RAW			8
#define RLf_INTERRUPTS		9
#define RLf_BLKDEV		10
#define RLf_MP			11
#define RLf_COMPILER		12
#define RLf_DOC			13
#define RLf_WINMGR		14
#define RLf_REGISTRY		15
#define RLf_HOME		16
#define RLf_AUTO_COMPLETE	17
#define RLf_ADAM_SERVER		18
#define RLf_ONCE_ADAM		19
#define RLf_ONCE_USER		20

#define RLF_16BIT		0x000001
#define RLF_VGA			0x000002
#define RLF_32BIT		0x000004
#define RLF_PATCHED		0x000008
#define RLF_16MEG_SYS_CODE_BP	0x000010
#define RLF_64BIT		0x000020
#define RLF_16MEG_ADAM_HEAP_CTRL 0x000040
#define RLF_FULL_HEAPS		0x000050
#define RLF_RAW			0x000100
#define RLF_INTERRUPTS		0x000200
#define RLF_BLKDEV		0x000400
#define RLF_MP			0x000800
#define RLF_COMPILER		0x001000
#define RLF_DOC			0x002000
#define RLF_WINMGR		0x004000
#define RLF_REGISTRY		0x008000
#define RLF_HOME		0x010000
#define RLF_AUTO_COMPLETE	0x020000
#define RLF_ADAM_SERVER		0x040000
#define RLF_ONCE_ADAM		0x080000
#define RLF_ONCE_USER		0x100000

#define LAPIC_BASE		0xFEE00000

#define LAPIC_APIC_ID		(LAPIC_BASE+0x020)
#define LAPIC_APIC_VERSION	(LAPIC_BASE+0x030)
#define LAPIC_TASK_PRIORITY	(LAPIC_BASE+0x080)
#define LAPIC_ARIBITRATION_PRIORITY (LAPIC_BASE+0x090)
#define LAPIC_PROCESSOR_PRIORITY (LAPIC_BASE+0x0A0)
#define LAPIC_EOI		(LAPIC_BASE+0x0B0)
#define LAPIC_LOG_DST		(LAPIC_BASE+0x0D0)
#define LAPIC_DFR		(LAPIC_BASE+0x0E0)
#define LAPIC_LDR		(LAPIC_BASE+0x0D0)

#define LAPICF_APIC_ENABLED	0x100
#define LAPIC_SVR		(LAPIC_BASE+0x0F0)

#define LAPIC_ISR		(LAPIC_BASE+0x100)
#define LAPIC_TMR		(LAPIC_BASE+0x180)
#define LAPIC_IRR		(LAPIC_BASE+0x200)
#define LAPIC_ICR_LOW		(LAPIC_BASE+0x300)
#define LAPIC_ICR_HIGH		(LAPIC_BASE+0x310)

#define LAPIC_LVT_TIMER		(LAPIC_BASE+0x320)
#define LAPIC_LVT_THERMAL	(LAPIC_BASE+0x330)
#define LAPIC_LVT_PERF		(LAPIC_BASE+0x340)
#define LAPIC_LVT_LINT0		(LAPIC_BASE+0x350)
#define LAPIC_LVT_LINT1		(LAPIC_BASE+0x360)
#define LAPIC_LVT_ERR		(LAPIC_BASE+0x370)

#define MPN_VECT		0x97
#define MP_VECT_ADDR		(MPN_VECT*0x1000)

//I/O APIC Memory mapped window
#define IOAPIC_REG		0xFEC00000 //U8
#define IOAPIC_DATA		0xFEC00010 //U32
//I/O APIC Regs
#define IOAPICID		0x00
#define IOAPICVER		0x01
#define IOAPICARB		0x02
#define IOREDTAB		0x10

//Model specific regs.
#define IA32F_SCE	0x001
#define IA32F_LME	0x100
#define IA32_LAPIC_BASE	0x01B
#define IA32_EFER	0xC0000080
#define IA32_FS_BASE	0xC0000100
#define IA32_GS_BASE	0xC0000101

class CAP16BitInit
{//AP Multicore
  U32	jmp;
  CSysLimitBase ap_gdt_ptr;
};

//High Performance Event Timer
#define HPET_GCAP_ID	(0xFED00000+0x00)
#define HPET_GEN_CONF	(0xFED00000+0x10)
#define HPET_MAIN_CNT	(0xFED00000+0xF0)

/*public */ class CCntsGlbls
{
  I64	jiffies,	//$LK,"JIFFY_FREQ",A="MN:JIFFY_FREQ"$
	timer,		//$LK,"SYS_TIMER_FREQ",A="MN:SYS_TIMER_FREQ"$. Use $LK,"SysTimerRead",A="MN:SysTimerRead"$().
	time_stamp_freq,
	time_stamp_kHz_freq,
	time_stamp_freq_initial, //Initial freq, sampled once at boot time.
	HPET_freq,
	HPET_kHz_freq,
	HPET_initial;	//Initial count, sampled at boot time.
  Bool	time_stamp_calibrated;
};

#define JIFFY_FREQ		1000 // Hz
#define CDATE_FREQ		49710 // Hz
#define SYS_TIMER_FREQ		(18333*65536/1000) //Hz
#define SYS_TIMER0_PERIOD	(65536*182/10/JIFFY_FREQ)

//Function Stack Frame
#define SF_RBP	0x00
#define SF_RIP	0x08
#define SF_ARG1	0x10
#define SF_ARG2	0x18
#define SF_ARG3	0x20
#define SF_ARG4	0x28
#define SF_ARG5	0x30
#define SF_ARG6	0x38
#define SF_ARG7	0x40
#define SF_ARG8	0x48

class CRAXRBCRCXRDX
{
  I64	rax,rbx,rcx,rdx;
};

//Asm callable function pointers.
//They work with $LK,"CallExtNum",A="MN:CallExtNum"$() when calling from HolyC.
#define EXT_WIN_TO_TOP		0
#define EXT_WIN_FOCUS		1
#define EXT_HEAPLOG_MALLOC	2
#define EXT_HEAPLOG_FREE	3
#define EXT_DBG_RESUME		4
#define EXT_EXTS_NUM		5

#define DFT_CACHE_LINE_WIDTH	128

//Semaphores
class CSema
{
  Bool	val,pad[DFT_CACHE_LINE_WIDTH-1];
};
#define SEMA_DEBUG		0
#define SEMA_RECORD_MACRO	1
#define SEMA_SYS_TIMER		2
#define SEMA_SYS_DATE		3
#define SEMA_DBG_MODE		4
#define SEMA_SND		5
#define SEMA_HEAPLOG_ACTIVE	6
#define SEMA_HEAPLOG_LOCK	7
#define SEMA_REFRESH_IN_PROGRESS 8
#define SEMA_FLUSH_VGA_IMAGE	9
#define SEMA_SINGLE_USER	10
#define SEMA_DSK_CACHE		11
#define SEMA_FAR_CALL32		12
#define SEMA_DEV_MEM		13
#define SEMA_VGA		14
#define SEMA_UPDATE_WIN_Z_BUF	15
#define SEMA_TT			16
#define SEMA_MUTE		17
#define SEMA_JUST_PUMP_MSGS	18
#define SEMA_TMBEAT		19
#define SEMA_FIX		20
#define SEMA_SEMAS_NUM		21

#define CTRL_ALT_DEL		0
#define CTRL_ALT_C		1
#define CTRL_ALT_X		2
#define CTRL_ALT_TAB		3

/*public */ class CHash
{//See $LK,"Hash",A="HI:Hash"$
  CHash	*next;
  U8	*str;
  U32	type,
	use_cnt; // inc'ed every time search found, never dec'ed.
};

/*public */ class CHashTable
{
  CHashTable *next;
  I64	mask,locked_flags;
  CHash	**body;
};

//Hash table types: $LK,"ST_HTT_TYPES",A="FF:::/Kernel/KDefine.HC,ST_HTT_TYPES"$
#define HTt_EXPORT_SYS_SYM	0
#define HTt_IMPORT_SYS_SYM	1
#define HTt_DEFINE_STR		2
#define HTt_GLBL_VAR		3
#define HTt_CLASS		4
#define HTt_INTERNAL_TYPE	5
#define HTt_FUN			6
#define HTt_WORD		7
#define HTt_DICT_WORD		8
#define HTt_KEYWORD		9
#define HTt_ASM_KEYWORD		10
#define HTt_OPCODE		11
#define HTt_REG			12
#define HTt_FILE		13
#define HTt_MODULE		14
#define HTt_HELP_FILE		15
#define HTt_FRAME_PTR		16
#define HTt_TYPES_NUM		17

#define HTf_PRIVATE		23
#define HTf_PUBLIC		24
#define HTf_EXPORT		25
#define HTf_IMPORT		26
#define HTf_IMM			27
#define HTf_GOTO_LABEL		28
#define HTf_RESOLVED		29
#define HTf_UNRESOLVED		30
#define HTf_LOCAL		31

#define HTT_INVALID		0
#define HTT_EXPORT_SYS_SYM	0x00001 //CHashExport
#define HTT_IMPORT_SYS_SYM	0x00002 //CHashImport
#define HTT_DEFINE_STR		0x00004 //CHashDefineStr
#define HTT_GLBL_VAR		0x00008 //CHashGlblVar
#define HTT_CLASS		0x00010 //CHashClass
#define HTT_INTERNAL_TYPE	0x00020 //CHashClass
#define HTT_FUN			0x00040 //CHashFun
#define HTT_WORD		0x00080 //CHashAC only in AutoComplete table
#define HTT_DICT_WORD		0x00100 //CHashGeneric only in AutoComplete tbl
#define HTT_KEYWORD		0x00200 //CHashGeneric $LK,"KEYWORD",A="FF:::/Compiler/OpCodes.DD,KEYWORD"$
#define HTT_ASM_KEYWORD		0x00400 //CHashGeneric $LK,"ASM_KEYWORD",A="FF:::/Compiler/OpCodes.DD,ASM_KEYWORD"$
#define HTT_OPCODE		0x00800 //CHashOpcode
#define HTT_REG			0x01000 //CHashReg
#define HTT_FILE		0x02000 //CHashGeneric
#define HTT_MODULE		0x04000 //CHashGeneric
#define HTT_HELP_FILE		0x08000 //CHashSrcSym
#define HTT_FRAME_PTR		0x10000 //CHashGeneric
#define HTG_TYPE_MASK		0x1FFFF

#define HTF_PRIVATE		0x00800000
#define HTF_PUBLIC		0x01000000
#define HTF_EXPORT		0x02000000
#define HTF_IMPORT		0x04000000
#define HTF_IMM			0x08000000
#define HTF_GOTO_LABEL		0x10000000
#define HTF_RESOLVE		0x20000000
#define HTF_UNRESOLVED		0x40000000
#define HTF_LOCAL		0x80000000
#define HTG_FLAGS_MASK		0xFF000000

#define HTG_SRC_SYM	(HTT_DEFINE_STR|HTT_GLBL_VAR|HTT_FUN|HTT_CLASS|\
			HTT_EXPORT_SYS_SYM|HTT_HELP_FILE)
#define HTG_ALL 		-1

#define KERNEL_MODULE_NAME	"/Kernel/Kernel"

class CDbgInfo
{
  U32	min_line,max_line;
  U8  *body[1];
};

/*public */ class CHashSrcSym:CHash
{
  U8	*src_link,
	*idx;
  CDbgInfo *dbg_info;
  U8	*import_name,*import_nameim;
  CAOTImportExport *ie_lst;
};

/*public */ class CHashGeneric:CHash
{
  I64	user_data0,user_data1,user_data2;
};

#define REGT_NONE	0
#define REGT_R8		1
#define REGT_R16	2
#define REGT_R32	3
#define REGT_R64	4
#define REGT_SEG	5
#define REGT_FSTK	6
#define REGT_MM		7
#define REGT_XMM	8

/*public */ class CHashReg:CHash
{
  U8	reg_num,reg_type;
};

/*public */ class CHashAC:CHash
{
  I32	num;
  U32	hits;
};

/*public */ class CHashExport:CHashSrcSym
{
  I64	val;
};

/*public */ class CHashImport:CHashSrcSym
{
  U8	*module_base,
	*module_header_entry;
};

#define PTR_STARS_NUM	4

//Member Lst Flags
#define MLF_DFT_AVAILABLE	1
#define MLF_LASTCLASS		2
#define MLF_STR_DFT_AVAILABLE	4
#define MLF_FUN			8
#define MLF_DOT_DOT_DOT		16
#define MLF_NO_UNUSED_WARN	32
#define MLF_STATIC		64

/*public */ class CArrayDim
{
  CArrayDim *next;
  I64	cnt,total_cnt;
};

#define MLMF_IS_STR	1
/*public */ class CMemberLstMeta
{
  CMemberLstMeta *next;
  U8	*str;
  I64	flags,
	user_data;
};

/*public */ class CMemberLst
{
  CMemberLst *next,*left,*right,
	*left_class_base,*right_class_base; //For finding dup class local vars.
  U8	*str;
  CHashClass *member_class,*member_class_base;
  CMemberLstMeta *meta;
  U32	use_cnt;
  U16	flags;
  I8	reg,pad;
  I64	offset,size;
  CArrayDim dim;
  U8	*static_data;
  union {
    I64	static_data_rip;
    I64 dft_val;
  }
  CHashFun *fun_ptr;
};

class CExternUsage
{
  CExternUsage *next;
  I64	rip;
};

/*public */ class CHashDefineStr:CHashSrcSym
{
  U8	*data,**sub_idx;
  I64	cnt;
};

#define Cf_EXTERN		0
#define Cf_INTERNAL_TYPE	1

/*public */ class CHashClass:CHashSrcSym
{//See $LK,"PrsClassNew",A="MN:PrsClassNew"$(). base_class of $LK,"CHashFun",A="MN:CHashFun"$
  I64	size,neg_offset;
  U32	member_cnt;
  U8	ptr_stars_cnt,raw_type;
  U16	flags;
  CMemberLst *member_lst_and_root, //Head of linked list and head of tree.
	*member_class_base_root, //For finding dup class local vars.
	*last_in_member_lst;
  CHashClass	*base_class,
	*fwd_class;
};

//Function flags
#define Ff_INTERRUPT		8
#define Ff_HASERRCODE		9
#define Ff_ARGPOP		10
#define Ff_NOARGPOP		11
#define Ff_INTERNAL		12
#define Ff__EXTERN		13
#define Ff_DOT_DOT_DOT		14
#define Ff_RET1			15

/*public */ class CHashFun:CHashClass
{//See $LK,"PrsFunNew",A="MN:PrsFunNew"$().
  CHashClass *return_class;
  U32	arg_cnt,pad,
	used_reg_mask,clobbered_reg_mask;
  U8	*exe_addr;
  CExternUsage *ext_lst;
};

//Glbl Var Flags
#define GVF_FUN		1
#define GVF_IMPORT	2
#define GVF_EXTERN	4
#define GVF_DATA_HEAP	8
#define GVF_ALIAS	16
#define GVF_ARRAY	32

/*public */ class CHashGlblVar:CHashSrcSym
{
  I64	size,flags;
  CHashClass *var_class;
  CHashFun *fun_ptr;
  CArrayDim dim;
  U8	*data_addr;
  union {
    I64	data_addr_rip;
    CAOTHeapGlbl *heap_glbl;
  }
};

//See $LK,"TextBase Layer",A="HI:TextBase Layer"$.
#define ATTRF_BLINK	0x10000000
#define ATTRF_INVERT	0x20000000
#define ATTRF_SEL	0x40000000
#define ATTRF_UNDERLINE	0x80000000

#define ATTRf_BLINK		28
#define ATTRf_INVERT		29
#define ATTRf_SEL		30
#define ATTRf_UNDERLINE		31

//CDocEntry.type codes (Low 8 bits)
#define DOCT_TEXT		0
#define DOCT_NEW_LINE		1
#define DOCT_SOFT_NEW_LINE	2
#define DOCT_TAB		3
#define DOCT_PAGE_BREAK		4
#define DOCT_CURSOR		5
#define DOCT_MARKER		6
#define DOCT_PMT		7
#define DOCT_CLEAR		8
#define DOCT_PAGE_LEN		9
#define DOCT_LEFT_MARGIN	10
#define DOCT_RIGHT_MARGIN	11
#define DOCT_HEADER		12
#define DOCT_FOOTER		13
#define DOCT_INDENT		14
#define DOCT_FOREGROUND		15
#define DOCT_BACKGROUND		16
#define DOCT_DFT_FOREGROUND	17
#define DOCT_DFT_BACKGROUND	18
#define DOCT_WORD_WRAP		19
#define DOCT_HIGHLIGHT		20
#define DOCT_BLINK		21
#define DOCT_INVERT		22
#define DOCT_UNDERLINE		23
#define DOCT_SHIFTED_X		24
#define DOCT_SHIFTED_Y		25
#define DOCT_CURSOR_MOVEMENT	26
#define DOCT_ANCHOR		27
#define DOCT_LINK		28
#define DOCT_BTTN		29
#define DOCT_DATA		30
#define DOCT_CHECK_BOX		31
#define DOCT_LST		32
#define DOCT_MACRO		33
#define DOCT_MENU_VAL		34
#define DOCT_HEX_ED		35
#define DOCT_TREE		36
#define DOCT_SPRITE		37
#define DOCT_INS_BIN		38
#define DOCT_INS_BIN_SIZE	39
#define DOCT_SONG		40
#define DOCT_HTML_CODE		41
#define DOCT_ERROR		42

#define DOCT_TYPES_NUM		43

//CDocEntry.type flags upper bits
#define DOCET_BLINK		ATTRF_BLINK
#define DOCET_INVERT		ATTRF_INVERT
#define DOCET_SEL		ATTRF_SEL
#define DOCET_UNDERLINE		ATTRF_UNDERLINE
#define DOCG_BL_IV_UL		0xB0000000

#define DOCEt_BLINK		ATTRf_BLINK
#define DOCEt_INVERT		ATTRf_INVERT
#define DOCEt_SEL		ATTRf_SEL
#define DOCEt_UNDERLINE		ATTRf_UNDERLINE

#define DOCG_DBL_BUF_FLAGS	(DOCF_OVERSTRIKE|DOCF_PLAIN_TEXT|\
		DOCF_PLAIN_TEXT_TABS|DOCF_SIZE_MIN|DOCF_NO_CURSOR|\
		DOCF_FORM|DOCF_DBL_DOLLARS|DOCF_DONT_SWAP_OUT|\
		DOCF_DO_FULL_REFRESH|DOCF_BORDER_DOC|DOCF_HIDE_CURSOR|\
		DOCF_DONT_HIGHLIGHT_CURSOR|DOCF_CARRIAGE_RETURN)

//CDocEntry.de_flags.  These first 16 are arg=
#define DOCEF_TAG		1
#define DOCEF_LEN		2
#define DOCEF_AUX_STR		4
#define DOCEF_DEFINE		8
#define DOCEF_HTML_LINK		0x10
#define DOCEF_LEFT_EXP		0x20
#define DOCEF_LEFT_MACRO	0x40
#define DOCEF_RIGHT_EXP		0x80
#define DOCEF_RIGHT_MACRO	0x100
#define DOCEF_HAS_BIN		0x200
#define DOCEF_BIN_PTR_LINK	0x400
#define DOCEF_RAW_TYPE		0x800
#define DOCEF_SHIFTED_X		0x1000
#define DOCEF_SHIFTED_Y		0x2000
#define DOCEF_SCROLLING_X	0x4000
#define DOCEF_USER_DATA		0x8000

//CDocEntry.de_flags.  These are +/- flags
#define DOCEF_LEFT_CB		0x10000
#define DOCEF_LEFT_IN_STR	0x20000
#define DOCEF_RIGHT_CB		0x40000
#define DOCEF_RIGHT_IN_STR	0x80000
#define DOCEF_LEFT_X		0x100000
#define DOCEF_CENTER_X		0x200000
#define DOCEF_RIGHT_X		0x400000
#define DOCEF_TOP_Y		0x800000
#define DOCEF_CENTER_Y		0x1000000
#define DOCEF_BOTTOM_Y		0x2000000
//HL...UL
#define DOCEF_TAG_CB		0x100000000
#define DOCEF_PAGE_REL_Y	0x200000000
#define DOCEF_MARGIN_REL_X	0x400000000
#define DOCEF_WIN_REL		0x800000000
#define DOCEF_LINK		0x1000000000
#define DOCEF_ESC		0x2000000000 //Send <ESC> (Exit and Save)
#define DOCEF_QUIT		0x4000000000 //Send <SHIFT-ESC> (Abort)
#define DOCEF_FROM_START	0x8000000000
#define DOCEF_HAS_BORDER	0x10000000000
#define DOCEF_SOLID_BORDER	0x20000000000
#define DOCEF_BORDER_PLOT	0x40000000000
#define DOCEF_CHECKED_COLLAPSED 0x80000000000 //Checked or Collapsed
#define DOCEF_CHECK_COLLAPSABLE 0x100000000000
#define DOCEF_REFRESH_DATA	0x200000000000
#define DOCEF_UPDATE_DATA	0x400000000000
//$LK,"DOCEF_DEREF_DATA",A="MN:DOCEF_DEREF_DATA"$ is confusing. $LK,"DocForm",A="MN:DocForm"$() makes doc_e->data point to members
//of class. For ints, it derefs doc_e->data as a ptr.  For strings, it doesn't.
#define DOCEF_DEREF_DATA	0x800000000000
#define DOCEF_REMALLOC_DATA	0x1000000000000
#define DOCEF_HAS_TERMINATOR	0x2000000000000
#define DOCEF_ZERO_BASED	0x4000000000000
#define DOCEF_HOLD		0x8000000000000
#define DOCEF_TREE		0x10000000000000
#define DOCEF_LST		0x20000000000000
#define DOCEF_SKIP		0x40000000000000
#define DOCEF_POPUP		0x80000000000000
#define DOCEF_SKIP_IN_FORM	0x100000000000000
#define DOCEF_FILTER_SKIP	0x200000000000000
#define DOCEF_NO_CLICK_ON	0x400000000000000
#define DOCEF_DONT_DRAW		0x800000000000000 //only works on sprites
#define DOCEF_DFT_LEN		0x1000000000000000
#define DOCEF_DFT_RAW_TYPE	0x2000000000000000

#define DOCEG_HAS_ALLOC		(DOCEF_TAG|DOCEF_AUX_STR|DOCEF_DEFINE|\
  DOCEF_HTML_LINK|DOCEF_LEFT_MACRO|DOCEF_RIGHT_MACRO|DOCEF_BIN_PTR_LINK|\
  DOCEF_REMALLOC_DATA)

#define DOCEG_HAS_ARG		((DOCEG_HAS_ALLOC&~DOCEF_REMALLOC_DATA)|\
  DOCEF_LEN|DOCEF_LEFT_EXP|DOCEF_RIGHT_EXP|DOCEF_HAS_BIN|DOCEF_RAW_TYPE|\
  DOCEF_SHIFTED_X|DOCEF_SHIFTED_Y|DOCEF_SCROLLING_X|DOCEF_USER_DATA)

#define DOCEG_DONT_EDIT	(DOCEF_DEFINE|DOCEF_HTML_LINK|\
  DOCEF_AUX_STR|DOCEF_BIN_PTR_LINK|DOCEF_SCROLLING_X|DOCEF_TAG_CB)

//These are ident to Doc flags
#define DOCEF_HIGHLIGHT		0x4000000
#define DOCEF_WORD_WRAP		0x8000000
#define DOCEF_BLINK		ATTRF_BLINK
#define DOCEF_INVERT		ATTRF_INVERT
#define DOCEF_SEL		ATTRF_SEL
#define DOCEF_UNDERLINE		ATTRF_UNDERLINE
#define DOCEf_HIGHLIGHT		26
#define DOCEf_WORD_WRAP		27
#define DOCEf_BLINK		ATTRf_BLINK
#define DOCEf_INVERT		ATTRf_INVERT
#define DOCEf_SEL		ATTRf_SEL
#define DOCEf_UNDERLINE		ATTRf_UNDERLINE

//CDocEntry.de_flags.  These first 16 are arg=
#define DOCEf_TAG		0
#define DOCEf_LEN		1
#define DOCEf_AUX_STR		2
#define DOCEf_DEFINE		3
#define DOCEf_HTML_LINK		4
#define DOCEf_LEFT_EXP		5
#define DOCEf_LEFT_MACRO	6
#define DOCEf_RIGHT_EXP		7
#define DOCEf_RIGHT_MACRO	8
#define DOCEf_HAS_BIN		9
#define DOCEf_BIN_PTR_LINK	10
#define DOCEf_RAW_TYPE		11
#define DOCEf_SHIFTED_X		12
#define DOCEf_SHIFTED_Y		13
#define DOCEf_SCROLLING_X	14
#define DOCEf_USER_DATA		15

//CDocEntry.de_flags.  These are +/- flags
#define DOCEf_LEFT_CB		16
#define DOCEf_LEFT_IN_STR	17
#define DOCEf_RIGHT_CB		18
#define DOCEf_RIGHT_IN_STR	19
#define DOCEf_LEFT_X		20
#define DOCEf_CENTER_X		21
#define DOCEf_RIGHT_X		22
#define DOCEf_TOP_Y		23
#define DOCEf_CENTER_Y		24
#define DOCEf_BOTTOM_Y		25
//HL...UL
#define DOCEf_TAG_CB		32
#define DOCEf_PAGE_REL_Y	33
#define DOCEf_MARGIN_REL_X	34
#define DOCEf_WIN_REL		35
#define DOCEf_LINK		36
#define DOCEf_ESC		37 //Send <ESC> (Exit and Save)
#define DOCEf_QUIT		38 //Send <SHIFT-ESC> (Abort)
#define DOCEf_FROM_START	39
#define DOCEf_HAS_BORDER	40
#define DOCEf_SOLID_BORDER	41
#define DOCEf_BORDER_PLOT	42
#define DOCEf_CHECKED_COLLAPSED 43 //Checked or Collapsed
#define DOCEf_CHECK_COLLAPSABLE 44
#define DOCEf_REFRESH_DATA	45
#define DOCEf_UPDATE_DATA	46
#define DOCEf_DEREF_DATA	47
#define DOCEf_REMALLOC_DATA	48
#define DOCEf_HAS_TERMINATOR	49
#define DOCEf_ZERO_BASED	50
#define DOCEf_HOLD		51
#define DOCEf_TREE		52
#define DOCEf_LST		53
#define DOCEf_SKIP		54
#define DOCEf_POPUP		55
#define DOCEf_SKIP_IN_FORM	56
#define DOCEf_FILTER_SKIP	57
#define DOCEf_NO_CLICK_ON	58
#define DOCEf_DONT_DRAW		59 //only works on sprites
#define DOCEf_DFT_LEN		60
#define DOCEf_DFT_RAW_TYPE	61
#define DOCEf_FLAGS_NUM		62

/*public */ class CDocBin
{
  CDocBin *next,*last;
  I32	tmp_use_cnt,renum_num;
  U8	*tag;
  U0	start;
  U32	num,flags,size,use_cnt;
  U0	end;
  U8	*data;
};

#define DOC_SCROLL_SPEED	8

#define DOCSS_NORMAL		0
#define DOCSS_SINGLE_QUOTE	1
#define DOCSS_DBL_QUOTE		2
#define DOCSS_COMMENT		3
#define DOCSS_CPP_Z_COMMENT	4

#define DOC_ATTR_DFT_TEXT	WHITE<<4+BLACK
#define DOC_COLOR_ALT_TEXT	LTGRAY
#define DOC_COLOR_LINK		RED
#define DOC_COLOR_MACRO		LTBLUE
#define DOC_COLOR_ANCHOR	DKGRAY
#define DOC_COLOR_TREE		PURPLE
#define DOC_COLOR_PMT		GREEN
#define DOC_COLOR_COMMENT	GREEN
#define DOC_COLOR_BIN		LTGREEN
#define DOC_COLOR_STR		BROWN
#define DOC_COLOR_CHAR_CONST	BROWN
#define DOC_COLOR_EXPORT_SYS_SYM LTPURPLE
#define DOC_COLOR_DEFINE_STR	CYAN
#define DOC_COLOR_GLBL_VAR	LTCYAN
#define DOC_COLOR_CLASS		LTBLUE
#define DOC_COLOR_FUN		PURPLE
#define DOC_COLOR_KEYWORD	BLUE
#define DOC_COLOR_REG		LTRED

/*public */ class CDocSettings
{
  U32	final_u32_attr;
  I16	left_margin,right_margin,indent;
  U16	page_len,header,footer;
  I8	shifted_x,shifted_y;
  U8	state,comment_depth,paren_depth,brace_depth,
	cur_text_attr,dft_text_attr;
};

#define DOC_DFT 		I32_MIN

/*public */ class CDocEntryBase
{
//This is a shortened structure for
  //cmds like the text cmd which
  //don't require the full CDocEntry structure.
  CDocEntryBase *next,*last;
  U8	*tag;
  union {
    U8	type_u8; //this stores the code
    U32 type; //these store attr flags
  };
  I32	page_line_num;
  I64	de_flags;
  I32	x,y;
  U32	min_col,max_col;
  CDocSettings settings;
  I64	user_data;
};

#define DOCE_LEN_DFT	64

/*public */ class CDocEntry:CDocEntryBase
{
  union {
    I64 attr;
    I64 cursor_x_offset;
    I64 (*left_cb)(CDoc *doc,CDocEntry *doc_e);
    I64 left_exp;
  };
  U8	*left_macro;

  union {
    I64 cursor_y_offset;
    I64 (*right_cb)(CDoc *doc,CDocEntry *doc_e);
    I64 right_exp;
  };
  U8	*right_macro;

  U8	*(*tag_cb)(CDoc *doc,CDocEntry *doc_e,CTask *mem_task);
  U8	*define_str,
	*aux_str,
	*bin_ptr_link,
	*html_link,
	*my_fmt_data;
  I64	hex_ed_width;
  I32	scroll_len,
	len, //$LK,"DOCE_LEN_DFT",A="MN:DOCE_LEN_DFT"$
	bin_num;
  U8	raw_type,pad[3];
  CDocBin *bin_data;
  U8	*data;
};

//$LK,"DocForm",A="MN:DocForm"$() $LK,"DocMenu",A="MN:DocMenu"$() $LK,"DocEd",A="MN:DocEd"$() $LK,"PopUpMenu",A="MN:PopUpMenu"$()
#define	DOF_SIZE_MIN		0x01
#define	DOF_INTERCEPT_TASK_END	0x02
#define DOF_DONT_HOME		0x04
#define DOF_WIN_MAX		0x08
#define DOF_DONT_TEXT_ATTR	0x10
#define DOF_DONT_WINMGR_SYNC	0x20
#define DOF_DONT_SHOW		0x40
//Combines with  $LK,"Editor Flags",A="MN:EDF_BAIL"$
//TODO RESTORE meta data
class CEdFindText
{
  U8	find_text[STR_LEN] format "\dDA-P,"
	"A=\"Find        :%s\"\d\n",
	replace_text[STR_LEN] format "\dDA-P,"
	"A=\"Replace     :%s\"\d\n";
  Bool	replace			format "\dCB,\"Replace\"\d\n",
	scan_fwd		format "\dCB,\"Fwd\"\d\n",
	scan_sel_text		format "\dCB,\"Selection\"\d\n",
	match_case		format "\dCB,\"Match Case\"\d\n",
	whole_labels		format "\dCB,\"Whole Labels\"\d\n",
	local_var		format "\dCB,\"Rename Local Var\"\d\n",
	pmt,pad;
  I64	filter_lines		format "\dDA,A=\"Filter Lines:%d\"\d\n";
};

class CEdFileName
{
  CDirContext *dirc;
  U8	name[256] format "\dDA-P,LEN=255,A=\"FileName:%s\"\d";
};
//$LK,"Ed",A="MN:Ed"$()
#define EDF_BAIL		0x100
#define EDF_COLLAPSE		0x200
#define EDF_UNCOLLAPSE		0x400
#define EDF_WAS_WRITE		0x800 //Was exit ESC or SHIFT_ESC?
//Combines with $LK,"Document Flags",A="MN:DOF_SIZE_MIN"$

#define EDf_BAIL		8
#define EDf_COLLAPSE		9
#define EDf_UNCOLLAPSE		10
#define EDf_WAS_WRITE		11

// DOC header flags
#define DOCF_PLAIN_TEXT 	0x1
#define DOCF_PLAIN_TEXT_TABS	0x2 //has '\t', not DOCT_TAB
#define DOCF_AUTO_SAVE		0x4
#define DOCF_NO_CURSOR		0x8
#define DOCF_CARRIAGE_RETURN	0x10
#define DOCF_DBL_DOLLARS	0x20
#define DOCF_COLOR_NAMES	0x40
//Reserved x1
#define DOCF_BORDER_DOC		0x100
#define DOCF_FORM		0x200
#define DOCF_SIZE_MIN		0x400
#define DOCF_HIDE_CURSOR	0x800  //use $LK,"DocCursor",A="MN:DocCursor"$
#define DOCF_DONT_HIGHLIGHT_CURSOR 0x1000 //use $LK,"DocHighlightCursor",A="MN:DocHighlightCursor"$
#define DOCF_NO_SCROLL_BARS	0x2000 //use $LK,"DocScroll",A="MN:DocScroll"$
#define DOCF_ALLOW_UNDO		0x4000
#define DOCF_DONT_SHOW		0x8000
#define DOCF_HAS_SONG		0x10000
#define DOCF_MORE		0x20000
#define DOCF_BWD_MOVEMENT	0x40000
#define DOCF_NULL_GRAB_SCROLL	0x80000
#define DOCF_DONT_SWAP_OUT	0x100000
#define DOCF_DO_FULL_REFRESH	0x200000
#define DOCF_BREAK_UNLOCKED	0x400000
//Reserved x1
#define DOCF_HIGHLIGHT		DOCEF_HIGHLIGHT
#define DOCF_WORD_WRAP		DOCEF_WORD_WRAP
#define DOCF_BLINK		DOCEF_BLINK
#define DOCF_INVERT		DOCEF_INVERT
#define DOCF_SEL		DOCEF_SEL
#define DOCF_UNDERLINE		DOCEF_UNDERLINE

#define DOCF_OVERSTRIKE 	0x100000000
#define DOCF_IN_DOLLAR		0x200000000
#define DOCF_SUPERSCRIPT_MODE	0x400000000
#define DOCF_SUBSCRIPT_MODE	0x800000000
#define DOCF_UNDO_DIRTY		0x1000000000

#define DOCf_PLAIN_TEXT 	0
#define DOCf_PLAIN_TEXT_TABS	1 //has '\t', not DOCT_TAB
#define DOCf_AUTO_SAVE		2
#define DOCf_NO_CURSOR		3
#define DOCf_CARRIAGE_RETURN	4
#define DOCf_DBL_DOLLARS	5
#define DOCf_COLOR_NAMES	6
//Reserved x1
#define DOCf_BORDER_DOC		8
#define DOCf_FORM		9
#define DOCf_SIZE_MIN		10
#define DOCf_HIDE_CURSOR	11  //use $LK,"DocCursor",A="MN:DocCursor"$
#define DOCf_DONT_HIGHLIGHT_CURSOR 12  //use $LK,"DocHighlightCursor",A="MN:DocHighlightCursor"$
#define DOCf_NO_SCROLL_BARS	13  //use $LK,"DocScroll",A="MN:DocScroll"$
#define DOCf_ALLOW_UNDO		14
#define DOCf_DONT_SHOW		15
#define DOCf_HAS_SONG		16
#define DOCf_MORE		17
#define DOCf_BWD_MOVEMENT	18
#define DOCf_NULL_GRAB_SCROLL	19
#define DOCf_DONT_SWAP_OUT	20
#define DOCf_DO_FULL_REFRESH	21
#define DOCf_BREAK_UNLOCKED	22
//Reserved x1

#define DOCf_HIGHLIGHT		DOCEf_HIGHLIGHT
#define DOCf_WORD_WRAP		DOCEf_WORD_WRAP
#define DOCf_BLINK		DOCEf_BLINK
#define DOCf_INVERT		DOCEf_INVERT
#define DOCf_SEL		DOCEf_SEL
#define DOCf_UNDERLINE		DOCEf_UNDERLINE

#define DOCf_OVERSTRIKE 	32
#define DOCf_IN_DOLLAR		33
#define DOCf_SUPERSCRIPT_MODE	34
#define DOCf_SUBSCRIPT_MODE	35
#define DOCf_UNDO_DIRTY		36

//locked flags
#define DOClf_LOCKED		0
class CDocUndo
{
  CDocUndo *next,*last;
  I64	size,doc_flags,time_stamp;
  U8	*body;
};

//See $LK,"DocMenu",A="MN:DocMenu"$()
#define DOCM_CANCEL		(-1)

#define DOC_SIGNATURE_VAL	'DocS'

#define RECALCt_NORMAL		0x00
#define RECALCt_FIND_CURSOR	0x01
#define RECALCt_TO_SCRN		0x02
#define RECALCG_MASK		0xFF

#define RECALCF_HAS_CURSOR	0x100
#define RECALCF_ADD_CURSOR	0x200
#define RECALCF_TO_HTML		0x400

/*public */ class CDoc //Linked Text File header
{//See $LK,"Doc",A="HI:Doc"$ for documentation.
  CDocEntryBase head;
  I64	flags,locked_flags;
  CDocEntry *cur_entry,*old_cur_entry;
  I32	cur_col,old_cur_col,
	line_start_col,top_line_num,
	dollar_buf_size,dollar_buf_ptr;
  U8	*dollar_buf; //When entering $$ cmds, it buffers them until the end $$.

  CTask *win_task,*mem_task,*owning_task;
  I32	page_line_num,undo_cnt,
	x,y,min_x,max_x,min_y,max_y;
  I64	line,col,best_d,
	old_win_top,old_win_bottom,
	old_win_left,old_win_right,
	cmd_U8;
  U32	doc_signature,cur_bin_num;
  I64	max_entries,
	updates_cnt;
  CEdFindText *find_replace;

  CEdFileName filename;
  I64	file_attr;
  I64	(*left_click_link)(CDoc *doc,CDocEntry *doc_e);
  I64	(*right_click_link)(CDoc *doc,CDocEntry *doc_e);

  //See $LK,"::/Apps/Psalmody/JukeBox.HC"$
  U8	*user_put_data; //Passed to user_put_key() and user_put_s()
  Bool	(*user_put_key)(CDoc *doc,U8 *data,I64 ch,I64 sc);
  Bool	(*user_put_s)(CDoc *doc,U8 *data,U8 *st);

  CDoc	*parent_doc; //(When browsing deeper, opening deeper docs.)
  U64	desc; //8 characters. See $LK,"DocBorderLstDraw",A="MN:DocBorderLstDraw"$().

  CDocBin bin_head;
  CDocSettings settings_head;
  CDocUndo undo_head;

  I64	user_data;
};

/*
Fs->win_inhibit mask

Some inhibit actions on the task itself.
Some inhibit actions if the focus task
tries to do something.
*/
#define WIF_SELF_FOCUS		0x0001 //If active this task cannot have focus
		//MENU		0x0002
#define WIF_SELF_CTRLS		0x0004
#define WIF_SELF_MS_L		0x0008
		//MS_L_D	0x0010
#define WIF_SELF_MS_R		0x0020
		//MS_R_D	0x0040
#define WIF_SELF_MS_WHEEL	0x0080 //Does nothing, yet
#define WIF_SELF_BORDER		0x0100
#define WIF_SELF_GRAB_SCROLL	0x0200
#define WIF_SELF_DOC		0x0400
#define WIF_SELF_ODE		0x0800
#define WIF_SELF_KEY_DESC	0x1000
		//FOCUS		0x00010000
#define WIF_FOCUS_TASK_MENU	0x00020000
#define WIF_FOCUS_TASK_CTRLS	0x00040000
#define WIF_FOCUS_TASK_MS_L	0x00080000
#define WIF_FOCUS_TASK_MS_L_D	0x00100000
#define WIF_FOCUS_TASK_MS_R	0x00200000
#define WIF_FOCUS_TASK_MS_R_D	0x00400000
#define WIF_FOCUS_TASK_MS_WHEEL	0x00800000 //Does nothing, yet
#define WIF_FOCUS_TASK_BORDER	0x01000000
#define WIF_FOCUS_TASK_GRAB_SCROLL 0x02000000

#define WIG_DBL_CLICK		(WIF_FOCUS_TASK_MS_L_D|WIF_FOCUS_TASK_MS_R_D)
#define WIG_TASK_DFT		(WIF_FOCUS_TASK_MENU|WIG_DBL_CLICK|\
	0xFFFF-WIF_SELF_DOC-WIF_SELF_ODE)
#define WIG_NO_FOCUS_TASK_DFT	(WIG_TASK_DFT-WIF_SELF_BORDER\
	-WIF_SELF_MS_L-WIF_SELF_MS_R-WIG_DBL_CLICK)
#define WIG_USER_TASK_DFT	WIF_SELF_KEY_DESC

#define WIf_SELF_FOCUS		0
#define WIf_SELF_CTRLS		2
#define WIf_SELF_MS_L		3
#define WIf_SELF_MS_R		5
#define WIf_SELF_MS_WHEEL	7
#define WIf_SELF_BORDER		8
#define WIf_SELF_GRAB_SCROLL	9
#define WIf_SELF_DOC		10
#define WIf_SELF_ODE		11
#define WIf_SELF_KEY_DESC	12
#define WIf_FOCUS_TASK_MENU	17
#define WIf_FOCUS_TASK_CTRLS	18
#define WIf_FOCUS_TASK_MS_L	19
#define WIf_FOCUS_TASK_MS_L_D	20
#define WIf_FOCUS_TASK_MS_R	21
#define WIf_FOCUS_TASK_MS_R_D	22
#define WIf_FOCUS_TASK_MS_WHEEL	23
#define WIf_FOCUS_TASK_BORDER	24
#define WIf_FOCUS_TASK_GRAB_SCROLL 25

class CWinMgrTimingGlbls
{
  I64	last_total_jiffies,
	last_idle_pt_hits[MP_PROCESSORS_NUM],
	last_swap_cnter[MP_PROCESSORS_NUM];
  F64	last_calc_idle_time,calc_idle_delta_time;
  I64	calc_idle_cnt;
};

extern F64 target_fps;
#define WINMGR_FPS	(target_fps)
#define WINMGR_PERIOD	(1./target_fps)
public extern F64 SetFPS(F64 target);

/*public */ class CWinMgrGlbls
{
  I64	updates;
  F64	ode_time,
	last_ode_time,
	fps,		//You can read but not write this. You have no control.
	ideal_refresh_tS,
	last_refresh_tS;
  CWinMgrTimingGlbls *t;
  Bool	show_menu,grab_scroll,grab_scroll_closed;
};

#define ACf_INIT_IN_PROGRESS	0
#define AC_FILLINS_NUM 10
/*public */ class CAutoCompleteGlbls
{
  I64	num_words;
  CHashTable *hash_table;
  U8	*cur_word;
  I64	flags;
  CTask	*task;
  I64	partial_len,num_fillins,
	fillin_hits	[AC_FILLINS_NUM+1];
  CHashAC *fillin_matches[AC_FILLINS_NUM+1];
};

#define ACD_WORD_FILENAME	"/ACWords.DATA"
#define ACD_DEF_FILENAME	"/ACDefs.DATA"
#define ACD_DEF_FILENAME_Z	"/ACDefs.DATA"

#define ACD_H1			0
#define ACD_H1_END		1
#define ACD_DEF			2
#define ACD_DEF_END		3
#define ACD_PRONUNCIATION	4
#define ACD_PRONUNCIATION_END	5
#define ACD_POS			6
#define ACD_POS_END		7
#define ACD_EXTRA		8
#define ACD_EXTRA_END		9
#define ACD_BLK_SIZE		0x4000

#define ACD_END_CHAR		0x00
#define ACD_WORD_CHAR		0x01
#define ACD_DEF_CHAR		0x02
#define ACD_PRONUNCIATION_CHAR	0x03
#define ACD_POS_CHAR		0x04
#define ACD_EXTRA_CHAR		0x05

#define ACD_FILLINS_NUM 10
/*public */ class CAutoCompleteDictGlbls
{
  U8	*word_lst;
  I64	word_lst_size,num_words,num_fillins;
  U8	*fillins[ACD_FILLINS_NUM];
  Bool	has_words,has_defs;
};

//Compiler $LK,"Option",A="MN:Option"$()s
//You might need to do #exe {Option();}
//Note: The #exe stmt is lexed-ahead,
//so it takes effect earlier than you might expect.
#define OPTf_ECHO		0x00
#define OPTf_TRACE		0x01
#define OPTf_WARN_UNUSED_VAR	0x10 //Applied to funs, not stmts
#define OPTf_WARN_PAREN		0x11 //Warn unnecessary parens
#define OPTf_WARN_DUP_TYPES	0x12 //Warn dup local var type stmts
#define OPTf_WARN_HEADER_MISMATCH 0x13
#define OPTf_EXTERNS_TO_IMPORTS	0x20
#define OPTf_KEEP_PRIVATE	0x21
#define OPTf_NO_REG_VAR		0x22  //Applied to funs, not stmts
#define OPTf_GLBLS_ON_DATA_HEAP	0x23
//Disable 10-byte float consts for Ã£,log2_10,log10_2,loge_2
#define OPTf_NO_BUILTIN_CONST	0x24 //Applied to funs, not stmts
#define OPTf_USE_IMM64		0x25 //Not completely implemented
#define OPTf_KEEP_RELOCATIONS 0x26 //Added by nroot,will keep the CHashImport's
#define OPTf_BOUNDS_CHECK 0x27 //Added by nroot,Bounds checker

#define OPTF_ECHO		(1<<OPTf_ECHO)

//See $LK,"ST_RAW_TYPES",A="MN:ST_RAW_TYPES"$
#define RT_I0		2
#define RT_U0		3
#define RT_I8		4
#define RT_U8		5
#define RT_I16		6
#define RT_U16		7
#define RT_I32		8
#define RT_U32		9
#define RT_I64		10
#define RT_PTR		10 //Signed to allow negative err codes. $LK,"DOCM_CANCEL",A="MN:DOCM_CANCEL"$
#define RT_U64		11
#define RT_F32		12 //Not implemented
#define RT_UF32		13 //Not implemented, Fictitious
#define RT_F64		14
#define RT_UF64		15 //Fictitious
#define RT_RTS_NUM	16
#define RTF_UNSIGNED	1
#define RTG_MASK	0xFF

#define MDf_STK		8
#define MDf_IMM		9
#define MDf_REG		10
#define MDf_DISP	11
#define MDf_SIB		12
#define MDf_RIP_DISP32	13

#define MDF_NULL	0x0000
#define MDF_STK		0x0100
#define MDF_IMM		0x0200
#define MDF_REG		0x0400
#define MDF_DISP	0x0800
#define MDF_SIB		0x1000
#define MDF_RIP_DISP32	0x2000
#define MDG_MASK	0xFF00
#define MDG_REG_DISP_SIB	(MDF_REG|MDF_DISP|MDF_SIB)
#define MDG_DISP_SIB_RIP	(MDF_DISP|MDF_SIB|MDF_RIP_DISP32)
#define MDG_REG_DISP_SIB_RIP	(MDF_REG|MDG_DISP_SIB_RIP)

#define ICF_RES_TO_F64			0x000000001
#define ICF_RES_TO_INT			0x000000002
#define ICF_ARG1_TO_F64			0x000000004
#define ICF_ARG1_TO_INT			0x000000008
#define ICF_ARG2_TO_F64			0x000000010
#define ICF_ARG2_TO_INT			0x000000020
#define ICF_USE_F64			0x000000040
#define ICF_USE_UNSIGNED		0x000000080
#define ICF_USE_INT			0x000000100 //highest priority
#define ICF_RES_NOT_USED		0x000000200
#define ICF_CODE_FINAL			0x000000400
#define ICF_BY_VAL			0x000000800 //By value, not ref.
#define ICF_SHORT_JMP			0x000001000 //Also used by nroot for short addresses(for global variables and such)
#define ICF_PUSH_RES			0x000002000
#define ICF_PASS_TRACE			0x000004000
#define ICF_RES_WAS_STK			0x000008000
#define ICF_ARG1_WAS_STK		0x000010000
#define ICF_ARG2_WAS_STK		0x000020000
#define ICF_PUSH_CMP			0x000040000 //for 50<i<j<=100 exps
#define ICF_POP_CMP			0x000080000 //for 50<i<j<=100 exps
#define ICF_SWAP			0x000100000
#define ICF_FUNC_CALL 0x000200000 //Added by Nroot,calling a function will dirty the tmp regs
#define ICf_DONT_PUSH_FLOAT0		21 // 3bits
#define ICf_DONT_POP_FLOAT0		24 // 3bits
#define ICF_ALT_TEMPLATE		0x008000000
#define ICF_LOCK			0x010000000
#define ICf_LOCK			28
#define ICF_NO_RIP			0x020000000
#define ICF_DEL_PREV_INS		0x040000000
#define ICF_PREV_DELETED		0x080000000
#define ICF_DONT_RESTORE		0x100000000
#define ICG_NO_CVT_MASK			0x1FFFFFF00

#define IC_BODY_SIZE			0x83

#define ECF_HAS_PUSH_CMP		0x01 //for 50<i<j<=100 exps

U16 class CICType
{
  U8	raw_type,mode;
};

class CICArg
{
  CICType type;
  U16	reg; //low is reg, high is index_reg+scale<<6
  I64	disp;
};

extern class CRPN; //See AIWNIOS_PrsExp.HC 

class CICTreeLinks
{
  CHashClass *arg1_class,*arg2_class;
  CRPN *arg1_tree,*arg2_tree;
  CHashClass *class2;
};

class CIntermediateCodeBase
{
  CIntermediateCode *next,*last;
  U16	ic_code,
	ic_precedence;
  I16	ic_cnt,
	ic_last_start;
};

class CIntermediateCode:CIntermediateCodeBase
{
  I64	ic_flags,
	ic_data,
	ic_line;
  CHashClass *ic_class,*ic_class2;
  CICArg arg1,arg2,res;
  U8	arg1_type_pointed_to; //Used for $LK,"IST_ASSIGN",A="MN:IST_ASSIGN"$ and $LK,"IST_DEREF",A="MN:IST_DEREF"$ $LK,"ic_codes",A="MN:intermediate_code_table"$.
  union {
    U8 ic_body[IC_BODY_SIZE];
    //Tree Links are created in OptPass012.  An ADD opcode, for example,
    //points back to its two earlier arg CIntermediateCode's.

    //Tree links get destroyed during Pass789A when they get overwrites
    //by machine code.	(Saves room to union the output machine code buffer
    //with these links, since they are not needed after pass4.

    //Tree links are used during passes 012 and 3 for determining types.
    CICTreeLinks t;
  };
};

class CPrsStk
{
  I64	ptr, //This is the shunting yard stack(.u32[1]==PREC,.u32[0]==TYPE)
	stk[255],
	ptr2, //This is the CAlloc'ed CRPN's 
	stk2[255],
  ptr3,
  /* Added by nroot. This is the stack of CRPN's in forward order used to make an AST.
   * if we have 1+2,the stack will be [1,2,+],the 1 and 2 will be poped into a CICTreeLinks and '+' will
   * sit at the bottom
   */
  stk3[255];
};

#define CMT_LABEL		0
#define CMT_ASM_LABEL		1
#define CMT_GOTO_LABEL		2
#define CMT_STR_CONST		3
#define CMT_JMP_TABLE		4
#define CMT_FLOAT_CONSTS	5
#define CMT_ARRAY_DIM		6
#define CMT_HASH_ENTRY		7

#define CMF_POP_CMP		0x01
#define CMF_DEFINED		0x02
#define CMF_I8_JMP_TABLE	0x04
#define CMF_U8_JMP_TABLE	0x08
#define CMF_I16_JMP_TABLE	0x10
#define CMF_U16_JMP_TABLE	0x20
#define CMF_SHORT_ADDR	0x40

#define CM_CONSTS_NUM		16

class CCodeMisc
{
  CCodeMisc *next,*last,*fwd,*dft,*begin;
  U8	*str;
  U32	type,flags;
  I64	use_cnt;
  //
  //Nroot uses this to point to the CCodeMisc's from parser.c
  //
  // Currently aiwnios will start out using the C code generator so you can
  //   port it to other archs easily(->addr)
  
  //addr2 is used for CMT_JMP_TABLE for pointing to the actual table in memory
  U8	*addr,*addr2; 
  union {
    I64 st_len;		//STR_CONST
    I64 num_consts;	//FLOAT_CONSTS
    I64 range;
    I64 rip;		//ASM_LABEL
    I64 offset; //Added by nroot,used for short label's members(CD3.y has an offset of 8)
  }
  union {
    CCodeMisc **jmp_table;
    F64	*float_consts;
    CArrayDim *dim;
    CHash *h;
  };
};

#define IEF_OP_SIZE16		0x001
#define IEF_OP_SIZE32		0x002
#define IEF_PLUS_OPCODE		0x004
#define IEF_DONT_SWITCH_MODES	0x008
#define IEF_DFT			0x010
#define IEF_NOT_IN_64_BIT	0x020
#define IEF_48_REX		0x040
#define IEF_REX_ONLY_R8_R15	0x080
#define IEF_REX_XOR_LIKE	0x100
#define IEF_STI_LIKE		0x200
#define IEF_ENDING_ZERO		0x400

//Slash value
#define SV_R_REG	8
#define SV_I_REG	9
#define SV_STI_LIKE	10 //$LK,"uasm_slash_val",A="FF:::/Compiler/AsmInit.HC,uasm_slash_val"$ only.
#define SV_NONE		11
class CInst
{
  U8	ins_entry_num, //This entry num in opcode hash entry
	opcode_cnt,
	opcode[4];
  U16	flags;
  U8	slash_val,uasm_slash_val,opcode_modifier,
	arg1,arg2,
	size1,size2,//Size in bits
	pad;
};

//x86 opcodes
#define OC_OP_SIZE_PREFIX	0x66
#define OC_ADDR_SIZE_PREFIX	0x67
#define OC_LOCK_PREFIX		0xF0
#define OC_NOP			0x90
#define OC_BPT			0xCC
#define OC_CALL			0xE8
#define OC_JMP_REL8		0xEB
#define OC_NOP2			(OC_NOP<<8+OC_OP_SIZE_PREFIX)

#define PUSH_C_REGS PUSH RAX PUSH RCX PUSH RDX PUSH RBX PUSH R8 PUSH R9
#define POP_C_REGS POP R9 POP R8 POP RBX POP RDX POP RCX POP RAX

#define PUSH_REGS PUSH RAX PUSH RCX PUSH RDX PUSH RBX PUSH RBP PUSH RSI \
PUSH RDI PUSH R8 PUSH R9 PUSH R10 PUSH R11 PUSH R12 PUSH R13 PUSH R14 PUSH R15
#define POP_REGS POP R15 POP R14 POP R13 POP R12 POP R11 POP R10 POP R9 \
POP R8 POP RDI POP RSI POP RBP POP RBX POP RDX POP RCX POP RAX

#define REG_RAX		0
#define REG_RCX		1
#define REG_RDX		2
#define REG_RBX		3
#define REG_RSP		4
#define REG_RBP		5
#define REG_RSI		6
#define REG_RDI		7
#define REG_R8		8
#ifdef TARGET_X86
#define REG_REGS_NUM	16
#endif
#ifdef TARGET_AARCH64
#define REG_REGS_NUM	31
#else
//???
#define REG_REGS_NUM	31
#endif

#define REG_RIP		16	//Used by compiler, not really it's num
//Be careful: RBPu8, RSPu8, RSIu8, RDIu8 are 20-24
#define REG_NONE	32	//noreg flag sets it to this
#define REG_ALLOC	33	//reg flag sets it to this
#define REG_UNDEF	I8_MIN

#define REGG_CLOBBERED		0x013F //RAX,RCX,RDX,RBX,R8
#define REGG_SAVED		0x0030 //RBP,RSP
#define REGG_STK_TMP		0x0200 //R9
#define REGG_LOCAL_VARS		0xCCC0 //RSI,RDI,R10,R11,R14,R15
#define REGG_LOCAL_NON_PTR_VARS	0x3000 //R12,R13

#define AOT_BIN_BLK_BITS 16
#define AOT_BIN_BLK_SIZE (1<<AOT_BIN_BLK_BITS)

class CAOTBinBlk
{
  CAOTBinBlk *next;
  U8	body[AOT_BIN_BLK_SIZE];
};

I64 class CAbsCntsI64
{
  U16	abs_addres, //Only odd/even matters. Cnt of absolute addres in an exp.
	c_addres; //Only odd/even matters. Cnt of C addres in an exp.
  U32	externs; //Only nonzero matters. Some regions have externs banned.
};

class CAsmUndefHash
{//Only place created is $LK,"Exp Parser",A="FF:::/Compiler/PrsExp.HC,sizeof(CAsmUndefHash)"$ when an undef is found in an ASM exp.
  CAsmUndefHash	*next;
  CHashExport	*hash;
};

class CAsmNum
{
  I64	i;
  U8	*machine_code;
  CAsmUndefHash	*local_asm_undef_hash,*glbl_asm_undef_hash;
  CAbsCntsI64 abs_cnts;
};

class CAsmNum2
{
  CAsmNum num;
  I64	U8_cnt,rel;
  Bool	imm_flag;
};

class CAsmIns
{
  CInst *tmpins;
  CAsmNum2 imm,disp;
  I64	U8_cnt,last_opcode_U8,
	REX,ModrM,SIB;
  Bool	has_REX,has_ModrM,has_SIB,
	has_addr_prefix,
	has_operand_prefix,
	is_dft,pad[2];
};

class CAsmArg
{
  CAsmNum num;
  I64	seg,size, //Size in bytes
	reg1,reg2,
	reg1_type,reg2_type,
	scale;
  Bool	indirect,imm_or_off_present,just_seg,pad[5];
};

class CAsmUnresolvedRef
{
  CAsmUnresolvedRef *next;
  I64	type,line_num;
  U8	*machine_code;
  I64	rip,rel_rip;
  CAOT	*aot;
  U8	*str;	//Only for import glbls
  CAsmUndefHash *asm_undef_hash;
  Bool	U8_avail,
	imm_flag;//Only for import glbls
};

//Opcode Modifier
#define OM_NO 0
#define OM_CB 1
#define OM_CW 2
#define OM_CD 3
#define OM_CP 4
#define OM_IB 5
#define OM_IW 6
#define OM_ID 7

#define ARGT_NONE	0
#define ARGT_REL8	1
#define ARGT_REL16	2
#define ARGT_REL32	3

#define ARGT_IMM8	4
#define ARGT_IMM16	5
#define ARGT_IMM32	6
#define ARGT_IMM64	7

#define ARGT_UIMM8	8
#define ARGT_UIMM16	9
#define ARGT_UIMM32	10
#define ARGT_UIMM64	11

#define ARGT_R8		12
#define ARGT_R16	13
#define ARGT_R32	14
#define ARGT_R64	15

#define ARGT_RM8	16
#define ARGT_RM16	17
#define ARGT_RM32	18
#define ARGT_RM64	19

#define ARGT_M8		20
#define ARGT_M16	21
#define ARGT_M32	22
#define ARGT_M64	23

#define ARGT_M1632	24 // Not implemented
#define ARGT_M16N32	25 // Not implemented
#define ARGT_M16N16	26 // Not implemented
#define ARGT_M32N32	27 // Not implemented

#define ARGT_MOFFS8	28
#define ARGT_MOFFS16	29
#define ARGT_MOFFS32	30
#define ARGT_MOFFS64	31

#define ARGT_AL		32
#define ARGT_AX		33
#define ARGT_EAX	34
#define ARGT_RAX	35

#define ARGT_CL		36
#define ARGT_DX		37
#define ARGT_SREG	39

#define ARGT_SS		40
#define ARGT_DS		41
#define ARGT_ES		42
#define ARGT_FS		43

#define ARGT_GS		44
#define ARGT_CS		45
#define ARGT_ST0	46
#define ARGT_STI	47

#define ARGT_MM		48 // Not implemented
#define ARGT_MM32	49 // Not implemented
#define ARGT_MM64	50 // Not implemented
#define ARGT_XMM	51 // Not implemented

#define ARGT_XMM32	52 // Not implemented
#define ARGT_XMM64	53 // Not implemented
#define ARGT_XMM128	54 // Not implemented
#define ARGT_XMM0	55 // Not implemented

#define OCF_ALIAS	1
/*public */ class CHashOpcode:CHash
{
  U16	inst_entry_cnt,
	oc_flags,pad[2];
  CInst ins[1];
};

#define IEF_GOTO_LABEL		1
class CAOTImportExport
{
  CAOTImportExport *next,*last;
  I64	rip,flags,offset; //offset added by nroot(CD3.y has offset of 8)
  CAOT	*aot;
  U8	*str,
	*src_link,
	type,pad[6],
  short_jmp; //short_jmp added by nroot,see IC_SHORT_JMP in the C part of aiwnios
};

#define AAT_ADD_U8		0
#define AAT_SUB_U8		1
#define AAT_ADD_U16		2
#define AAT_SUB_U16		3
#define AAT_ADD_U32		4
#define AAT_SUB_U32		5
#define AAT_ADD_U64		6
#define AAT_SUB_U64		7
class CAOTAbsAddr
{
  CAOTAbsAddr *next;
  I64	rip;
  U8	type,pad[7];
};

class CAOTHeapGlblRef
{
  CAOTHeapGlblRef *next;
  I64	rip;
};

class CAOTHeapGlbl
{
  CAOTHeapGlbl *next;
  U8	*str;
  I64	size;
  CAOTHeapGlblRef *references;
};

class CAOT
{
  CAOT	*next,*last;
  U8	*buf;
  I64	rip,rip2,
	aot_U8s,
	max_align_bits,org;
  CAOT	*parent_aot;
  CAOTImportExport *next_ie,*last_ie;
  CAOTAbsAddr *abss;
  CAOTHeapGlbl *heap_glbls;
};

class CStreamBlk
{
  CStreamBlk *next,*last;
  U8	*body;
};

class CCodeCtrl
{
  CCodeCtrl *coc_next;
  CCodeMisc *coc_next_misc,*coc_last_misc;
  CQue	coc_head; //Changed by NRoot,see CRPN in AIWNIOS_PrsExp.HC 
};

#define __DATE__ #exe{StreamPrint("\"%D\"",Now);}
#define __TIME__ #exe{StreamPrint("\"%T\"",Now);}
#define __LINE__ #exe{StreamPrint("%d",\
	Fs->last_cc->lex_include_stk->line_num);}
#define __CMD_LINE__ #exe{StreamPrint("%d",Fs->last_cc->flags&CCF_CMD_LINE &&\
	Fs->last_cc->lex_include_stk->depth<1);}
#define __FILE__ #exe{StreamPrint("\"%s\"",\
	Fs->last_cc->lex_include_stk->full_name);}
#define __DIR__  #exe{StreamDir;}

#define LFSF_DOC	1
#define LFSF_DEFINE	2
class CLexFile
{
  CLexFile *next;
  U8	*buf,
	*buf_ptr;
  I64	line_num,flags;
  U8	*full_name,
	*line_start;
  CDoc	*doc;
  CDocEntry *cur_entry;
  I32	depth;
  U8	last_U16,pad[3];
};

class CAOTCtrl
{
  I64	rip; //Inst ptr
  CAsmArg arg1,arg2;
  CAOTBinBlk *bin;
  I64	num_bin_U8s,
	max_align_bits,org;
  CAsmUnresolvedRef *local_unresolved,*glbl_unresolved;
  CAOTAbsAddr *abss;
  CAOTHeapGlbl *heap_glbls;
  I64	lst_col,lst_last_rip;
  U8	*last_label,*lst_last_line;
  CLexFile *lst_last_lfn;
  I64	seg_size;
  Bool	lst;
};

//Tokens
#define TK_EOF		0
#define TK_SUPERSCRIPT	0x001
#define TK_SUBSCRIPT	0x002
#define TK_NORMALSCRIPT	0x003
#define TK_IDENT	0x100
#define TK_STR		0x101
#define TK_I64		0x102
#define TK_CHAR_CONST	0x103
#define TK_F64		0x104
#define TK_PLUS_PLUS	0x105
#define TK_MINUS_MINUS	0x106
#define TK_DEREFERENCE	0x107
#define TK_DBL_COLON	0x108
#define TK_SHL		0x109
#define TK_SHR		0x10A
#define TK_EQU_EQU	0x10B
#define TK_NOT_EQU	0x10C
#define TK_LESS_EQU	0x10D
#define TK_GREATER_EQU	0x10E
#define TK_AND_AND	0x10F
#define TK_OR_OR	0x110
#define TK_XOR_XOR	0x111
#define TK_SHL_EQU	0x112
#define TK_SHR_EQU	0x113
#define TK_MUL_EQU	0x114
#define TK_DIV_EQU	0x115
#define TK_AND_EQU	0x116
#define TK_OR_EQU	0x117
#define TK_XOR_EQU	0x118
#define TK_ADD_EQU	0x119
#define TK_SUB_EQU	0x11A
#define TK_IF		0x11B
#define TK_IFDEF	0x11C
#define TK_IFNDEF	0x11D
#define TK_IFAOT	0x11E
#define TK_IFJIT	0x11F
#define TK_ENDIF	0x120
#define TK_ELSE		0x121
#define TK_MOD_EQU	0x122
#define TK_DOT_DOT	0x123
#define TK_ELLIPSIS	0x124
#define TK_INS_BIN	0x125
#define TK_INS_BIN_SIZE 0x126
#define TK_TKS_NUM	0x127

class CLexHashTableContext
{
  CLexHashTableContext *next;
  I64	old_flags,hash_mask;
  CHashFun *local_var_lst,
	*fun;
  CHashTable *hash_table_lst,
	*define_hash_table,
	*local_hash_table,
	*glbl_hash_table;
};

//CmpCtrl flags
#define CCF_CMD_LINE		0x001
#define CCF_PMT			0x002
#define CCf_PMT			1
#define CCF_QUESTION_HELP	0x004
#define CCF_DONT_FREE_BUF	0x008
#define CCF_NO_DEFINES		0x010
#define CCF_IN_IF		0x020
#define CCF_JUST_LOAD		0x040
#define CCF_KEEP_NEW_LINES	0x080
#define CCF_KEEP_DOT		0x100
#define CCF_KEEP_SIGN_NUM	0x200
#define CCF_KEEP_AT_SIGN	0x400
#define CCF_NO_CHAR_CONST	0x800
#define CCf_PASS_TRACE_PRESENT	12
#define CCF_NOT_CONST		0x0000020000
#define CCF_NO_REG_OPT		0x0000040000
#define CCF_IN_QUOTES		0x0000080000
#define CCF_EXE_BLK		0x0000100000
#define CCF_HAS_MISC_DATA	0x0000200000
#define CCF_HAS_RETURN		0x0000400000
#define CCF_ASM_EXPRESSIONS	0x0000800000
#define CCF_UNRESOLVED		0x0001000000
#define CCF_LOCAL		0x0002000000
#define CCF_FUN_EXP		0x0004000000
#define CCf_FUN_EXP		26
#define CCF_POSTINC		0x0008000000
#define CCF_POSTDEC		0x0010000000
#define CCF_PREINC		0x0020000000
#define CCF_PREDEC		0x0040000000
#define CCF_ARRAY		0x0080000000
#define CCF_RAX			0x0100000000
#define CCF_USE_LAST_U16	0x0200000000
#define CCf_USE_LAST_U16	33
#define CCF_LAST_WAS_DOT	0x0400000000
#define CCF_AOT_COMPILE		0x0800000000
#define CCf_AOT_COMPILE		35
#define CCF_NO_ABSS		0x1000000000
#define CCF_PAREN		0x2000000000
#define CCf_PAREN		37
#define CCF_CLASS_DOL_OFFSET	0x4000000000
#define CCF_DONT_MAKE_RES	0x8000000000

/*public */ class CCmpCtrl
{
  CCmpCtrl *next,*last;
  I64	token,
	flags,
	cur_i64;
  F64	cur_f64;
  U8	*cur_str;
  I64	cur_str_len,
	class_dol_offset;
  U8	*dollar_buf;
  I64	dollar_cnt;
  U8	*cur_help_idx;
  I64	last_U16,
	min_line,max_line,last_line_num,
	lock_cnt;
  U32	*char_bmp_alpha_numeric;
  CLexHashTableContext htc;
  CHashGeneric *hash_entry;
  CAbsCntsI64 abs_cnts;
  CAsmUndefHash *asm_undef_hash;
  CMemberLst *local_var_entry;
  CCodeMisc *lb_leave;
  U8	*cur_buf_ptr;
  CLexFile *lex_include_stk,
	*lex_prs_stk,
	*fun_lex_file;
  CStreamBlk *next_stream_blk,*last_stream_blk;
  CAOT	*aot;

  I64	pass,opts,pass_trace,saved_pass_trace,
	error_cnt,warning_cnt;

  //For intermediate codes with multiple float ops (int<->float conversions)
  I64	cur_ic_float_op_num,last_ic_float_op_num;
  CIntermediateCode *last_float_op_ic;
  Bool	last_dont_pushable,last_dont_popable,last_float_op_pos,
	dont_push_float,pad[4];

  CCodeCtrl coc;
  CPrsStk *ps;
  CAOTCtrl *aotc;
  I64	aot_depth,pmt_line;
//Added by nroot,used for @@labels
  I64 asm_local_scope;
};

/*public */ class CCmpGlbls
{
  CHashTable *asm_hash;
  CHashClass *internal_types[RT_RTS_NUM];
  CIntermediateCode ic_nop;
  U32	*dual_U16_tokens1,*dual_U16_tokens2,*dual_U16_tokens3,
	*binary_ops;
  I64	num_reg_vars,num_non_ptr_vars,
	stk_tmps_mask,reg_vars_mask,non_ptr_vars_mask;
  U8	*to_reg_vars_map,*non_ptr_vars_map;
  I64	size_arg_mask[9],
	compiled_lines;
};

class CUAsmGlbls
{
  CInst **table_16_32,**table_64;
  I64	table_16_32_entries,
	table_64_entries,
	ins64_arg_mask,
	signed_arg_mask,
	mem_arg_mask;
};

class CPCIDev
{
  CPCIDev *next,*last;
  U16	vendor,dev_id;
  U8	bus,dev,fun,pad,
	sub_code,base_code,pad[6],
	*vendor_str,*dev_id_str;
};

/*public */ class CATARep
{
  CATARep *next;
  I64	num,type,base0,base1,unit,irq;
};

//See $LK,"::/Doc/Credits.DD"$.
#define ATA_NOP			0x00
#define ATA_DEV_RST		0x08
#define ATA_PACKET		0xA0
#define ATA_READ_NATIVE_MAX	0xF8
#define ATA_READ_NATIVE_MAX_EXT	0x27
#define ATA_SET_MAX		0xF9
#define ATA_SET_MAX_EXT		0x37
#define ATA_READ_MULTI		0xC4
#define ATA_READ_MULTI_EXT	0x29
#define ATA_WRITE_MULTI		0xC5
#define ATA_WRITE_MULTI_EXT	0x39
#define ATA_ID_DEV		0xEC

#define ATAS_ERR	0x01
#define ATAS_DRQ	0x08
#define ATAS_DF		0x20
#define ATAS_DRDY	0x40
#define ATAS_BSY	0x80

#define ATAR0_DATA	0
#define ATAR0_FEAT	1
#define ATAR0_NSECT	2
#define ATAR0_SECT	3
#define ATAR0_LCYL	4
#define ATAR0_HCYL	5
#define ATAR0_SEL	6
#define ATAR0_STAT	7
#define ATAR0_CMD	7
#define ATAR1_CTRL	2

#define FILEMASK_JIT	"*.HC*;*.HH*"
#define FILEMASK_AOT	"*.HC*;*.HH*;*.PRJ*"
#define FILEMASK_SRC	"*.HC*;*.HH*;*.IN*;*.PRJ*"
#define FILEMASK_DD	FILEMASK_SRC ";*.DD*"
#define FILEMASK_TXT	FILEMASK_DD ";*.TXT*"
#define FILEMASK_GR	"*.GR*"

#define BLK_SIZE_BITS	9
#define BLK_SIZE	(1<<BLK_SIZE_BITS)
#define DVD_BLK_SIZE	(4*BLK_SIZE)
#define DVD_BOOT_LOADER_SIZE	DVD_BLK_SIZE*1
#define INVALID_CLUS (-1)

class CMBRPrt
{
  U8	active,	//0x80=active  0x00=inactive
	start_head;
  U16	start_cyl;
  U8	type,
	end_head;
  U16	end_cyl;
  U32	offset,	//Sects between MBR and first sect
	size;	//Sects in drv
};

class CMasterBoot
{
  U8	code[440];
  U32	media_id;
  U16	zero;
  CMBRPrt p[4];
  U16	signature; //AA55
};

class CRedSeaBoot
{
  U8	jump_and_nop[3],
	signature,reserved[4]; //MBR_PT_REDSEA=0x88. Distinguish from real FAT32
  I64	drv_offset,	//For CD/DVD image copy.
	sects,
	root_clus,
	bitmap_sects,
	unique_id;
  U8	code[462];
  U16	signature2;	//0xAA55
};

class CFAT32Boot
{
  U8	jump_and_nop[3],
	oem_name[8];
  U16	bytes_per_sect;
  U8	sects_per_clus;
  U16	reserved_sects;
  U8	copies_of_fat;
  U16	max_root_dir_entries,	//Not used
	old_sects_in_drv;	//Not used
  U8	media_desc;		//F64 for hard disk
  U16	old_sects_per_fat,	//Not used
	sects_per_track,
	num_heads;
  U32	hidden_sects,
	sects,
	sects_per_fat;
  U16	flags,
	version;
  U32	root_clus;
  U16	file_system_info_sect,
	backup_boot_sect;
  U8	reserved[12],
	log_drv_num,
	unused,
	ext_signature; //0x29
  U32	serial_num;
  U8	vol_name[11],
	fat_name[8],
	code[420];
  U16	signature;
};

class CFAT32FileInfoSect
{
  U32	signature1;
  U8	unknown[480];
  U32	signature2,
	free_clus,
	most_recently_alloced;
  U8	reserved[12];
  U32	signature3;
};

class CFAT32DirEntry
{
  U8	name[11],
	attr,
	NTres,
	CrtTimeTenth;
  U16	CrtTime,
	CrtDate,
	LstAccDate,
	clus_hi,
	WrtTime,
	WrtDate,
	clus_lo;
  U32	size;
};

class CFAT32DirEntryLong
{
  U8	ord;
  U16	name1[5];
  U8	attr,
	type,
	xsum;
  U16	name2[6],
	zero,
	name3[2];
};

#define FAT32_ENTRIES_PER_BLK	(BLK_SIZE/sizeof(CFAT32DirEntry))
#define FAT32_ENTRIES_BITS	Bsf(FAT32_ENTRIES_PER_BLK)

class CPalindromeU16
{
  U16	little,big;
};

class CPalindromeU32
{
  U32	little,big;
};

class CATAPITrack
{
  U16	track_info_len;
  U8	track_lo,
	session_lo,
	reserved;
  U16	misc1;
  U8	misc2;
  U32	track_start,
	next_writable,
	free_blks;
  union {
    U32 fixed_packet_size;
    U32 blocking_factor;
  };
  union {
    U32 track_size;
    U32 rzone_end;
  };
  U32	last_recorded;
  U8	track_hi,
	session_hi;
  U16	reserved;
  U32	read_compatibility,
	next_layer_jmp,
	last_layer_jmp;
};

//ISO9660
#define ISOT_BOOT_RECORD	0
#define ISOT_PRI_VOL_DESC	1
#define ISOT_SUPPLEMENTARY_DESC	2
#define ISOT_VOL_DRV_DESC	3
#define ISOT_TERMINATOR		255

class CISODirEntry
{
  U8 pad[2];
  CPalindromeU32 loc;
  U8 pad[24];
};

class CISOPriDesc
{
  U8	type,
	id[5],
	version,
	pad[73];
  CPalindromeU32 vol_space_size;
  U8	pad[32];
  CPalindromeU16 vol_set_size;
  CPalindromeU16 vol_seq_num;
  CPalindromeU16 log_block_size;
  U8	pad[20];
  CISODirEntry root_dir_record;
  U8	pad[128],
	publisher_id[128],
	pad[435],
	file_structure_version,
	pad[1166];
};

//Red Sea Attributes
//See $LK,"ST_FILE_ATTRS",A="MN:ST_FILE_ATTRS"$
#define RS_ATTR_READ_ONLY	0x01 //R
#define RS_ATTR_HIDDEN		0x02 //H
#define RS_ATTR_SYSTEM		0x04 //S
#define RS_ATTR_VOL_ID		0x08 //V
#define RS_ATTR_DIR		0x10 //D
#define RS_ATTR_ARCHIVE		0x20 //A
#define RS_ATTR_LONG_NAME	(RS_ATTR_READ_ONLY|RS_ATTR_HIDDEN|\
				RS_ATTR_SYSTEM|RS_ATTR_VOL_ID)
#define RS_ATTR_LONG_NAME_MASK	(RS_ATTR_LONG_NAME|RS_ATTR_DIR|RS_ATTR_ARCHIVE)
#define RS_ATTR_DELETED		0x100 //X
#define RS_ATTR_RESIDENT	0x200 //T
#define RS_ATTR_COMPRESSED	0x400 //Z
#define RS_ATTR_CONTIGUOUS	0x800 //C
#define RS_ATTR_FIXED		0x1000 //F

//Media types for $LK,"DVDImageWrite",A="MN:DVDImageWrite"$()
#define MT_CD		1
#define MT_DVD		2

//CDirEntry flags (Used by $LK,"FileMgr",A="MN:FileMgr"$())
#define CDIR_FILENAME_LEN	38 //Must include terminator zero
/*public */ class CDirEntry
{
  CDirEntry *next,*parent,*sub;
  U8	*full_name;
  I64	user_data,user_data2;

  U0	start;
  U16	attr;
  U8	name[CDIR_FILENAME_LEN];
  I64	clus,size;
  CDate datetime;
};
#define CDIR_SIZE (sizeof(CDirEntry)-offset(CDirEntry.start))

//File Util Flags
//See $LK,"ST_FILE_UTIL_FLAGS",A="MN:ST_FILE_UTIL_FLAGS"$
#define FUf_RECURSE		0
#define FUf_DIFF		1
#define FUf_DEL			1
#define FUf_IGNORE		2
#define FUf_ALL			3
#define FUf_CANCEL		4
#define FUf_REPLACE		5
#define FUf_RISKY		5
#define FUf_PUBLIC		6
#define FUf_MAP			7
#define FUf_EXPAND		8
#define FUf_SINGLE		9
#define FUf_JUST_DIRS		10
#define FUf_JUST_FILES		11
#define FUf_JUST_TXT		12
#define FUf_JUST_DD		13
#define FUf_JUST_SRC		14
#define FUf_JUST_AOT		15
#define FUf_JUST_JIT		16
#define FUf_JUST_GR		17
#define FUf_Z_OR_NOT_Z		18
#define FUf_CLUS_ORDER	19
#define FUf_SCAN_PARENTS	20
#define FUf_FLATTEN_TREE	21
#define FUf_WHOLE_LABELS	22
#define FUf_WHOLE_LABELS_BEFORE	23
#define FUf_WHOLE_LABELS_AFTER	24

#define FUF_RECURSE		0x0000001 //r
#define FUF_DIFF		0x0000002 //d
#define FUF_DEL			0x0000002 //d
#define FUF_IGNORE		0x0000004 //i
#define FUF_ALL			0x0000008 //a
#define FUF_CANCEL		0x0000010 //c
#define FUF_REPLACE		0x0000020 //R
#define FUF_RISKY		0x0000020 //R
#define FUF_PUBLIC		0x0000040 //p
#define FUF_MAP			0x0000080 //m
#define FUF_EXPAND		0x0000100 //x
#define FUF_SINGLE		0x0000200 //s
#define FUF_JUST_DIRS		0x0000400 //D
#define FUF_JUST_FILES		0x0000800 //F
#define FUF_JUST_TXT		0x0001000 //T
#define FUF_JUST_DD		0x0002000 //$$
#define FUF_JUST_SRC		0x0004000 //S
#define FUF_JUST_AOT		0x0008000 //A
#define FUF_JUST_JIT		0x0010000 //J
#define FUF_JUST_GR		0x0020000 //G
#define FUF_Z_OR_NOT_Z		0x0040000 //Z
#define FUF_CLUS_ORDER	0x0080000 //O Move disk head one direction
#define FUF_SCAN_PARENTS	0x0100000 //P
#define FUF_FLATTEN_TREE	0x0200000 //f
#define FUF_WHOLE_LABELS	0x0400000 //l
#define FUF_WHOLE_LABELS_BEFORE	0x0800000 //lb
#define FUF_WHOLE_LABELS_AFTER	0x1000000 //la

#define FUG_FILES_FIND	(FUF_RECURSE|FUF_SINGLE|FUF_CLUS_ORDER|\
  FUF_JUST_DIRS|FUF_JUST_FILES|FUF_JUST_TXT|FUF_JUST_DD|\
  FUF_JUST_SRC|FUF_JUST_AOT|FUF_JUST_JIT|FUF_JUST_GR|FUF_FLATTEN_TREE)
#define FUG_FILE_FIND	(FUF_JUST_DIRS|FUF_JUST_FILES|FUF_Z_OR_NOT_Z|\
  FUF_SCAN_PARENTS)

//See $LK,"ST_BLKDEV_TYPES",A="MN:ST_BLKDEV_TYPES"$
#define BDT_NULL		0
#define BDT_RAM			1
#define BDT_ATA			2
#define BDT_ISO_FILE_READ	3
#define BDT_ISO_FILE_WRITE	4
#define BDT_ATAPI		5
#define BDT_VIRT		6
#define BDT_TYPES_NUM		7

#define BDF_REMOVABLE		0x001
#define BDF_INITIALIZED		0x002
#define BDF_READ_ONLY		0x004
#define BDF_READ_ONLY_OVERRIDE	0x008
#define BDF_LAST_WAS_WRITE	0x010
#define BDF_READ_CACHE		0x020
#define BDF_FMT			0x040
#define BDF_INIT_IN_PROGRESS	0x080
#define BDF_EXT_SIZE		0x100

#define BDf_REMOVABLE		0
#define BDf_INITIALIZED		1
#define BDf_READ_ONLY		2
#define BDf_READ_ONLY_OVERRIDE	3
#define BDf_LAST_WAS_WRITE	4
#define BDf_READ_CACHE		5
#define BDf_FMT			6
#define BDf_INIT_IN_PROGRESS	7
#define BDf_EXT_SIZE		8

//locked flags
#define BDlf_LOCKED		0

#define BLKDEVS_NUM		26
#define BD_SIGNATURE_VAL	'BDSV'
/*public */ class CBlkDev
{
  CBlkDev *lock_fwding; //If two blkdevs on same controller, use just one lock
  I64	locked_flags;
  U32	bd_signature,
	type,flags;
  U8	first_drv_let,unit,pad[2];
  U32	base0,base1,
	blk_size;
  I64	drv_offset,init_root_dir_blks,
	max_blk;
  U16	*dev_id_record;
  U8	*RAM_dsk,
	*file_dsk_name;
  CFile *file_dsk;
  CTask *owning_task;
  F64	last_time;
  U32	max_reads,max_writes;
};

//Drive locked_flags
#define DVlf_LOCKED	0

//See $LK,"ST_DRV_TYPES",A="MN:ST_DRV_TYPES"$
#define FSt_NULL	0
#define FSt_REDSEA	1 //Supported
#define FSt_FAT32	2 //Supported except for short names, to some degree
#define FSt_ISO9660	3 //Not Supported
#define FSt_NTFS	4 //Not Supported
#define FSt_UNKNOWN	5
#define FSt_VIRT	6
#define FSt_TYPES_NUM	7
#define FSG_TYPE_MASK	(FSt_TYPES_NUM<<1-1)
//File system type flags
#define FStf_DISABLE	16

#define MBR_PT_FAT12	0x01
#define MBR_PT_FAT32a	0x0B
#define MBR_PT_FAT32b	0x0C
#define MBR_PT_FAT32c	0x1B
#define MBR_PT_FAT32d	0x1C
#define MBR_PT_FAT32e	0x8B
#define MBR_PT_FAT32f	0x8C
#define MBR_PT_NTFS	0x07
#define MBR_PT_REDSEA	0x88

class CFreeLst
{
  CFreeLst *next,*last;
  I64	start,size;
};

#define DRVS_NUM		26

#define DRV_SIGNATURE_VAL	'DVSV'
/*public */ class CDrv
{
//Don't access ->drv_let directly in case a drive has been remapped.
  //Use $LK,"Drv2Let",A="MN:Drv2Let"$().
  I64	locked_flags;
  U32	dv_signature;
  U8	drv_let,pad;
  U16	fs_type;
  I64	drv_offset,
	size,
	prt_num,
	file_system_info_sect,
	fat1,fat2,
	root_clus,
	data_area,
	spc; //sectors per clus
  CDate fat32_local_time_offset;
  CTask *owning_task;
  CBlkDev *bd;

  CFAT32FileInfoSect *fis;
  I64	fat_blk_dirty,
	cur_fat_blk_num;
  U32	*cur_fat_blk;
  CFreeLst *next_free,*last_free;
};

#define DSK_CACHE_HASH_SIZE	0x2000

class CCacheBlk
{
  CCacheBlk *next_lru,*last_lru;
  CCacheBlk *next_hash,*last_hash;
  CDrv	*dv;
  I64	blk;
  U8	body[BLK_SIZE];
};

#define DFT_ISO_FILENAME	"::/Tmp/CDDVD.ISO"
#define DFT_ISO_C_FILENAME	"::/Tmp/CDDVD.ISO.C"

/*public */ class CBlkDevGlbls
{
  CBlkDev *blkdevs;
  U8	*dft_iso_filename;	//$TX,"\"::/Tmp/CDDVD.ISO\"",D="DFT_ISO_FILENAME"$
  U8	*dft_iso_c_filename;	//$TX,"\"::/Tmp/CDDVD.ISO.C\"",D="DFT_ISO_C_FILENAME"$
  U8	*tmp_filename;
  U8	*home_dir;
  CCacheBlk *cache_base,*cache_ctrl,**cache_hash_table;
  I64	cache_size,read_cnt,write_cnt;
  CDrv	*drvs,*let_to_drv[32];
  I64	mount_ide_auto_cnt,
	ins_base0,ins_base1;	//Install cd/dvd controller.
  U8	boot_drv_let,first_hd_drv_let,first_dvd_drv_let;
  Bool	dvd_boot_is_good,ins_unit,pad[3];
};

/*public */ class CDirContext
{
  CDrv	*old_dv,*dv;
  U8	*old_dir,*mask;
};

#define FFB_NEXT_BLK		I64_MAX

#define FF_WRITE		1
#define FF_NEW_FILE		2
#define FF_BUF_DIRTY		4
#define FF_NEEDS_WRITE		8
#define FF_CONTIGUOUS		16
#define FF_USE_OLD_DATETIME	32

/*public */ class CFile //See $LK,"::/Demo/Dsk/DataBase.HC"$.
{
  I64	flags;
  CDirEntry de;
  CDrv	*dv;
  I64	fblk_num,clus,file_clus_num,max_blk;
  U8	*clus_buf,*_3days_virt;
};

#define _CFG_HEAP_DBG FALSE


class CMemUnused
{
  U0	hc;
  U0	caller1,caller2;
  CMemUnused *next;
  I64	size;
};
class CMemUsed
{
  CHeapCtrl *hc;
  U0	caller1,caller2;
  U0	next,last;
  I64	size;
  U0	start;
};


#define MBS_USED_SIGNATURE_VAL		'MBUs'
#define MBS_UNUSED_SIGNATURE_VAL	'MBUn'
class CMemBlk
{
  CMemBlk *next,*last;
  U32	mb_signature,pags;
};

#define MRT_UNUSED	0
#define MRT_RAM		1
#define MRT_DEV		2

class CMemRange
{
  CMemRange *next,*last;
  U32	type,flags;
  U8	*base;
  I64	size;
};

#define MEM_PAG_BITS		9
#define MEM_PAG_SIZE		(1<<MEM_PAG_BITS)
#define MEM_HEAP_HASH_SIZE	1024
#define MEM_FREE_PAG_HASH_SIZE	0x100
//It is common to $LK,"MAlloc",A="MN:MAlloc"$() exact powers of two.  There is some overhead.
//We add 2 pags, so a request is not rounded-up to next power of two.
#define MEM_EXTRA_HASH2_PAGS	2

#define MEM_ADAM_STK		(MEM_PAG_SIZE*512) //Like 16384*MEM_PAG_SIZE
#define MEM_SETH_STK		(MEM_PAG_SIZE*512)
#define MEM_INTERRUPT_STK	(MEM_PAG_SIZE*512)
#define MEM_DFT_STK		(MEM_PAG_SIZE*512)

#define TASK_HASH_TABLE_SIZE	(1<<10)

//locked flags
#define BPlf_LOCKED		0
/*public */ class CBlkPool
{
  I64	locked_flags,alloced_u8s,used_u8s;
  CMemBlk *mem_free_lst,
	*mem_free_2meg_lst, //This is for Sup1CodeScraps/Mem/Mem2Meg.HC.
	*free_pag_hash[MEM_FREE_PAG_HASH_SIZE],
	*free_pag_hash2[64-MEM_PAG_BITS];
};

//locked flags
#define HClf_LOCKED		0

#define HEAP_CTRL_SIGNATURE_VAL	'HcSV'
/*public */ class CHeapCtrl
{
  CBlkPool *bp;
  U32	hc_signature,pad;
  I64	locked_flags,alloced_u8s,used_u8s;
  CTask *mem_task;
  CMemBlk *next_mem_blk,*last_mem_blk;
  CMemBlk *last_mergable;
  CMemUnused *malloc_free_lst;
  CMemUsed *next_um,*last_um;
  CMemUnused *heap_hash[MEM_HEAP_HASH_SIZE/sizeof(U8 *)];
};

/*public */ class CDevGlbls
{
  I64	*idt;
  U8	*mem64_ptr;
  U8	*uncached_alias; //Alias of lowest 4Gig.
  U8	mp_apic_ids[MP_PROCESSORS_NUM];
  CMemRange mem32_head;
  CPCIDev pci_head;
};

//Raster operations
#define ROPB_EQU			0x00
#define ROPB_XOR			0x01
#define ROPB_COLLISION			0x02
#define ROPB_MONO			0x03
#define ROPBF_HALF_RANGE_COLOR		0x10
#define ROPBF_TWO_SIDED			0x20
#define ROPBF_DITHER			0x40
#define ROPBF_PROBABILITY_DITHER	0x80

#define ROP_EQU				(ROPB_EQU<<8)
#define ROP_XOR				(ROPB_XOR<<8)
#define ROP_COLLISION			(ROPB_COLLISION<<8)
#define ROP_MONO			(ROPB_MONO<<8)

//These are just for $LK,"ROPF_PROBABILITY_DITHER",A="MN:ROPF_PROBABILITY_DITHER"$
//See $LK,"DCLighting",A="MN:DCLighting"$().
#define ROPF_HALF_RANGE_COLOR		0x1000
#define ROPF_TWO_SIDED			0x2000

//These always go in the c1.rop of a CColorROPU32
#define ROPF_DITHER			0x40000000
#define ROPF_PROBABILITY_DITHER		0x80000000

#define TRANSPARENT		0xFF
#define BLACK			0
#define BLUE			1
#define GREEN			2
#define CYAN			3
#define RED			4
#define PURPLE			5
#define BROWN			6
#define LTGRAY			7
#define DKGRAY			8
#define LTBLUE			9
#define LTGREEN			10
#define LTCYAN			11
#define LTRED			12
#define LTPURPLE		13
#define YELLOW			14
#define WHITE			15

#define COLORS_NUM		16
#define COLOR_INVALID		16
#define COLOR_MONO		0xFF

/*public */ U16 class CColorROPU16 //Don't use this, use CColorROPU32
{
  U8	color,rop;
};
/*public */ U32 class CColorROPU32
{
  CColorROPU16 c0,c1;
};
#define COLORROP_COLORS_MASK	0x00FF00FF
#define COLORROP_NO_ROP0_MASK	0xFFFF00FF
#define COLORROP_BITS		16
/*public */ U32 class CBGR24
{
  U8	b,g,r,pad;
};
/*public */ I64 class CBGR48
{
  U16	b,g,r,pad;
};

#define KBD_PORT	0x60
#define KBD_CTRL	0x64
/*public */ class CKbdStateGlbls
{
  I64	scan_code,	//See $LK,"scan codes",A="FI:::/Doc/CharOverview.DD"$
	last_down_scan_code,
	cnt,		//Count of keys pressed since boot.
	timestamp,	//Output: GetTSC when event.
	new_key_timestamp; //Output: GetTSC when new key event.
  CFifoU8 *fifo,*fifo2; //Private
  CFifoI64 *scan_code_fifo,*scan_code_fifo2;

  //BitTest, $LK,"Bt",A="MN:Bt"$(), with a merged scan code.
  //(Left and right shift merged, for example.)
  U32	down_bitmap[8],
//BitTest, $LK,"Bt",A="MN:Bt"$(), with an unmerged scan code.
	down_bitmap2[8];

  Bool	rst,		//Private: Reset KbdMs
	irqs_working;	//Private
};

/*public */ class CMsHardStateGlbls
{
  CD3I64 pos,		//Position in pixels
	prescale;
  CD3	scale;
  F64	speed;		//Output: How fast the user is moving it.
  I64	timestamp,	//Output: GetTSC when event.
	install_attempts, //Private
	pkt_size;	//Private
  CFifoU8 *fifo,*fifo2; //Private
  Bool	bttns[5],
	has_wheel,
	has_ext_bttns,
	evt,		//Private
	installed,	//Private
	install_in_progress, //Private
	irqs_working;	//Private
};

/*public */ class CMsStateGlbls
{
  CD3I64 pos,		//Position in pixels
	pos_text,	//Position in text rows,cols
	presnap,
	offset;
  CD3	scale;
  F64	speed;		//Output: How fast the user is moving it.
  I64	timestamp;	//Output: GetTSC when event.
  F64	dbl_time,	//Input: Time threshold for calling it a double click.
	left_dbl_time,	//Private
	right_dbl_time;	//Private
  Bool	lb,		//Left Bttn
	rb,		//Right Bttn
	show,
	has_wheel,
	left_dbl,	//Private
	left_down_sent, //Private
	right_dbl,	//Private
	right_down_sent;//Private
};


public class CGridGlbls
{
  Bool	snap	format "\dCB,\"Snap Grid\"\d\n",
	show	format "\dCB,\"Show Grid\"\d\n",
	coord	format "\dCB,\"Show Coordinates\"\d\n";
  U8	pad[5];
  F64	x	format "\dDA-TRM,A=\"X Spacing:%6.3f\"\d\n",
	y	format "\dDA-TRM,A=\"Y Spacing:%6.3f\"\d\n",
	z	format "\dDA-TRM,A=\"Z Spacing:%6.3f\"\d\n",
	x_offset format "\dDA-TRM,A=\"X Offset :%6.3f\"\d\n",
	y_offset format "\dDA-TRM,A=\"Y Offset :%6.3f\"\d\n",
	z_offset format "\dDA-TRM,A=\"Z Offset :%6.3f\"\d\n",
	x_speed	format "\dDA-TRM,A=\"X Speed  :%6.3f\"\d\n",
	y_speed	format "\dDA-TRM,A=\"Y Speed  :%6.3f\"\d\n",
	z_speed	format "\dDA-TRM,A=\"Z Speed  :%6.3f\"\d\n";
};

#define CTRLT_GENERIC		0
#define CTRLT_WIN_HSCROLL	1 //unique
#define CTRLT_WIN_VSCROLL	2 //unique
#define CTRLT_VIEWING_ANGLES	3 //unique

#define CTRLF_SHOW		1
#define CTRLF_BORDER		2
#define CTRLF_CAPTURE_LEFT_MS	4
#define CTRLF_CAPTURE_RIGHT_MS	8
#define CTRLF_CLICKED		16

#define WSSf_SET_TO_POS		0

/*public */ class CWinScroll
{
  I64	min,pos,max;
  U32	flags;
  U8	color,pad[3];
};

/*public */ class CViewAngles
{
  I64	sx,sy,sz;
  F64	ax,ay,az;
  CColorROPU32 cx,cy,cz,cbd,cbg,cfg;
};

/*public */ class CCtrl
{
  CCtrl *next,*last;
  CTask *win_task;
  I64	type,flags;

  //win pix coordinates
  I64	left,right,top,bottom;

  //scrn pix coordinates (derived)
  I64	scrn_left,scrn_right,scrn_top,scrn_bottom;

  U8	*state;

  //called on resize
  U0	(*update_derived_vals)(CCtrl *c);
  U0	(*draw_it)(CDC *dc,CCtrl *c);

  Bool	(*inside_ctrl)(CCtrl *c,I64 x,I64 y); //For nonbox shapes
  U0	(*left_click)(CCtrl *c,I64 x,I64 y,Bool down);
  U0	(*right_click)(CCtrl *c,I64 x,I64 y,Bool down);
  U0	(*wheel_chg)(CCtrl *c,I64 delta);
};

/*public */ class CMenuEntry
{
  CMenuEntry *next;
  CMenuEntry *sub;
  U8	name[32];
  I64	msg_code,arg1,arg2;
  Bool	checked,dir,pad[6];
};

/*public */ class CMenu
{
  CMenu *next;
  CMenuEntry *sub;
  CTask *task;
  I64	flags;
  U8	attr,pad[7];
};

class CBpt
{
  CBpt	*next;
  //On ARM64 all the insts are 32bit
  U32	*addr,val;
};

class CExcept
{
  CExcept *next,*last;
  I64 AARCH64_except_pad[2048];
};

class CFPU
{
  U8	body[512];
};

#define JOBf_WAKE_MASTER	0
#define JOBf_FOCUS_MASTER	1
#define JOBf_EXIT_ON_COMPLETE	2
#define JOBf_DONT_FILTER	3
#define JOBf_HIGHEST_PRIORITY	4
//MP flags
#define JOBf_DONE		5
#define JOBf_DISPATCHED		6
#define JOBf_FREE_ON_COMPLETE	7
#define JOBf_ADD_TO_QUE		8

#define JOBT_TEXT_INPUT		0 //$LK,"TaskText",A="MN:TaskText"$()	Feed StdIn
#define JOBT_MSG		1 //$LK,"TaskMsg",A="MN:TaskMsg"$()	Post msg
#define JOBT_EXE_STR		2 //$LK,"TaskExe",A="MN:TaskExe"$()	Compile & execute src code text
//MP cmds
#define JOBT_CALL		3 //$LK,"JobQue",A="MN:JobQue"$()	Tell MP to call function
#define JOBT_SPAWN_TASK		4 //$LK,"Spawn",A="MN:Spawn"$()	Tell MP to spawn task

class CJob
{
  CJob *next,*last;
  CJobCtrl *ctrl;
  I64	job_code,flags,msg_code;

  I64	(*addr)(U8 *fun_arg);
  U8	*fun_arg;

  U8	*aux_str;
  I64	aux1,aux2, //Sometimes called arg1 and arg2. (Windows msg param1 param2)
	res;

  CTask	*spawned_task,
	*master_task;
};

#define JOBCf_LOCKED		0
class CJobCtrl
{
  CJob *next_waiting,*last_waiting;
  CJob *next_done,*last_done;
  I64	flags;
};

//See $LK,"::/Demo/MsgLoop.HC"$
#define MSG_NULL		0
#define MSG_CMD			1
#define MSG_KEY_DOWN		2  //($LK,"ASCII",A="MN:CH_CTRLA"$,$LK,"scan code",A="FI:::/Doc/CharOverview.DD"$) Press <CTRL-SHIFT-L>
#define MSG_KEY_UP		3  //($LK,"ASCII",A="MN:CH_CTRLA"$,$LK,"scan code",A="FI:::/Doc/CharOverview.DD"$) Press <CTRL-SHIFT-L>
#define MSG_MS_MOVE		4  //(x,y)
#define MSG_MS_L_DOWN		5  //(x,y)
#define MSG_MS_L_UP		6  //(x,y)
#define MSG_MS_L_D_DOWN 	7  //(x,y)
#define MSG_MS_L_D_UP		8  //(x,y)
#define MSG_MS_R_DOWN		9  //(x,y)
#define MSG_MS_R_UP		10 //(x,y)
#define MSG_MS_R_D_DOWN 	11 //(x,y)
#define MSG_MS_R_D_UP		12 //(x,y)

//Fake messages used to send both an up and down.
#define MSG_KEY_DOWN_UP		-2  //Down & UP
#define MSG_MS_L_DOWN_UP	-5  //Down & Up
#define MSG_MS_L_D_DOWN_UP	-7  //Down & Up
#define MSG_MS_R_DOWN_UP	-9  //Down & Up
#define MSG_MS_R_D_DOWN_UP	-11 //Down & Up

#define TSF_SAME_SONG	1
/*public */ class CTaskSettings
{
  CTaskSettings *next;
  U8	*cur_dir;
  I64	left,right,top,bottom;
  U0	(*draw_it)(CTask *task,CDC *dc);
  U0	(*task_end_cb)();
  CTask *song_task,*animate_task;
  I64	scroll_x,scroll_y,scroll_z;
  CBGR48 palette[COLORS_NUM];
  U32	win_inhibit;
  U8	text_attr,title_src,
	border_attr,border_src,
	task_title[STR_LEN];
  Bool	border,hide_cursor,highlight_cursor,scroll,autocomplete,pad[3];
};

//CTask.border_src
#define BDS_CONST		0
#define BDS_CUR_DRV		1
#define BDS_ED_FILENAME_DRV	2

//CTask.title_src
#define TTS_CONST		0
#define TTS_LOCKED_CONST	1 //This is not strictly enforced
#define TTS_TASK_NAME		2
#define TTS_ED_FILENAME		3
#define TTS_CUR_LEX		4

//CTask.task_flags
#define TASKf_TASK_LOCK		0
#define TASKf_KILL_TASK		1
#define TASKf_SUSPENDED		2
#define TASKf_IDLE		3
#define TASKf_CMD_LINE_PMT	4
#define TASKf_INPUT_FILTER_TASK	5
#define TASKf_FILTER_INPUT	6
#define TASKf_HAS_SONG		7
#define TASKf_DISABLE_BPTS	8
#define TASKf_AWAITING_MSG	9
#define TASKf_BREAK_LOCKED	10
#define TASKf_PENDING_BREAK	11
#define TASKf_BREAK_TO_SHIFT_ESC 12
#define TASKf_KILL_AFTER_DBG	13

#define TASKf_NONTIMER_RAND	14

//CTask.display_flags
#define DISPLAYf_SHOW			0
#define DISPLAYf_NOT_RAW		1
#define DISPLAYf_SILENT			2
#define DISPLAYf_NO_BORDER		3
#define DISPLAYf_WIN_ON_TOP		4
#define DISPLAYf_CHILDREN_NOT_ON_TOP	5

#define TASK_SIGNATURE_VAL		'TskS'
#define TASK_NAME_LEN			32
#define TASK_EXCEPT_CALLERS		8
class CTaskStk
{
  CTaskStk *next_stk;
  I64	stk_size,stk_ptr;
  U0	stk_base;
};

#define DYING_JIFFIES	ToI64(JIFFY_FREQ/5)
class CTaskDying
{
  CTask *next,*last;
  I64	wake_jiffy;
};

/*public */ class CTask //The Fs segment reg points to current CTask.
{
  CTask *addr; //Self-addressed ptr
  U32	task_signature,win_inhibit;
  I64	wake_jiffy;
  U32	task_flags,display_flags;

  CHeapCtrl *code_heap,*data_heap;

  CDoc	*put_doc,*display_doc, //When double buffering, these two differ.
	*border_doc;
  I64	win_left,win_right,win_top,win_bottom;

  CDrv	*cur_dv;
  U8	*cur_dir;

  CTask *parent_task,
	*next_task,*last_task,
	*next_input_filter_task,*last_input_filter_task,
	*next_sibling_task,*last_sibling_task,
	*next_child_task,*last_child_task;

  //These are derived from left,top,right,bottom
  I64	win_width,win_height,
	pix_left,pix_right,pix_width, //These are in pixs, not characters
	pix_top,pix_bottom,pix_height,
	scroll_x,scroll_y,scroll_z;

  //These must be in this order
  //for $LK,"TASK_CONTEXT_SAVE",A="FF:::/Kernel/Sched.HC,TASK_CONTEXT_SAVE"$ and $LK,"_TASK_CONTEXT_RESTORE",A="FF:::/Kernel/Sched.HC,_TASK_CONTEXT_RESTORE"$
  I64	context_save_area[2048/8];
  CCPU	*gs;
  CFPU	*fpu_mmx;
  I64	swap_cnter;

  U0	(*draw_it)(CTask *task,CDC *dc);

  U8	task_title[STR_LEN],
	task_name[TASK_NAME_LEN],
	wallpaper_data[STR_LEN],

	title_src,border_src,
	text_attr,border_attr;
  U16	win_z_num,pad;

  U8 *stk;

  CExcept *next_except,*last_except;
  I64	except_rbp,	//throw routine's RBP
	except_ch;	//throw(ch)
  U8	*except_callers[TASK_EXCEPT_CALLERS];

  Bool	catch_except;
  Bool	new_answer;
  U8	answer_type,pad[5];
  I64	answer;
  F64	answer_time;
  CBpt	*bpt_lst;
  CCtrl	*next_ctrl,*last_ctrl;
  CMenu	*cur_menu;
  CTaskSettings *next_settings;
  CMathODE *next_ode,*last_ode;
  F64	last_ode_time;
  CHashTable *hash_table;

  CJobCtrl srv_ctrl;
  CCmpCtrl *next_cc,*last_cc;
  CHashFun *last_fun;

  U0	(*task_end_cb)();
  CTask *song_task,*animate_task;
  I64	rand_seed,
	task_num,
	fault_num,fault_err_code;
  CTask *popup_task,
	*dbg_task;
  CWinScroll horz_scroll,vert_scroll;

  I64	user_data,user_data2,is_single_step;
};

class CTSS
{
  U32	res1;
  I64	rsp0,rsp1,rsp2,res2,
	ist1,ist2,ist3,ist4,ist5,ist6,ist7,res3;
  U16	res4,io_map_offset;
  U8	io_map[0x10000/8];
  I64	*st0,*st1,*st2;
  U16	tr,tr_ring3;
};

#define ans	(Fs->answer)
#define ansf	(Fs->answer(F64))

#define _RAX Fs->rax
#define _RBX Fs->rbx
#define _RCX Fs->rcx
#define _RDX Fs->rdx
#define _RSI Fs->rsi
#define _RDI Fs->rdi
#define _RBP Fs->rbp
#define _RSP Fs->rsp
#define _RIP Fs->rip
#define _R8  Fs->r8
#define _R9  Fs->r9
#define _R10 Fs->r10
#define _R11 Fs->r11
#define _R12 Fs->r12
#define _R13 Fs->r13
#define _R14 Fs->r14
#define _R15 Fs->r15

#define CPUf_RAN_A_TASK		0
#define CPUf_DYING_TASK_QUE	1

public class CCPU //The Gs segment reg points to current CCPU.
{
  CCPU	*addr; //Self-addressed ptr
  I64	num,cpu_flags,
	startup_rip,
	idle_pt_hits;
  F64	idle_factor;
  I64	total_jiffies;
  CTask *seth_task,*idle_task;
  I64	tr,   //task reg
	swap_cnter;
  U0	(*profiler_timer_irq)(CTask *task);
  CTaskDying *next_dying,*last_dying;
  I64	kill_jiffy;
  CTSS	*tss;
  I64	start_stk[16];
  I64 ready;
};

#define MEM_MIN_MEG		512 //512 Meg minimum.

#define SYS_FIXED_AREA		0x100000
#define SYS_16MEG_AREA_LIMIT	0x1000000
/*public */ class CSysFixedArea
{
  CFPU	init_fpu_mmx;
  CCPU	boot_cpu;
  CTask	adam;
  CBlkPool sys_code_bp;
  CHeapCtrl adam_hc;
};

#define CH_CTRLA	0x01
#define CH_CTRLB	0x02
#define CH_CTRLC	0x03
#define CH_CTRLD	0x04
#define CH_CTRLE	0x05
#define CH_CTRLF	0x06
#define CH_CTRLG	0x07
#define CH_CTRLH	0x08
#define CH_CTRLI	0x09
#define CH_CTRLJ	0x0A
#define CH_CTRLK	0x0B
#define CH_CTRLL	0x0C
#define CH_CTRLM	0x0D
#define CH_CTRLN	0x0E
#define CH_CTRLO	0x0F
#define CH_CTRLP	0x10
#define CH_CTRLQ	0x11
#define CH_CTRLR	0x12
#define CH_CTRLS	0x13
#define CH_CTRLT	0x14
#define CH_CTRLU	0x15
#define CH_CTRLV	0x16
#define CH_CTRLW	0x17
#define CH_CTRLX	0x18
#define CH_CTRLY	0x19
#define CH_CTRLZ	0x1A
#define CH_CURSOR	0x05
#define CH_BACKSPACE	0x08
#define CH_ESC		0x1B
#define CH_SHIFT_ESC	0x1C
#define CH_SHIFT_SPACE	0x1F
#define CH_SPACE	0x20

#define ST_ERR_ST   "$$LTRED$$$$BK,1$$ERROR:$$FG$$$$BK,0$$ "
#define ST_WARN_ST  "$$RED$$$$BK,1$$WARNING:$$FG$$$$BK,0$$ "

//Scan code flags
#define SCf_E0_PREFIX	7
#define SCf_KEY_UP	8
#define SCf_SHIFT	9
#define SCf_CTRL	10
#define SCf_ALT 	11
#define SCf_CAPS	12
#define SCf_NUM 	13
#define SCf_SCROLL	14
#define SCf_NEW_KEY	15
#define SCf_MS_L_DOWN	16
#define SCf_MS_R_DOWN	17
#define SCf_DELETE	18
#define SCf_INS		19
#define SCf_NO_SHIFT	30
#define SCf_KEY_DESC	31
#define SCF_E0_PREFIX	(1<<SCf_E0_PREFIX)
#define SCF_KEY_UP	(1<<SCf_KEY_UP)
#define SCF_SHIFT	(1<<SCf_SHIFT)
#define SCF_CTRL	(1<<SCf_CTRL)
#define SCF_ALT		(1<<SCf_ALT)
#define SCF_CAPS	(1<<SCf_CAPS)
#define SCF_NUM		(1<<SCf_NUM)
#define SCF_SCROLL	(1<<SCf_SCROLL)
#define SCF_NEW_KEY	(1<<SCf_NEW_KEY)
#define SCF_MS_L_DOWN	(1<<SCf_MS_L_DOWN)
#define SCF_MS_R_DOWN	(1<<SCf_MS_R_DOWN)
#define SCF_DELETE	(1<<SCf_DELETE)
#define SCF_INS 	(1<<SCf_INS)
#define SCF_NO_SHIFT	(1<<SCf_NO_SHIFT)
#define SCF_KEY_DESC	(1<<SCf_KEY_DESC)

//TempleOS places a 1 in bit 7 for
//keys with an E0 prefix.
//See $LK,"::/Doc/CharOverview.DD"$ and $LK,"KbdHndlr",A="MN:KbdHndlr"$().
#define SC_ESC		0x01
#define SC_BACKSPACE	0x0E
#define SC_TAB		0x0F
#define SC_ENTER	0x1C
#define SC_SHIFT	0x2A
#define SC_CTRL		0x1D
#define SC_ALT		0x38
#define SC_CAPS		0x3A
#define SC_NUM		0x45
#define SC_SCROLL	0x46
#define SC_CURSOR_UP	0x48
#define SC_CURSOR_DOWN	0x50
#define SC_CURSOR_LEFT	0x4B
#define SC_CURSOR_RIGHT 0x4D
#define SC_PAGE_UP	0x49
#define SC_PAGE_DOWN	0x51
#define SC_HOME		0x47
#define SC_END		0x4F
#define SC_INS		0x52
#define SC_DELETE	0x53
#define SC_F1		0x3B
#define SC_F2		0x3C
#define SC_F3		0x3D
#define SC_F4		0x3E
#define SC_F5		0x3F
#define SC_F6		0x40
#define SC_F7		0x41
#define SC_F8		0x42
#define SC_F9		0x43
#define SC_F10		0x44
#define SC_F11		0x57
#define SC_F12		0x58
#define SC_PAUSE	0x61
#define SC_GUI		0xDB
#define SC_PRTSCRN1	0xAA
#define SC_PRTSCRN2	0xB7

//text.raw_flags
#define RWF_IN_DOLLAR	1
#define RWF_LAST_DOLLAR	2
#define RWF_SHOW_DOLLAR	4
#define RWF_SCROLL	8

/*public */ class CTextGlbls
{
  I64	raw_col,raw_flags;
  U8	*raw_scrn_image;
  I64	rows,cols;		//Use TEXT_ROWS,TEXT_COLS
  U64	*font,*aux_font;
  U8	*vga_alias,*vga_text_alias;
  U8	border_chars[16];
};

#define FONT_WIDTH	8
#define FONT_HEIGHT	8

#define GR_WIDTH	640
#define GR_HEIGHT	480

//z-vals less than zero are in front of scrn and not drawn.
//we want to shift all Z-vals into a drawable range.
//GR_Z_ALL is set to half of the Z-range which is an I32.
#define GR_Z_ALL	(I32_MAX/2)

//Low 8 bits reserved for flags that go into saved bitmaps
#define DCF_COMPRESSED		1
#define DCF_PALETTE		2
#define DCF_NO_TRANSPARENTS	4 //Can be used to optimized $LK,"GrBlot",A="MN:GrBlot"$().

#define DCF_TRANSFORMATION	0x100

//See $LK,"DCSymmetrySet",A="MN:DCSymmetrySet"$() or $LK,"DCSymmetry3Set",A="MN:DCSymmetry3Set"$()
#define DCF_SYMMETRY		0x200

//Must be used with DCF_SYMMETRY set also.
//See $LK,"::/Demo/Games/BigGuns.HC"$
#define DCF_JUST_MIRROR		0x400

#define DCF_LOCATE_NEAREST	0x800
#define DCF_DONT_DRAW		0x1000
#define DCF_ALIAS		0x2000
#define DCF_SCRN_BITMAP		0x4000
#define DCF_FILL_NOT_COLOR	0x8000
#define DCF_RECORD_EXTENTS	0x10000
#define DCF_ON_TOP		0x20000

//$LK,"DCSave",A="MN:DCSave"$() flags.
#define DCSF_COMPRESSED		1
#define DCSF_PALETTE_GET	2

#define DCS_SIGNATURE_VAL	'DvCS'

class CGrSym
{
  I32	sx,sy,sz,pad;
//Normal of symmetry plane
  I64	snx,sny,snz;
};

/*public */ class CDC
{
  U0	start;
  CDate cdt;
  I32	x0,y0,
	width,width_internal,
	height,
	flags;
  U0	end;
  CBGR48 palette[COLORS_NUM];

  ///*public */ (Change directly)
  CColorROPU32 color,
	bkcolor, //Set for use with $LK,"ROP_COLLISION",A="MN:ROP_COLLISION"$
	color2; //Internally used for $LK,"GrFloodFill",A="MN:GrFloodFill"$()
  CD3I32 ls; //Light source (should be normalized to 65536).

  //dither_probability_u16 is basically a U16.
  //It is activated by $LK,"ROPF_PROBABILITY_DITHER",A="MN:ROPF_PROBABILITY_DITHER"$.
  //0x0000 =100% color.c0
  //0x8000 =50%  color.c0   50% color.c1
  //0x10000=100% color.c1
  //See $LK,"::/Demo/Graphics/SunMoon.HC"$ and	$LK,"::/Demo/Graphics/Shading.HC"$.
  U64 dither_probability_u16;

  CDC *brush;

  //Set with $LK,"DCMat4x4Set",A="MN:DCMat4x4Set"$().  $LK,"Free",A="MN:Free"$() before setting.
  I64	*r, //rotation matrix of quads decimal in lo
	r_norm; //shifted 32 bits.  Used for scaling thick

  ///*public */ (Change directly)
  I32	x,y,z,
	thick;

  //Can be changed from the default $LK,"DCTransform",A="MN:DCTransform"$()
  U0	(*transform)(CDC *dc,I64 *x,I64 *y,I64 *z);

  //Can be changed from the default $LK,"DCLighting",A="MN:DCLighting"$()
  U0	(*lighting)(CDC *dc,CD3I32 *p1,CD3I32 *p2,
	CD3I32 *p3,CColorROPU32 color);

  //Set by $LK,"DCSymmetrySet",A="MN:DCSymmetrySet"$() or $LK,"DCSymmetry3Set",A="MN:DCSymmetry3Set"$()
  CGrSym sym;

  I32	cur_x,cur_y,cur_z,pad;
  I64	collision_cnt;

  I64	nearest_dist,
	min_x,max_x,min_y,max_y; //Set by $LK,"DCF_RECORD_EXTENTS",A="MN:DCF_RECORD_EXTENTS"$ (scrn coordinates)

  U32	dc_signature,pad;
  CTask	*mem_task,*win_task;
  CDC	*alias;
  U8	*body;

  //Set by $LK,"DCDepthBufAlloc",A="MN:DCDepthBufAlloc"$()
  I32	*depth_buf;
  I64	db_z; //private
};

//VGA Memory
#define VGAM_GRAPHICS	0xA0000
#define VGAM_TEXT	0xB8000

//VGA I/O ports
#define VGAP_ATTR_INDEX		0x03C0
#define VGAP_ATTR_DATA_WRITE	0x03C0 //alias
#define VGAP_ATTR_DATA_READ	0x03C1
#define VGAP_MISC_OUTPUT	0x03C2
#define VGAP_IDX		0x03C4
#define VGAP_DATA		0x03C5
#define VGAP_PALETTE_MASK	0x03C6
#define VGAP_REG_READ		0x03C7
#define VGAP_REG_WRITE		0x03C8
#define VGAP_PALETTE_DATA	0x03C9
#define VGAP_CRTC_INDEX		0x03D4
#define VGAP_CRTC_DATA		0x03D5
#define VGAP_INPUT_STAT		0x03DA

//VGA Registers
#define VGAR_MAP_MASK		0x02

#define ARC_BITS_MAX	12

#define CT_NONE 	1
#define CT_7_BIT	2
#define CT_8_BIT	3
class CArcEntry
{
  CArcEntry *next;
  U16	basecode;
  U8	ch,pad;
  U32	pad;
};

/*public */ class CArcCtrl
{
  I64	src_pos,src_size,
	dst_pos,dst_size;
  U8	*src_buf,*dst_buf;
  I64	min_bits,min_table_entry;
  CArcEntry *cur_entry,*next_entry;
  I64	cur_bits_in_use,next_bits_in_use;
  U8	*stk_ptr,*stk_base;
  I64	free_idx,free_limit,
	saved_basecode,
	entry_used,
	last_ch;
  CArcEntry compress[1<<ARC_BITS_MAX],
	*hash[1<<ARC_BITS_MAX];
};

/*public */ class CArcCompress
{
  I64	compressed_size,expanded_size;
  U8	compression_type;
  U0	body;
};

//GetStr flags
#define GSF_SHIFT_ESC_EXIT	1 //This kills task on <SHIFT-ESC>
#define GSF_WITH_NEW_LINE	2

//Flags for StrUtil and MStrUtil
#define SUF_REM_CTRL_CHARS	0x001
#define SUF_REM_LEADING		0x002
#define SUF_REM_TRAILING	0x004
#define SUF_REM_SPACES		0x008
#define SUF_SINGLE_SPACE	0x010
#define SUF_TO_UPPER		0x020
#define SUF_TO_LOWER		0x040
#define SUF_S2T			0x080
#define SUF_T2S			0x100 // Only works with MStrUtil
#define SUF_SCALE_INDENT	0x200
#define SUF_SAFE_DOLLAR		0x400

//Flags for StrFind
#define SFF_IGNORE_CASE		1
#define SFF_WHOLE_LABELS_BEFORE	2
#define SFF_WHOLE_LABELS_AFTER	4
#define SFG_WHOLE_LABELS	(SFF_WHOLE_LABELS_BEFORE|SFF_WHOLE_LABELS_AFTER)

//Flags for LstMatch
#define LMF_IGNORE_CASE		1
#define LMF_EXACT		2

#define KDF_HAS_DESCS	1
class CKeyDevEntry
{
  CKeyDevEntry *next,*last;
  I64	priority,flags;
  Bool	(*put_key)(I64 ch,I64 sc);
  Bool	(*put_s)(U8 *st);
};

class CKeyDevGlbls
{
  CKeyDevEntry put_key_head;
  //U0	(**fp_ctrl_alt_cbs)(I64 sc); Changed by nroot
  U8 **fp_ctrl_alt_cbs;
  I64	ctrl_alt_in_irq_flags,
	**ctrl_alt_ret_addr; //addr of ret addr on stack in kbd irq
  U8	**ctrl_alt_no_shift_descs,**ctrl_alt_shift_descs,
	desc[STR_LEN],
	*hndlr;
};

/*public */ class CAUData
{//Fmt of AU files
  CDate	cdt;
  I8	ona;
};

class CSndData
{//Fmt recorded in mem
  CSndData *next,*last;
  F64	tS;
  I8	ona;
};

/*public */ class CScrnCastGlbls
{
  CSndData snd_head;
  CDate	t0_now;
  F64	t0_tS;
  U8	*print_fmt;
  CDC	*dc,*dc2_alias;
  Bool	record,just_audio;
  I8	ona;
};

#define FUN_SEG_CACHE_SIZE	256
class CFunSegCache
{
  I64	base,limit;
  F64	time_stamp;
  U8	str[1]; //FUN_SEG_CACHE_STR_LEN
};
#define FUN_SEG_CACHE_STR_LEN	(sizeof(CFunSegCache)-offset(CFunSegCache.str))

class CMPCrash
{
  I64	cpu_num;
  CTask *task;
  I64	rip;
  U8	*msg;
  I64	msg_num;
};

/*public */ class CDbgGlbls
{
  CTask *focus_task;
  U8	*msg;
  I64	msg_num;
  CMPCrash *mp_crash;
  U8	*int_fault_code,
	*fix_file_line;
  CFunSegCache *fun_seg_cache;
  I64	fun_seg_cache_index;
  Bool	panic;
};

//Boot related
#define BOOT_RAM_BASE		0x07C00
#define BOOT_RAM_LIMIT		0x97000
#define BOOT_STK_SIZE		BLK_SIZE

#define BOOT_SRC_NULL		0
#define BOOT_SRC_ROM		1
#define BOOT_SRC_RAM		2
#define BOOT_SRC_HARDDRV	3
#define BOOT_SRC_DVD		4

// $LK,"In",A="MN:In"$("") StdIn for call to $LK,"BootHDIns",A="MN:BootHDIns"$().
#define STD_DISTRO_DVD_CFG	"TB\nScale2Mem(2048,0x40000)\nT \n\n\n\n"

//Registry sys_msg_flags. $LK,"RegOneTimePopUp",A="MN:RegOneTimePopUp"$()
#define ARf_FLOODFILL			0
#define ARf_CSPRITE_INS_CLIP		1
#define ARf_PLANAR_SYMMETRY		2
#define ARf_PSALMODY_JUKEBOX		3
#define ARf_MESH_ED			4
#define ARf_CSPRITE_PTS_RECTANGLES	5
#define ARf_MANAGE_SLIDER		6

#define PROGRESS_BARS_NUM	4
#define PROGRESS_DESC_LEN	(64-8-8)
class CProgress
{
  I64	val,max;
  F64	t0,tf;
  U8	desc[PROGRESS_DESC_LEN];
};

#define PRTF_PAD_ZERO		0x001
#define PRTF_LEFT_JUSTIFY	0x002
#define PRTF_TRUNCATE		0x004
#define PRTF_COMMA		0x008
#define PRTF_DOLLAR		0x010
#define PRTF_SLASH		0x020
#define PRTF_QUESTION		0x040
#define PRTF_AUX_FMT_NUM	0x080
#define PRTF_DECIMAL		0x100
#define PRTF_NEG		0x200
#define PRTF_NEG_E		0x400
#define PRTF_NEG_AUX_FMT_NUM	0x800

//Host Operating System
#define OS_OTHER	0
#define OS_NATIVE	1
#define OS_LINUX	2
#define OS_WINDOWS	3
//Virtual Machine
#define VM_OTHER	0
#define VM_NATIVE	1
#define VM_VMWARE	2
#define VM_QEMU		3
#define VM_VIRTUALBOX	4


#ifdef IMPORT_AIWNIOS_SYMS
//From AIWNIOS
import U8 *MPSetProfilerInt(U0 (*fp)(U8 *fs),I64 c,I64);
import U8 *BoundsCheck(U8 *ptr,I64 *oob_bytes);
import I64 Call(U8 *,I64 argc,I64 *argv);
import U0 ExitAiwnios();
import U0 TaskContextSetRIP(U8 *,U8 *);
import U0 MakeContext(U8 *,U8 *rip,U8*rsp);
import U8 *AiwniosGetClipboard();
import U0 AiwniosSetClipboard(U8 *);
import U0 InteruptCore(I64);
import F64 Exp(F64);
import U0 __HC_CmpCtrl_SetAOT(U8 *);
import U0 ImportSymbolsToHolyC(U8 (*cb)(U8*,U8*));
import U0 __Sleep(I64);
import U0 __SleepHP(I64);
import I64 __GetTicksHP();
import I64 LBtc(U8*,I64);
import F64 Ln(F64);
import F64 Arg(F64,F64); //ATAN2
import F64 Tan(F64);
import F64 Sin(F64);
import F64 Cos(F64);
import F64 ATan(F64);
import F64 ASin(F64);
import F64 ACos(F64);
import U0 UpdateScreen(U8*,I64,I64,I64);
import U0 DrawWindowNew();
import U0 __GrPaletteColorSet(I64,CBGR48);
import U8 *HeapCtrlInit(U8 *DO_NOT_USE,CTask *,I64 is_code);
import U0 HeapCtrlDel(U8 *);
import U8 *__MAlloc(I64i sz,CTask *t=NULL);
import U8 *__CAlloc(I64i sz,CTask *t=NULL);
import U8 *__StrNew(U8 *,CTask *t=NULL);
import U0 DbgPutS(U8 *);
import U0 PrintI(U8 *,I64);
import U0 PrintF(U8 *,F64);
import U0 Free(U8 *);
import U0 MemCpy(U8*,U8*,I64);
import I64 MSize(U8i *);
import U8 *MemSet(U8i *,U8 ch,I64 sz);
import U8 *MemSetU16(U16 *,U16 ch,I64 sz);
import U8 *MemSetU32(U32 *,U32 ch,I64 sz);
import U8 *MemSetU64(U64 *,U64 ch,I64 sz);
import I64 StrLen(I64);
import I64 StrCmp(U8*,U8*);
import U64 ToUpper(U64);
import U64 Bt(U8 *,I64);
import U64 Btr(U8 *,I64);
import U64 Bts(U8 *,I64);
import U64 Btc(U8 *,I64);
import F64 Log10(F64);
import F64 Log2(F64);
import F64 Pow10(F64);
import F64 Round(F64);
import F64 Floor(F64);
import F64 Ceil(F64);
import I64 Bsf(I64);
import I64 Bsr(I64);
import U0 PutS(U8*);
import CTask *Fs();
import U0 SetFs(CTask *);
import I64 AIWNIOS_SetJmp(I64 *); //Returns 1 if called,else 0 if LongJmped to
import U0 AIWNIOS_LongJmp(I64 *);
import I64 __GetTicks();
import Bool IsValidPtr(U8*);
#define MSize2 MSize
import U64 LBtr(U8 *,I64);
import U64 LBts(U8 *,I64);
import U8 *Caller(I64 c=0);
import I64 UnixNow();
import U0 VFsFTrunc(U8i*,I64i);
import U8i *VFsFOpenR(U8i*);
import U8i *VFsFOpenW(U8i*);
import U0 VFsFClose(U8i*);
import U0 VFsFBlkRead(U8i*,I64i,I64i,U8i*);
import U0 VFsFBlkWrite(U8i*,I64i,I64i,U8i*);
import U0 VFsFSeek(I64i,U8i*);
import U0 VFsSetPwd(U8i*);
import U0 VFsSetDrv(U8i);
import Bool VFsExists(U8i*);
import Bool VFsIsDir(U8i*);
import I64i VFsFSize(U8i*);
import U8i *VFsFRead(U8i*,I64i*);
import U8i *VFsDirMk(U8i*);
import U8i *VFsFWrite(U8i*,U8i*,I64i);
import Bool VFsDel(U8i*);
import U8i **VFsDir();
import I64 FSize(U8*);
import I64 FUnixTime(U8*);
import U0 VFsFTrunc(U8*,I64);
import F64 Sqrt(F64);
import I64 MemCmp(U8*,U8*,I64);
import Bool _SixtyFPS();
import U0 SetKBCallback(U8 *fptr);
import U0 SetMSCallback(U8 *fptr);
import U0 SndFreq(I64);
import F64 Pow(F64,F64);
import CCPU *Gs();
import U0 SetGs(CCPU *);
import I64 mp_cnt();
import U0 SpawnCore(U0(*fp)(I64),CCPU *,I64 );
import U0 MPSleepHP(I64);
import U0 MPAwake(I64);
#else
extern U8 *MPSetProfilerInt(U0 (*fp)(U8 *fs),I64 c,I64);
extern I64 Call(U8 *,I64 argc,I64 *argv);
extern U0 ExitAiwnios();
extern U0 MakeContext(U8 *,U8 *rip,U8*rsp);
extern F64 Ln(F64);
extern U8 *AiwniosGetClipboard();
extern U0 AiwniosSetClipboard(U8 *);
extern U64 Btr(U8 *,I64);
extern U64 Bts(U8 *,I64);
extern U64 Btc(U8 *,I64);
extern I64 mp_cnt();
extern CCPU *Gs();
extern U0 SetGs(CCPU *);
extern U8 *BoundsCheck(U8 *ptr,I64 *oob_bytes);
extern F64 Pow(F64,F64);
extern U0 SndFreq(I64);
extern U0 __SleepHP(I64);
extern I64 __GetTicksHP();
extern U0 ImportSymbolsToHolyC(U8 (*cb)(U8*,U8*));
extern U0 SetKBCallback(U8 *fptr);
extern U0 SetMSCallback(U8 *fptr);
extern U0 __Sleep(I64);
extern F64 Arg(F64,F64); //ATAN2
extern F64 Tan(F64);
extern F64 Sin(F64);
extern F64 Cos(F64);
extern F64 ATan(F64);
extern F64 ASin(F64);
extern F64 ACos(F64);
//From AIWNIOS
extern F64 Exp(F64);
extern I64 MemCmp(U8*,U8*,I64);
extern U8 *HeapCtrlInit(U8 *DO_NOT_USE,CTask *,I64 is_code);
extern U0 HeapCtrlDel(U8 *);
extern U8 *__MAlloc(I64i sz,CTask *t=NULL);
extern U8 *__CAlloc(I64i sz,CTask *t=NULL);
extern U8 *__StrNew(U8 *,CTask *t=NULL);
extern U0 DbgPutS(U8 *);
extern U0 PrintI(U8 *,I64);
extern U0 PrintF(U8 *,F64);
extern U0 Free(U8 *);
extern U0 MemCpy(U8*,U8*,I64);
extern I64 MSize(U8i *);
extern U8 *MemSet(U8i *,U8 ch,I64 sz);
extern U8 *MemSetU16(U16 *,U16 ch,I64 sz);
extern U8 *MemSetU32(U32 *,U32 ch,I64 sz);
extern U8 *MemSetU64(U64 *,U64 ch,I64 sz);
extern I64 StrLen(I64);
extern I64 StrCmp(U8*,U8*);
extern U64 ToUpper(U64);
extern U64 Bt(U8 *,I64);
extern F64 Log10(F64);
extern F64 Log2(F64);
extern F64 Pow10(F64);
extern F64 Round(F64);
extern F64 Floor(F64);
extern F64 Ceil(F64);
extern I64 Bsf(I64);
extern I64 Bsr(I64);
extern U0 PutS(U8*);
extern CTask *Fs();
extern U0 SetFs(CTask *);
extern I64 AIWNIOS_SetJmp(I64 *); //Returns 1 if called,else 0 if LongJmped to
extern U0 AIWNIOS_LongJmp(I64 *);
extern I64 __GetTicks();
extern Bool IsValidPtr(U8*);
#define MSize2 MSize
extern U64 LBtr(U8 *,I64);
extern U64 LBts(U8 *,I64);
extern U8 *Caller(I64 c=0);
//EVIL things from AIWNIOS to be reworked
extern I64 UnixNow();
extern U0 VFsFTrunc(U8i*,I64i);
extern U8i *VFsFOpenR(U8i*);
extern U8i *VFsFOpenW(U8i*);
extern U0 VFsFClose(U8i*);
extern U0 VFsFBlkRead(U8i*,I64i,I64i,U8i*);
extern U0 VFsFBlkWrite(U8i*,I64i,I64i,U8i*);
extern U0 VFsFSeek(I64i,U8i*);
extern U0 VFsSetPwd(U8i*);
extern U0 VFsSetDrv(U8i);
extern Bool VFsExists(U8i*);
extern Bool VFsIsDir(U8i*);
extern I64i VFsFSize(U8i*);
extern U8i *VFsFRead(U8i*,I64i*);
extern U8i *VFsDirMk(U8i*);
extern U8i *VFsFWrite(U8i*,U8i*,I64i);
extern Bool VFsDel(U8i*);
extern U8i **VFsDir();
extern I64 FSize(U8*);
extern I64 FUnixTime(U8*);
extern U0 VFsFTrunc(U8*,I64);
extern F64 Sqrt(F64);
#endif
extern U8 *FileRead(U8 *,I64 *,I64 *attr=NULL);
extern U0 FileWrite(U8 *filename,U8 *fbuf,I64 size,CDate cdt=0,I64 attr=0);

extern I64 Cmp(U8 *filename,U8 *map_name=NULL,U8 *out_name=NULL,U8 mapfile_drv_let=0);

//Forward declarations
extern Bool DirMk(U8 *filename,I64 entry_cnt=0);
extern U8 *MStrPrint(U8 *fmt,...);
extern U8 *StrPrint(U8 *dst,U8 *fmt,...);
extern U0 TaskRstAwaitingMsg(CTask *task=NULL);
extern U0 TaskWait(CTask *task=NULL,Bool cmd_line_pmt=FALSE);
extern U0 XTalk(CTask *task,U8 *fmt,...);
extern U0 JobCtrlInit(CJobCtrl *ctrl);
extern U0 JobQueDel(CJob *head);
extern I64 JobRunOne(I64 run_flags,CJobCtrl *ctrl);
extern U8 *SysTry();
extern U0 throw(I64 ch=0,Bool no_log=FALSE);
extern U0 EndCatch();
extern U0 SysUntry();
extern CHashTable *HashTableNew(I64 size,CTask *mem_task=NULL);
extern I64 Str2I64(U8 *st,I64 radix=10,U8 **_end_ptr=NULL);
extern U0 StrPrintFunSeg(U8 *buf,I64 addr,I64 field_len,I64 flags);
extern U8 *Define(U8 *dname);
extern U8 *DefineSub(I64 sub,U8 *dname);
extern U0 DrvsRelease();
extern U0 BlkDevsRelease();
extern U8 Drv2Let(CDrv *dv=NULL);
extern Bool FileFind(U8 *filename,CDirEntry *_de=NULL,I64 fuf_flags=FUF_Z_OR_NOT_Z);
extern Bool IsDir(U8*);
extern Bool _SixtyFPS();
extern CBlkDev *BlkDevChk(CBlkDev *bd,Bool except=TRUE); 
extern CDrv *Let2Drv(U8 drv_let=0,Bool except=TRUE);
extern Bool RedSeaValidate(U8 drv_let);
extern U0 RedSeaInit(CDrv *dv);
extern U0 RedSeaFmt(U8 drv_let,Bool quick=TRUE);
extern CFile *FOpen(U8 *filename,U8 *flags,I64 cnt=0,CTask *mem_task=NULL);
extern U0 DskCacheInvalidate(CDrv *dv);
extern I64 Let2BlkDevType(U8 drv_let);
extern U0 DrvBlkDevDel(CBlkDev *bd);
extern U0 FClose(CFile *f);
extern CDrv *DrvChk(CDrv *dv,Bool except=TRUE);
extern U8 Let2Let(U8 drv_let=0);
extern U0 RedSeaFreeFreeLst(CDrv *dv);
extern Bool BlkRead(CDrv *dv,U8 *buf, I64 blk, I64 cnt);
extern Bool BlkWrite(CDrv *dv,U8 *buf, I64 blk, I64 cnt);
extern Bool ISOInit(CDrv *dv,I64 blk);
extern Bool Drv(U8 drv_let);
extern Bool FBlkRead(CFile *f,U8 *buf,I64 blk=FFB_NEXT_BLK,I64 cnt=1);
extern Bool FBlkWrite(CFile *f,U8 *buf,I64 blk=FFB_NEXT_BLK,I64 cnt=1);
extern I64 RedSeaAllocClus(CDrv *dv,I64 cnt);
extern I64 FAT32AllocContiguousClus(CDrv *dv,I64 cnt);
extern I64 FAT32AllocClus(CDrv *dv,I64 c,I64 cnt);
extern Bool CFileNameTo(U8 *dst,U8 *src);
extern CDate Str2Date(U8 *_src);
extern Bool Cd(U8 *dirname=NULL,Bool make_dirs=FALSE);
extern U0 DirEntryDel(CDirEntry *tmpde);
extern Bool RedSeaFileFind(CDrv *dv,I64 cur_dir_clus,U8 *name,
	CDirEntry *_res,I64 fuf_flags=0);
extern Bool FAT32FileFind(CDrv *dv,I64 cur_dir_clus,
	U8 *name,CDirEntry *_res,I64 fuf_flags=0);
extern U0 FAT32Init(CDrv *dv);
extern Bool RedSeaDirNew(CDrv *dv,U8 *cur_dir,CDirEntry *tmpde,Bool free_old_chain);
extern Bool FAT32DirNew(CDrv *dv,U8 *cur_dir,CDirEntry *tmpde,Bool free_old_chain);
extern Bool DrvTypeSet(U8 drv_let,I64 type=FSt_REDSEA);
extern I64 Del(U8 *files_find_mask,Bool make_mask=FALSE,
	Bool del_dir=FALSE,Bool print_msg=TRUE);
extern U0 Refresh(I64 cnt=1,Bool force=FALSE);
extern U8 DrvTextAttrGet(U8 drv_let=0);
extern Bool TaskValidate(CTask *task);
extern U8 *LexStmt2Bin(CCmpCtrl *cc,I64 *_type,I64 cmp_flags=0);
extern F64 tS();
extern I64 JobsHndlr(I64 run_flags,CTask *task=NULL);
extern U0 PutExcept(Bool catch_it=TRUE);
extern I64 FlushMsgs(CTask *task=NULL);
extern U0 ACDDef(I64 n,CTask *parent=NULL);
extern U0 ACDDefsPut(CDoc *doc=NULL,U8 *st,I64 num=-1);
extern U0 ACDFillin(I64 n);
extern U0 ACFillIn(I64 n);
extern U0 ACMan(I64 n,CTask *parent_task=NULL);
extern I64 AdamFile(U8 *filename,Bool warn_ext=TRUE);
extern Bool AutoComplete(Bool val=OFF);
extern U0 ClipDel();
extern CCtrl *CtrlFindUnique(CTask *haystack_task,I64 needle_type);
extern Bool CtrlInside(CCtrl *c,I64 x,I64 y);
extern U8 *DC2Sprite(CDC *tmpb);
extern U0 DocBinDel(CDoc *doc,CDocBin *b);
extern U0 DocBinsValidate(CDoc *doc);
extern U0 DocBottom(CDoc *doc=NULL);
extern U0 DocCenter(CDoc *doc=NULL,I64 recalc_flags=RECALCt_NORMAL);
extern U0 DocClear(CDoc *doc=NULL,Bool clear_holds=FALSE);
extern Bool DocCursor(Bool show=OFF,CDoc *doc=NULL);
extern U0 DocD(U8 *buf,I64 cnt=0x80);
extern U0 DocDataFmt(CDoc *doc,CDocEntry *doc_e,I64 d=DOCM_CANCEL);
extern U0 DocDel(CDoc *doc);
extern CDoc *DocDisplay(CTask *task=NULL);
extern U0 DocDump(CDoc *doc,I64 uS_delay=0);
extern CDocEntry *DocEntryCopy(CDoc *doc,CDocEntry *doc_e);
extern U0 DocEntryDel(CDoc *doc,CDocEntry *doc_e);
extern Bool DocForm(U8 *_d,U8 *class_name=lastclass,
	I64 dof_flags=0,U8 *header=NULL,U8 *footer=NULL);
extern U0 DocHelpIdx(CDoc *doc,U8 *idx);
extern Bool DocHighlightCursor(Bool show=OFF,CDoc *doc=NULL);
extern U0 DocInsDoc(CDoc *doc=NULL,CDoc *doc2);
extern U0 DocInsEntry(CDoc *doc,CDocEntry *doc_e);
extern Bool DocLock(CDoc *doc);
extern I64 DocMax(I64 i=I64_MAX);
extern CDoc *DocNew(U8 *filename=NULL,CTask *task=NULL);
extern CDocEntry *DocPrint(CDoc *doc=NULL,U8 *fmt,...);
extern CDoc *DocPut(CTask *task=NULL);
extern CDoc *DocRead(U8 *name=NULL,I64 flags=0);
extern Bool DocRecalc(CDoc *doc,I64 recalc_flags=RECALCt_NORMAL);
extern U0 DocRst(CDoc *doc,Bool is_old);
extern CDocEntry *DocSprite(CDoc *doc=NULL,U8 *elems,U8 *fmt=NULL);
extern U0 DocTop(CDoc *doc=NULL);
extern Bool DocUnlock(CDoc *doc);
extern U0 DocUpdateTaskDocs(CTask *task);
extern U0 DrawCtrls(CTask *task);
extern Bool Ed(U8 *link_st,I64 edf_dof_flags=0);
extern U0 EdCodeTools(CDoc *doc);
extern U8 *EdSprite(I64 bin_num);
extern I64 ExeDoc(CDoc *doc,I64 ccf_flags=0);
extern I64 FindWiz();
extern I64 GetI64(U8 *msg=NULL,I64 dft=0,I64 lo=I64_MIN,I64 hi=I64_MAX);
extern Bool GrPlot0(CDC *dc,I64 x,I64 y);
extern CMenuEntry *MenuEntryFind(CMenu *haystack_menu,U8 *needle_full_name);
extern CMenu *MenuFilePush(U8 *filename);
extern U0 MenuPop();
extern CMenu *MenuPush(U8 *st);
extern U8 Mount(Bool caller_is_prtdsk=FALSE);
extern CTask *Noise(I64 mS,F64 min_ona,F64 max_ona);
extern Bool Plain(U8 *filename,I64 edf_dof_flags=0);
extern Bool PopUpCancelOk(U8 *header=NULL,U8 *footer=NULL);
extern I64 PopUpColor(U8 *header=NULL,
	Bool allow_transparent=TRUE,Bool allow_dft=TRUE);
extern I64 PopUpColorDither(U8 *header=NULL);
extern I64 PopUpColorLighting(U8 *header=NULL);
extern I64 PopUpFile(U8 *filename,
	Bool warn_ext=TRUE,CTask *parent=NULL,CTask **_pu_task=NULL);
extern Bool PopUpForm(U8 *_d,U8 *class_name=lastclass,
	I64 dof_flags=DOF_SIZE_MIN,U8 *header=NULL,U8 *footer=NULL);
extern I64 PopUpGetI64(U8 *msg,I64 dft,I64 lo=I64_MIN,I64 hi=I64_MAX);
extern U8 *PopUpGetStr(U8 *header=NULL);
extern I64 PopUpMenu(CDoc *doc,I64 dof_flags=0);
extern Bool PopUpNoYes(U8 *header=NULL,U8 *footer=NULL);
extern Bool PopUpOk(U8 *header=NULL,U8 *footer=NULL);
extern I64 PopUpRangeI64(
	I64 lo,I64 hi,I64 step=1,U8 *header=NULL,U8 *footer=NULL);
extern Bool PopUpTransform(I64 *r);
extern I64 RedSeaISO(U8 *_iso_filename=NULL,U8 *_src_dir,
	U8 *_stage2_filename=NULL);
extern U0 Refresh(I64 cnt=1,Bool force=FALSE);
extern U0 RegOneTimePopUp(I64 flag_num,U8 *msg);
extern Bool RegWrite(U8 *path,U8 *fmt,...);
extern U0 SettingsPop(CTask *task=NULL,I64 flags=0);
extern CTaskSettings *SettingsPush(CTask *task=NULL,I64 flags=0);
extern U0 TemplateCtrlSlider(CDoc *doc);
extern Bool View();
extern U0 ViewAnglesDel(CTask *task=NULL);
extern CCtrl *ViewAnglesNew(CTask *task=NULL);
extern Bool WinBorder(Bool val=OFF,CTask *task=NULL);
extern CDoc *WinCursorPosSet(CTask *task,I64 msx,I64 msy,Bool set_cursor=TRUE);
extern Bool WinHorz(I64 left,I64 right,CTask *task=NULL);
extern U0 WinMax(CTask *task=NULL);
extern U0 WinScrollNull(CTask *task,CD3I64 *s);
extern U0 WinScrollRestore(CTask *task,CD3I64 *s);
extern U0 WinScrollsInit(CTask *task);
extern I64 WinToTop(CTask *task=NULL,Bool update_z_buf=TRUE);
extern Bool WinVert(I64 top,I64 bottom,CTask *task=NULL);
extern CWinMgrGlbls winmgr;
extern U0 MsHardSet(I64 x,I64 y,I64 z,I64 l,I64 r);
extern U8 *GetStr(U8 *msg=NULL,U8 *dft=NULL,I64 flags=0);
extern U0 UserStartUp();
extern U0 DocPrintPartial(CDoc *doc=NULL,U8 *fmt,...);
extern U0 GetOutOfDollar();
public extern CDoc *DocPut(CTask *task=NULL);
public extern CDoc *DocDisplay(CTask *task=NULL);
public extern CDoc *DocBorder(CTask *task=NULL);
public extern CDoc *DocDblBufStart(CTask *task=NULL);
public extern Bool DocDblBufEnd(CTask *task=NULL);
public extern Bool DocDblBufSwap(CTask *task=NULL);
public extern Bool View();
extern U8 *EdOverStrikeCB(CDoc *,CDocEntry *doc_e,CTask *mem_task);
extern U8 *EdAutoSaveCB(CDoc *,CDocEntry *doc_e,CTask *mem_task);
extern U8 *EdFilterCB(CDoc *,CDocEntry *doc_e,CTask *mem_task);
extern U8 *EdDollarCB(CDoc *,CDocEntry *doc_e,CTask *mem_task);
extern U8 *EdMoreCB(CDoc *,CDocEntry *doc_e,CTask *mem_task);
extern U8 *EdDollarTypeCB(CDoc *,CDocEntry *doc_e,CTask *mem_task);
public extern Bool DocEd(CDoc *doc,I64 dof_flags=0);
public extern Bool Ed(U8 *link_st,I64 edf_dof_flags=0);
public extern Bool Plain(U8 *filename,I64 edf_dof_flags=0);
public extern I64 PopUpEd(U8 *filename,CTask *parent=NULL,CTask **_pu_task=NULL);
public extern U0 DocLoad(CDoc *doc,U8 *src2,I64 size);
public extern CDoc *DocRead(U8 *name=NULL,I64 flags=0);
public extern U8 *DocSave(CDoc *doc,I64 *_size=NULL);
public extern Bool DocWrite(CDoc *doc,Bool prompt=FALSE);
public extern U0 DocInsDoc(CDoc *doc=NULL,CDoc *doc2);
public extern U0 StreamDoc(CDoc *doc);
extern Bool DocCaptureUndo(CDoc *doc,Bool force=FALSE);
extern U0 DocUndoRestore(CDoc *doc);
public extern Bool DocType(CDoc *doc=NULL,U8 *filename,I64 trailing_new_lines=1);
public extern Bool Type(U8 *filename,I64 trailing_new_lines=1);
public extern U8 *DocLineRead(U8 *filename,I64 line,CTask *mem_task=NULL)
public extern U8 *DocLineWrite(U8 *filename,I64 line,U8 *st);
public extern Bool DocGoToLine(CDoc *doc,I64 line_num);
public extern Bool DocFind(CDoc *haystack_doc,I64 start_line_num=I64_MIN,
U8 *needle,I64 match=1);
public extern Bool DocAnchorFind(CDoc *haystack_doc,U8 *needle_str);
public extern U0 EdFindNext(CDoc *doc);
public extern U0 EdSelAll(CDoc *doc,Bool sel);
public extern Bool EdFindPaired(CDoc *doc,U8 plus,U8 minus,
Bool fwd,Bool abort_on_dbl_colon=FALSE);
public extern Bool EdGoToFun(CDoc *doc,Bool fwd,Bool abort_on_dbl_colon);
public extern U0 EdSelFun(CDoc *doc,Bool abort_on_dbl_colon=FALSE);
#define RSAC_REPLACE	0
#define RSAC_SKIP	1
#define RSAC_ALL	2
extern I64 PopUpReplaceSkipAllCancel(U8 *header=NULL,U8 *footer=NULL);
extern I64 EdFindReplace(CDoc *doc);
public extern I64 EdReplace(CDoc *doc,U8 *find,U8 *replace,
  Bool sel=TRUE,Bool match_case=TRUE,Bool whole_labels=FALSE);
class CEdLineGoTo
{
  I64 line format "$$DA,A=\"Go to Line:%d\"$$";
};
extern U0 EdGoToLine(CDoc *doc);
public extern Bool DocForm(U8 *_d,U8 *class_name=lastclass,
    I64 dof_flags=0,U8 *header=NULL,U8 *footer=NULL);
public extern I64 DocMenu(CDoc *m,I64 dof_flags=0);
public extern I64 PopUpMenu(CDoc *doc,I64 dof_flags=0);
public extern Bool PopUpForm(U8 *_d,U8 *class_name=lastclass,
	I64 dof_flags=DOF_SIZE_MIN,U8 *header=NULL,U8 *footer=NULL);
extern U0 EdUndoFilter(CDoc *doc);
public extern I64 DocGetKey(I64 *_sc=NULL);
public extern U8 *DocScanLine(CDoc *doc,CDocEntry *doc_e,
	I64 *cur_col=NULL,CDocEntry **_do_e_end=NULL);
extern U8 *DocGetStr2(I64 flags=0);
public extern I64 GetI64(U8 *msg=NULL,I64 dft=0,I64 lo=I64_MIN,I64 hi=I64_MAX);
public extern F64 GetF64(U8 *msg=NULL,F64 dft=0,F64 lo=F64_MIN,F64 hi=F64_MAX);
public extern CDate GetDate(U8 *msg=NULL,CDate dft=I64_MIN,
	CDate lo=I64_MIN,CDate hi=I64_MAX);
public extern I64 PopUpColor(U8 *header=NULL,
	Bool allow_transparent=TRUE,Bool allow_dft=TRUE);
public extern I64 PopUpColorLighting(U8 *header=NULL);
class CTransformForm
{
  F64 x_scale	format "$$DA-TRM,A=\"X Scale :%12.6f\"$$\n";
  F64 y_scale	format "$$DA-TRM,A=\"Y Scale :%12.6f\"$$\n";
  F64 z_scale	format "$$DA-TRM,A=\"Z Scale :%12.6f\"$$\n";
  F64 a_z	format "\nAngles are in degrees\n"
		       "$$DA-TRM,A=\"Z-Axis  :%12.6f\"$$\n";
  F64 a_y	format "$$DA-TRM,A=\"Y-Axis  :%12.6f\"$$\n";
  F64 a_x	format "$$DA-TRM,A=\"X-Axis  :%12.6f\"$$\n";
  F64 x_offset	format "\n$$DA-TRM,A=\"X Offset:%12.6f\"$$\n";
  F64 y_offset	format "$$DA-TRM,A=\"Y Offset:%12.6f\"$$\n";
  F64 z_offset	format "$$DA-TRM,A=\"Z Offset:%12.6f\"$$\n";
};
class CRenum
{
  CRenum *next,*last;
  //Was U8 label[sizeof(CEdFindText.find_text)];
  U8 label[STR_LEN];
};
public extern Bool PopUpTransform(I64 *r);
extern I64 DitherColor2(U8 *header=NULL);
public extern I64 PopUpColorDither(U8 *header=NULL);
extern U32 *DocHighlight(CDocEntry *doc_e,U8 *src,I64 len,I64 _tmp_u32_attr);
extern U0 DocInit();
#define LK_FILE 	0
#define LK_FILE_ANCHOR	1
#define LK_FILE_FIND	2
#define LK_FILE_LINE	3
#define LK_MAN_PAGE	4
#define LK_PLAIN	5
#define LK_PLAIN_FIND	6
#define LK_PLAIN_LINE	7
#define LK_BIBLE_FIND	8
#define LK_DEF		9
#define LK_HELP_INDEX	10
#define LK_ADDR		11
#define LK_DOC		12 //See $LK,"SpriteEdText",A="MN:SpriteEdText"$()
#define LK_DOC_ANCHOR	13
#define LK_DOC_FIND	14
#define LK_DOC_LINE	15
#define LK_PLACE_ANCHOR	16
public extern U8 *DocEntryLink(CDoc *doc,CDocEntry *doc_e);
extern Bool DocFileEd(I64 _type,U8 *filename,
	U8 *needle_str,I64 *_num,I64 edf_dof_flags);
#define DFT_ADDR_LINK_BIN_SIZE	64

public extern I64 EdLinkCvt(U8 *link_st,U8 **_filename=NULL,U8 **_needle_str=NULL,
	I64 *_num=NULL,I64 edf_dof_flags=0);
public extern Bool DocLinkChk(CDoc *doc,U8 *link_st);
extern U0 SysMacroStripKey(CJob *macro_head,I64 arg1,I64 arg2);
#define MT_NULL	0
#define MT_MSG	1
#define MT_CHAR	2

class CMacroTmp
{
  CMacroTmp *next,*last;
  I64 type;
  U8 buf[STR_LEN];
};

extern CMacroTmp *Cmd2MT(CJob *tmpc);
extern U8 *SysMacro2Str(CJob *macro_head);
extern U0 PlaySysMacro(I64 n=1);
extern U0 EdInsCapturedMacro();
#define SM_RECORD	0
#define SM_INS		1
#define SM_PLAY		2
#define SM_REPEAT_N	3
#define SM_STOP		4
extern I64 PopUpMacroMenu();
extern U0 MacroTask(I64);
extern U0 EdMacroUtil();
public extern Bool DocLock(CDoc *doc);
public extern Bool DocUnlock(CDoc *doc);
extern Bool IsEditableText(CDocEntry *doc_e);
extern CDocEntry *DocEntryNewBase(CDoc *doc,I64 type,I64 de_flags=0,
	I64 x=0,I64 y=0,I64 page_line_num=0);
extern CDocEntry *DocEntryNewTag(CDoc *doc,CDocEntry *doc_ce,U8 *tag);
public extern U0 DocEntryDel(CDoc *doc,CDocEntry *doc_e);
public extern I64 DocEntrySize(CDoc *,CDocEntry *doc_e);
extern U0 DocUndoDel(CDoc *,CDocUndo *u);
extern U0 DocUndoCntSet(CDoc *doc);
public extern CDocEntry *DocEntryCopy(CDoc *doc,CDocEntry *doc_e);
extern U0 DocRemSoftNewLines(CDoc *doc=NULL,CDocEntry *doc_e=NULL);
public extern U0 DocInsEntry(CDoc *doc,CDocEntry *doc_e);
public extern U0 DocRst(CDoc *doc,Bool is_old);
public extern U0 DocDel(CDoc *doc);
public extern I64 DocSize(CDoc *doc);
public extern CDoc *DocNew(U8 *filename=NULL,CTask *task=NULL);
extern I64 PrsDocFlagSingle(CCmpCtrl *cc,I64 *_de_flags,U32 *_type,Bool turn_on);
extern I64 PrsDocFlags(CCmpCtrl *cc,I64 *_de_flags,U32 *_type);
extern U8 *Doc2PlainText(CDoc *doc,CDocEntry *doc_e);
extern CDocEntry *PrsDollarCmd(CDoc *doc,U8 *st);
extern U0 DocEntryToggle(CDoc *doc);
extern U0 DocFlagsToggle(CDoc *doc,I64 tog_flags);
public extern CTask *PopUpViewDoc(CDoc *doc,I64 dof_flags=0);
public extern CTask *PopUpViewPrint(U8 *fmt,...);
public extern U8 *PopUpPickFile(U8 *dir=NULL);
public extern U8 *PopUpPickDir(U8 *dir=NULL);
public extern U8 *FileNameForm(U8 *dft=NULL,I64 dof_flags=0,CTask *mem_task=NULL);
public extern U8 *PopUpFileName(U8 *dft=NULL,I64 dof_flags=0);
extern Bool PopUpCd();
public extern I64 PopUpPickLst(U8 *lst);
public extern U8 *PopUpPickDefineSub(U8 *dname);
public extern I64 PopUp1(U8 *b1,I64 n1,U8 *header=NULL,U8 *footer=NULL);
public extern I64 PopUp2(U8 *b1,I64 n1,U8 *b2,I64 n2,U8 *header=NULL,U8 *footer=NULL);
public extern Bool PopUpOk(U8 *header=NULL,U8 *footer=NULL);
public extern Bool PopUpNoYes(U8 *header=NULL,U8 *footer=NULL);
public extern Bool PopUpCancelOk(U8 *header=NULL,U8 *footer=NULL);
extern U8 *PopUpGetStr2(U8 *header,CTask *mem_task);
public extern U8 *PopUpGetStr(U8 *header=NULL);
public extern I64 PopUpGetI64(U8 *msg,I64 dft,I64 lo=I64_MIN,I64 hi=I64_MAX);
public extern F64 PopUpGetF64(U8 *msg,F64 dft,F64 lo=F64_MIN,F64 hi=F64_MAX);
public extern I64 PopUpRangeI64(I64 lo,I64 hi,I64 step=1,
	U8 *header=NULL,U8 *footer=NULL);
public extern F64 PopUpRangeF64(F64 lo,F64 hi,F64 step,
    U8 *fmt="%9.4f",U8 *header=NULL,U8 *footer=NULL);
public extern F64 PopUpRangeF64Exp(F64 lo,F64 hi,F64 factor,
    U8 *fmt="%9.4f",U8 *header=NULL,U8 *footer=NULL);
public extern F64 PopUpRangeF64Log(F64 lo,F64 hi,I64 steps,
    U8 *fmt="%9.4f",U8 *header=NULL,U8 *footer=NULL);
public extern I64 AdamFile(U8 *filename,Bool warn_ext=TRUE);
public extern I64 PopUpFile(U8 *filename,Bool warn_ext=TRUE,
	CTask *parent=NULL,CTask **_pu_task=NULL);
public extern I64 PopUpRunFile(U8 *filename,I64 ccf_flags=0,...);
public extern U0 DocPutKey(CDoc *doc,I64 ch=0,I64 sc=0);
extern Bool KDDocPutKey(I64 ch,I64 scan_code);
extern CDocEntry *DocPutS(CDoc *doc,U8 *st);
public extern CDocEntry *DocPrint(CDoc *doc=NULL,U8 *fmt,...);
public extern U0 DocPrintPartial(CDoc *doc=NULL,U8 *fmt,...);
extern Bool KDDocPutS(U8 *st);
public extern U0 DocPrintAtomic(CDoc *doc=NULL,U8 *fmt,...);
extern U0 DocDump(CDoc *doc,I64 uS_delay=0);
public extern CDocEntry *DocPutLine(CDoc *doc=NULL,CDocEntry *doc_e);
public extern U0 DocDm(U8 *buf,I64 cnt=0x80);
public extern U0 DocD(U8 *buf,I64 cnt=0x80);
extern I64 DocWordWrapDel(CDoc *doc,CDocEntry *doc_e,
	Bool full_refresh,Bool same_win,I64 left_margin,I64 right_margin,
	CDocEntry **_best_doc_e,I64 *_best_col);
extern U0 DocRecalcXY(CDoc *doc,CDocEntry *doc_e,
	I64 k,I64 left,I64 width,I64 height,I64 left_margin,I64 right_margin,
	I64 x0,I64 y0,I64 *_x,I64 *_y);
extern CDocEntry *DocSplitTag(CDoc *doc,CDocEntry *doc_e,I64 i,I64 x,I64 y,I64 type_u8);
extern CDocEntry *DocWordWrapAdd(CDoc *doc,CDocEntry *doc_e,
	I64 *_k,I64 left,I64 right_margin,I64 x,I64 y);
extern I64 DocTmpAttr(CDoc *doc,CDocEntry *doc_e,I64 cur_u8_attr);
public extern Bool DocRecalc(CDoc *doc,I64 recalc_flags=RECALCt_NORMAL);
extern I64 DocCharDist(CDoc *doc,I64 x,I64 y);
extern U0 DocDelToNum(CDoc *doc,I64 num);
extern U0 DocDelToEntry(CDoc *doc,CDocEntry *clear_entry,Bool clear_holds);
extern U0 DocBorderLstDraw(CDoc *doc);
public extern U0 DocTop(CDoc *doc=NULL);
public extern U0 DocCenter(CDoc *doc=NULL,I64 recalc_flags=RECALCt_NORMAL);
public extern U0 DocBottom(CDoc *doc=NULL);
public extern U0 DocClear(CDoc *doc=NULL,Bool clear_holds=FALSE);
public extern Bool DocCursor(Bool show=OFF,CDoc *doc=NULL);
public extern Bool DocHighlightCursor(Bool show=OFF,CDoc *doc=NULL);
public extern Bool DocScroll(Bool val=OFF,CDoc *doc=NULL);
public extern U0 DocCollapse(Bool collapse=TRUE,CDoc *doc=NULL);
public extern I64 DocMax(I64 i=I64_MAX);
extern U0 DocUpdateTaskDocs(CTask *task);
public extern I64 DocEntryRun(CDoc *doc,CDocEntry *doc_e,
	Bool exited,I64 *_has_action=NULL);
public extern CDoc *DocBorderNew(CDoc *pdoc);
public extern U0 DocTermNew();
#define RIGHT_INCLUDE	0
#define RIGHT_AINCLUDE	1
#define RIGHT_COPY	2
#define RIGHT_MOVE	3
#define RIGHT_DELETE	4
#define RIGHT_TYPE	5
#define RIGHT_ED	6
#define RIGHT_MOUNT	7
#define RIGHT_PLAIN	8
#define RIGHT_INFILE	9

extern I64 PopUpTermRight(U8 *header);
extern I64 EdLeftClickLink(CDoc *doc,CDocEntry *doc_e);
extern I64 TermRightClickLink(CDoc *doc,CDocEntry *doc_e);
extern I64 PopUpLinkType(Bool include_anchor);


class CEdFileLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512]	format "$$DA-P,A=\"File          :%s\"$$\n";
  I64	book;
  U8	aux[512];
  I64	num;
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdFileAnchorLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512]	format "$$DA-P,A=\"File          :%s\"$$\n";
  I64	book;
  U8	aux[512]	format "$$DA-P,A=\"Anchor Label  :%s\"$$\n";
  I64	num;
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdFileFindLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512]	format "$$DA-P,A=\"File          :%s\"$$\n";
  I64	book;
  U8	aux[512]	format "$$DA-P,A=\"Str        :%s\"$$\n";
  I64	num		format "$$DA-TRM,A=\"Occurrence Num:%04d\"$$\n";
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdFileLineLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512]	format "$$DA-P,A=\"File          :%s\"$$\n";
  I64	book;
  U8	aux[512];
  I64	num		format "$$DA-TRM,A=\"Line Num      :%04d\"$$\n";
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdManPageLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512];
  I64	book;
  U8	aux[512]	format "$$DA-P,A=\"Label         :%s\"$$\n";
  I64	num;
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdAddrLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512];
  I64	book;
  U8	aux[512]	format "$$DA-P,A=\"Addr Exp   :%s\"$$\n";
  I64	num		format "$$DA-TRM,A=\"Bin Size      :%04d\"$$\n";
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdPlaceAnchor
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512];
  I64	book;
  U8	aux[512]	format "$$DA-P,A=\"Anchor Label  :%s\"$$\n";
  I64	num;
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up,
	quote		format "$$CB,\"Quote\"$$\n",
	hide		format "$$CB,\"Hide\"$$\n";
};

class CEdBibleLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512];
  I64	book		format "$$LS,D=\"ST_BIBLE_BOOKS\"$$\n";
  U8	aux[512]	format "$$DA-P,A=\"Chapter Verse :%s\"$$\n";
  I64	num;

  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdDefLink
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512];
  I64	book;
  U8	aux[512]	format "$$DA-P,A=\"Word          :%s\"$$\n";
  I64	num		format "$$DA-TRM,A=\"Def Num       :%4d\"$$\n";
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdProject
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n",
	file[512]	format "$$DA-P,A=\"File          :%s\"$$\n";
  I64	book;
  U8	aux[512];
  I64	num;
  U8	html_link[512]	format "$$DA-P,A=\"Html Link     :%s\"$$\n";
  Bool	pop_up		format "$$CB,\"PopUp\"$$\n",
	quote		format "$$CB,\"Quote\"$$\n",
	hide;
};

class CEdPageSetting1
{
  U8	val[512]	format "$$DA-P,A=\"Setting Val:%s\"$$\n";
  Bool	winrel;
};

class CEdPageSetting2
{
  U8	val[512]	format "$$DA-P,A=\"Setting Val:%s\"$$\n";
  Bool	winrel		format "$$CB,\"Win Relative\"$$\n";
};

extern Bool GetLink(I64 type,U8 **_tag,U8 **_link,Bool *_pop_up,
	Bool *_quote,U8 **_html_link);
extern U0 EdInsLink();
extern U0 EdInsPageSetting();
extern I64 PopUpWidgetType();

class CEdMacroMenu
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text                  :%s\"$$\n",
	left_macro[512]	format "$$DA-P,A=\"Left Click Macro          :%s\"$$\n",
	left_exp[512]	format "$$DA-P,A=\"Left Click Expression     :%s\"$$\n";
  Bool	popup		format "$$CB,\"PopUp\"$$\n",
	left_is_in_str	format "$$CB,\"Left is InStr\"$$\n",
	left_x		format "$$CB,\"Left X \"$$\n",
	center_x	format "$$CB,\"Center X \"$$\n",
	right_x		format "$$CB,\"Right X \"$$\n",
	margin_rel	format "$$CB,\"Margin Rel X\"$$\n",
	blink		format "$$CB,\"Blink\"$$\n",
	invert		format "$$CB,\"Invert\"$$\n",
	underline	format "$$CB,\"Underline\"$$\n",
	escape		format "$$CB,\"Escape\"$$\n";
  U8	scroll_x[512]	format "$$DA-P,A=\"Scroll X Length Expression:%s\"$$\n",
	shift_x[512]	format "$$DA-P,A=\"X Offset Expression       :%s\"$$\n",
	shift_y[512]	format "$$DA-P,A=\"Y Offset Expression       :%s\"$$\n";
};

extern U0 EdInsMacroMenu(Bool is_macro);

class CEdBttn
{
  U8	tag[512]   format "$$DA-P,A=\"Tag Text      :%s\"$$\n";
  Bool	popup	   format "$$CB,\"PopUp\"$$\n",
	left_x	   format "$$CB,\"Left X \"$$\n",
	center_x   format "$$CB,\"Center X \"$$\n",
	right_x	   format "$$CB,\"Right X \"$$\n",
	margin_rel format "$$CB,\"Margin Rel X\"$$\n",
	escape	   format "$$CB,\"Escape\"$$\n";
  U8	left_macro[512]	format "$$DA-P,A=\"Left Click Macro:%s\"$$\n";
  Bool	left_is_in_str	format "$$CB,\"Left is InStr\"$$\n";
  U8	left_exp[512]	format "$$DA-P,A=\"Left Click Expression:%s\"$$\n";
  Bool	quote		format "$$CB,\"Quote\"$$\n";
};

extern U0 EdInsBttn();

class CEdCursorMovement
{
  U8	left_exp[512]	 format "$$DA-P,A=\"X Expression (LE):%s\"$$\n",
	right_exp[512]	 format "$$DA-P,A=\"Y Expression (RE):%s\"$$\n";
  Bool	left_x	 format "$$CB,\"Left   X \"$$\n",
	center_x format "$$CB,\"Center X \"$$\n",
	right_x  format "$$CB,\"Right  X \"$$\n",
	margin_rel format "$$CB,\"Margin Rel X\"$$\n",
	top_y	 format "$$CB,\"Top    Y \"$$\n",
	center_y format "$$CB,\"Center Y \"$$\n",
	bottom_y format "$$CB,\"Bottom Y \"$$\n",
	page_rel format "$$CB,\"Page Rel Y\"$$\n",
	quote	 format "$$CB,\"Quote\"$$\n";
};

extern U0 EdInsCursorMovement();

class CEdDataNum
{
  U8	fmt_str[512]	format "$$DA-P,A=\"Format Str:%s\"$$\n";
  I64	len;
  Bool	term		format "$$CB,\"Form Field Terminator\"$$\n",
	remalloc,
	refresh		format "$$CB,\"Refresh Data\"$$\n",
	update		format "$$CB,\"Update Data\"$$\n";
};

class CEdDataStr
{
  U8	fmt_str[512]	format "$$DA-P,A=\"Format Str:%s\"$$\n";
  I64	len		format "$$DA,A=\"Length:%d\"$$\n";
  Bool	term		format "$$CB,\"Zero Terminator\"$$\n",
	remalloc	format "$$CB,\"Remalloc for Unlimited Length\"$$\n",
	refresh		format "$$CB,\"Refresh Data\"$$\n",
	update		format "$$CB,\"Update Data\"$$\n";
};

extern U0 EdInsData();

class CEdCheckBox
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n";
  Bool	refresh		format "$$CB,\"Refresh Data\"$$\n";
  I64	type		format "$$LS,D=\"ST_INT_SIZE_TYPES\"$$\n";
};

extern U0 EdInsCheckBox();
class CEdLst
{
  U8	tag[512]	format "$$DA-P,A=\"Dft Sel    :%s\"$$\n",
	define_str[512]	format "$$DA-P,A=\"Define Str    :%s\"$$\n";
  Bool	refresh		format "$$CB,\"Refresh Data\"$$\n";
  I64	type		format "$$LS,D=\"ST_INT_SIZE_TYPES\"$$\n";
};
extern U0 EdInsLst();
class CEdHexEd
{
  I64	cnt	format "$$DA,A=\"Count:%d\"$$\n",
	cols	format "$$DA,A=\"Columns:%d\"$$\n";
  Bool	zero	format "$$CB,\"Zero Based\"$$\n",
	refresh	format "$$CB,\"Refresh Data\"$$\n";
};
extern U0 EdInsHexEd();
class CEdBin
{
  U8	tag[512]		format "$$DA-P,A=\"Tag Text      :%s\"$$\n";
  I64	bin_num			format "$$DA,A=\"Bin Num:%d\"$$\n";
  U8	bin_ptr_link_file[512]	format "$$DA-P,A=\"File:%s\"$$\n";
  I64	bin_ptr_link_bin_num	format "$$DA,A=\"File Bin Num:%d\"$$\n";
  U8	bin_ptr_link_tag[512]	format "$$DA-P,A=\"File Bin Tag:%s\"$$\n";
};

extern U0 EdInsBin(I64 bin_num,I64 type);
class CEdTree
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text      :%s\"$$\n";
  I64	indent		format "$$DA,A=\"Indention:%d\"$$\n";
  Bool	collapsed	format "$$CB,\"Collapsed\"$$\n";
};
extern U0 EdInsTree();
extern U0 EdInsWidgetWiz();
#define EST_SPRITE		0
#define EST_SPRITE_PTR		1
#define EST_DUP_SPRITE		2
#define EST_SPRITE_SIZE		3
#define EST_SPRITE_MACRO	4
#define EST_SPRITE_MENU		5
#define EST_SPRITE_LINK		6

extern I64 PopUpSpriteType();
class CEdMacroSprite
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text       :%s\"$$\n",
	exp[512]	format "$$DA-P,A=\"Macro          :%s\"$$\n";
  Bool	escape		format "$$CB,\"Escape\"$$\n",
	popup		format "$$CB,\"PopUp\"$$\n",
	is_in_str		format "$$CB,\"InStr\"$$\n";
};

class CEdMenuSprite
{
  U8	tag[512]	format "$$DA-P,A=\"Tag Text       :%s\"$$\n",
	exp[512]	format "$$DA-P,A=\"Expression     :%s\"$$\n";
  Bool	escape		format "$$CB,\"Escape\"$$\n",
	popup,
	is_in_str;
};

extern U8 *EdSpriteLink(Bool *_pop_up,U8 **_html_link);
extern U8 *EdSprite(I64 bin_num);
public extern U0 WinZBufUpdate();
extern U0 InputFilterTask();
extern Bool DirMk(U8 *filename,I64 entry_cnt=0);
extern I64 Dir(U8 *files_find_mask=".",Bool full=FALSE);
extern U0 BlkDevLockFwdingSet(CBlkDev *bd);
extern I64 BlkDevAdd(CBlkDev *bd,I64 prt_num=I64_MIN,
	Bool whole_drv,Bool make_free);
extern Bool DrvEnable(U8 drv_let,Bool val);
extern U0 BlkDevsInitAll();
extern Bool BlkDevLock(CBlkDev *bd);
extern Bool BlkDevUnlock(CBlkDev *bd,Bool rst=FALSE);
extern Bool BlkDevInit(CBlkDev *bd);
extern U0 BlkDevsRelease();
extern CBlkDev *BlkDevNextFreeSlot(U8 first_drv_let,I64 type);
extern U0 BlkDevDel(CBlkDev *bd);
extern CBlkDev *BlkDevChk(CBlkDev *bd,Bool except=TRUE);
extern CBlkDev *Let2BlkDev(U8 drv_let=0,Bool except=TRUE);
#define ZERO_BUF_SIZE	2048
extern U0 BlkWriteZero(CDrv *dv,I64 blk,I64 cnt);
extern Bool BlkRead(CDrv *dv,U8 *buf, I64 blk, I64 cnt);
extern Bool BlkWrite(CDrv *dv,U8 *buf, I64 blk, I64 cnt);
extern Bool ISOInit(CDrv *dv,I64 blk);
extern U0 DVDImageRead(U8 dvd_drv_let,U8 *out_name);
extern I64 FSize(CFile *f);
extern CFile *FOpen(U8 *filename,U8 *flags,I64 cnt=0,CTask *mem_task=NULL);
extern U0 FClose(CFile *f);
extern I64 FSetClus(CFile *f,I64 c,I64 blk,Bool read);
extern Bool FBlkRead(CFile *f,U8 *buf,I64 blk=FFB_NEXT_BLK,I64 cnt=1);
extern Bool FBlkRead(CFile *f,U8 *buf,I64 blk=FFB_NEXT_BLK,I64 cnt=1);
extern Bool CopySingleZ(U8 *f1,U8 *f2) //Just one file;
extern Bool CopySingle(U8 *f1,U8 *f2);
extern I64 Del(U8 *files_find_mask,Bool make_mask=FALSE,
	Bool del_dir=FALSE,Bool print_msg=TRUE);
extern Bool DirNew(CDrv *dv,U8 *cur_dir,CDirEntry *tmpde,Bool free_old_chain=TRUE);
extern U0 DirEntryDel(CDirEntry *tmpde);
extern U0 DirEntryDel2(CDirEntry *tmpde);
extern U0 DirTreeDel(CDirEntry *tmpde);
extern U0 DirTreeDel2(CDirEntry *tmpde);
extern I64 DirEntryCompareName(CDirEntry *e1,CDirEntry *e2);
extern I64 DirEntryCompareClus(CDirEntry *e1,CDirEntry *e2);
#define SK_NAME		0
#define SK_CLUS	1
extern U0 DirFilesSort(CDirEntry **_tmpde,I64 key);
extern CDirEntry *DirFilesFlatten(CDirEntry *tmpde,CDirEntry **_res,I64 fuf_flags);
extern U0 PutFileLink(U8 *filename,U8 *full_name=NULL,I64 line=0,Bool plain_text=FALSE);
extern U0 PutDirLink(U8 *dirname,U8 *full_name=NULL);
extern U0 HomeSet(U8 *dirname);
extern Bool Cd(U8 *dirname=NULL,Bool make_dirs=FALSE);
extern Bool IsDir(U8 *dir_name);
extern U0 DirContextDel(CDirContext *dirc,Bool restore=TRUE);
extern CDirContext *DirContextNew(U8 *_mask,Bool make_mask=FALSE,
	Bool make_dirs=FALSE,Bool no_mask=FALSE);
extern Bool DrvLock(CDrv *dv);
extern Bool DrvUnlock(CDrv *dv,Bool rst=FALSE);
extern U0 DrvsRelease();
extern CDrv *DrvMakeFreeSlot(U8 drv_let);
extern U8 DrvNextFreeLet(U8 first_drv_let='C');
extern U0 DrvDel(CDrv *dv);
extern U0 DrvBlkDevDel(CBlkDev *bd);
extern U0 DrvFATBlkAlloc(CDrv *dv);
extern U0 DrvFATBlkClean(CDrv *dv,I64 fat_sel=3);
extern U0 DrvFATBlkSet(CDrv *dv,I64 c,I64 fat_sel=3);
extern CDrv *DrvChk(CDrv *dv,Bool except=TRUE);
extern U8 Drv2Let(CDrv *dv=NULL);
extern U8 Let2Let(U8 drv_let=0);
extern I64 Let2BlkDevType(U8 drv_let);
extern CDrv *Let2Drv(U8 drv_let=0,Bool except=TRUE);
extern CBlkDev *DrvIsWritable(U8 drv_let=0,Bool except=FALSE);
extern U0 DskCacheInvalidate(CDrv *dv);
extern U0 DskChg(U8 drv_let=0);
extern Bool DrvMap(U8 drv_let,CDrv *dv);
extern Bool Drv(U8 drv_let);
extern U8 *DrvSerialNum(U8 drv_let=0);
extern U8 *DrvModelNum(U8 drv_let=0);
extern U8 DrvTextAttrGet(U8 drv_let=0);
extern U0 DrvRep();
extern U8 *FileRead(U8 *filename,I64 *_size=NULL,I64 *_attr=NULL);
extern I64 FileWrite(U8 *filename,U8 *fbuf,I64 size,CDate cdt=0,I64 attr=0);
extern CDirEntry *FilesFind2(U8 *files_find_mask,I64 fuf_flags);
extern CDirEntry *FilesFind(U8 *files_find_mask,I64 fuf_flags=0);
extern Bool FileFind(U8 *filename,CDirEntry *_de=NULL,I64 fuf_flags=FUF_Z_OR_NOT_Z);
extern Bool DrvTypeSet(U8 drv_let,I64 type=FSt_REDSEA);
extern U0 Fmt(I64 drv_let,Bool quick=TRUE,Bool confirm=TRUE,I64 type=FSt_FAT32);
extern I64 StrICmp(U8 *a,U8 *b);
extern U8 MountFile(U8 *filename);
extern U0 Unmount(U8 drv_let=0);
extern U0 In(U8 *fmt,...);
extern I64 ExePrint(U8 *fmt,...);
extern U0 PutChars(U64 c);
extern U0 Print(U8 *fmt,...);
extern I64 KMCompare(U8 *e1,U8 *e2);
extern U0 DocMenuEndTaskCB();
extern class CSprite;
extern U0 SpriteSideBarTask2(CTask *grand_parent);
extern CFifoI64 *FifoI64New(I64 size,CTask *mem_task=NULL);
extern U0 TaskFocusNext();
extern CSprite *SMLine(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color);
extern U0 GrUpdateTaskODEs(CTask *task);
extern Bool Gr2Bezier3(CDC *dc=0,CD3I32 *ctrl);
extern Bool GrTextBox3(CDC *dc=0,I64 x1,I64 y1,I64 z1,U8 *s,I64 border=2);
extern CSprite *SMPolyLineFamily(I64 eletype,CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,
	CColorROPU32 color);
extern Bool BreakUnlock(CTask *task=NULL);
extern U0 SPutChar(U8 **_dst,U8 ch,U8 **_buf);
extern U32 RandU32();
extern U0 CtrlAltCBSet(U8 ch,U0 (*fp_hndlr)(I64 sc),
	U8 *no_shift_desc=NULL,U8 *shift_desc=NULL,Bool in_irq=FALSE);
extern U0 EdLineDown(CDoc *doc,I64 sc=I64_MIN);
extern CAOT *CmpBuf(U8 *buf,U8 *map_name=NULL,
  I64 *error_cnt=NULL, I64 *warning_cnt=NULL,U8 mapfile_drv_let=0);
extern I64 PressAKey();
extern U8 *DocLineRead(U8 *filename,I64 line,CTask *mem_task=NULL);
extern U8 *DocLineWrite(U8 *filename,I64 line,U8 *st);

class CRILex
{
  CCmpCtrl *cc1,*cc2;
  CQueVectU8 *indent;
  I64 depth,exp_depth,one_shot;
  Bool was_new_line,is_not_cont;
};

class CDualBuf
{
  U8 *buf0,*buf1;
  I64 in_buf,out_buf,cnt;
  U8 *filename;
  CBlkDev *dvd_bd;
};

extern class CMeshTri;
extern class CQueMeshTri;
extern class COptMemberVar;
extern class CEdSprite;
extern class CMeshEdVertex;
extern class CMeshFrame;
extern class CMeshEdTri;

#define FND_REPLACE	0
#define FND_SKIP	1
#define FND_ALL		2
#define FND_ED		3
#define FND_ABORT_FILE	4
#define FND_SKIP_FILE	5
class CFind
{
  U8	find_text[STR_LEN] format "$$DA-P,"
	"A=\"FIND        :%s\"$$\n";
  U8	replace_text[STR_LEN] format "$$DA-P,"
	"A=\"REPLACE     :%s\"$$\n";
  Bool	replace		format "$$CB,\"REPLACE\"$$\n";
  Bool	match_case	format "$$CB,\"MATCH CASE\"$$\n";
  Bool	whole_labels	format "$$CB,\"WHOLE LABELS\"$$\n";
  U8	filemask[STR_LEN] format "$$DA-P,A=\"FILE MASK   :%s\"$$\n";
  Bool	recurse		format "$$CB,\"RECURSE\"$$\n";
};


#define CMPF_ASM_BLK		1
#define CMPF_ONE_ASM_INS	2
#define CMPF_LEX_FIRST		4
#define CMPF_PRS_SEMICOLON	8
#define PEF_END_EXPR 0x1 //Same as TRUE
#define PEF_PAREN 0x2
#define PEF_ARRAY 0x4
#define PEF_ADDR_OF 0x8
#define PEF_FUN_BEFORE 0x10
#define PEF_NO_COMMA 0x20

extern CMsStateGlbls	ms,ms_last,old_ms;
#define BIBLE_FILENAME	"::/Bible.TXT.Z"


class CMusicGlbls
{
  U8	*cur_song;
  CTask	*cur_song_task;
  I64	octave;
  F64	note_len;
  U8	note_map[7];
  Bool	mute;
  I64	meter_top,meter_bottom;
  F64	tempo,stacatto_factor;

  //If you wish to sync with a
  //note in a Play() string.  0 is the start
  I64	play_note_num;

  F64	tM_correction,last_Beat,last_tM;
};
extern CMusicGlbls music;
class CGodGlbls
{
  U8	**words,
	*word_file_mask;
  I64	word_fuf_flags,
	num_words;
  CFifoU8 *fifo;
  CDC	*doodle_dc;
  I64	doodle_ch;
  CFifoU8 *doodle_fifo;
  Bool	doodle_done;
};

class CMakeSongSettings
{
  I64  complexity		format "$$LS,D=\"ST_RHYTHM_COMPLEXITY\"$$\n";
  Bool rests			format "$$CB,\"Rests\"$$\n";
  Bool six_eight		format "$$CB,\"Six Eight\"$$\n";
  I64  octave			format "$$DA-TRM,A=\"Octave:%d\"$$\n";
  I64  octave_state;
};

#define BTTN_BORDER	2

#define BTF_DONT_FREE	1

class CCtrlBttnState
{
  I64 state,num_states,flags;
  U8 *state_texts;
  CColorROPU32 *state_colors;
};

class CGrGlbls
{
  I64	*to_8_bits,*to_8_colors;
  CDC	*scrn_image,	//Read only.
	*dc,		//Persistent
	*dc1,
	*dc2,		//Updated every refresh
	*dc_cache,
	*zoomed_dc;
  U32	*text_base;	//See $LK,"TextBase Layer",A="HI:TextBase Layer"$. (Similar to 0xB8000 but 32 bits)
  U16	*win_z_buf;

  #define SPHT_ELEM_CODE	1
  CHashTable *sprite_hash;

  U16	*win_uncovered_bitmap;
  I64	highest_uncovered;
  U16	*vga_text_cache;
  I64	pan_text_x,pan_text_y;	//[-7,7]
  U0	(*fp_final_scrn_update)(CDC *dc);//Mouse cursor is handled here.
  U0	(*fp_wall_paper)(CTask *task);
  U0	(*fp_draw_ms)(CDC *dc,I64 x,I64 y);
  U0	(*fp_draw_grab_ms)(CDC *dc,I64 x,I64 y,Bool closed);
  U8	*empty_sprite; //Gets assigned $LK,"gr.empty_sprite",A="FF:::/Adam/AMouse.HC,empty_sprite"$

  #define GR_PEN_BRUSHES_NUM 64
  CDC	*pen_brushes[GR_PEN_BRUSHES_NUM],
	*collision_pen_brushes[GR_PEN_BRUSHES_NUM],
	*even_pen_brushes[GR_PEN_BRUSHES_NUM],
	*odd_pen_brushes[GR_PEN_BRUSHES_NUM];
  I8	circle_lo[GR_PEN_BRUSHES_NUM][GR_PEN_BRUSHES_NUM],
	circle_hi[GR_PEN_BRUSHES_NUM][GR_PEN_BRUSHES_NUM];

  #define GR_SCRN_ZOOM_MAX	8
  U8	*scrn_zoom_tables[GR_SCRN_ZOOM_MAX+1];
  I64	scrn_zoom,sx,sy;

  //When zoomed, this keeps the mouse centered.
  Bool	continuous_scroll,
	hide_row,hide_col;
};
extern CGrGlbls gr;

#define FM_NORMAL	0
#define FM_PICK_FILE	1
#define FM_PICK_DIR	2
class CFMUncollapsedLst
{
  CFMUncollapsedLst *next;
  U8 *name;
};
extern U0 (*fp_update_ctrls)(CTask *task);
extern class CTemplateCS;
extern class CSoundEffectFrame;
extern CGodGlbls god;
extern U8 *ACDDefGet(U8 *st,I64 def_num=1);
extern U8 *ACDDefsGet(U8 *st);
extern U8 *ACDWordPtAt(U8 *st);
extern U0 ACDPopUpDef(U8 *st,I64 num=-1,CTask *parent=NULL);
extern U0 ACDWordsLoad();
extern CHashAC *ACHashAdd(U8 *w);
extern U0 ACSingleFileAdd(U8 *buf);
extern U0 ACMainFileLstTraverse(U8 *files_find_mask);
extern U0 ACInit(U8 *mask=NULL);
extern U0 ACDDictWordsAdd(U8 *st);
extern U0 ACDocRst(I64 left,I64 top);
extern I64 ACSkipCrap(U8 *src,I64 len);
extern I64 ACPriorWordInStr(U8 *src,U8 *dst,I64 len,I64 buf_size);
extern U0 ACFillInAdd(CHashAC *tmpw);
extern U0 ACPutChoices(CDoc *focus_l,CDocEntry *doc_e,CTask *focus_task,	Bool force_refresh);
extern U0 ACTaskNormal(I64 sc,I64 last_sc,	CTask *focus_task,CTask *original_focus_task);
extern U0 ACTaskCtrl(I64 sc,I64 last_sc,	CTask *focus_task,CTask *original_focus_task);
extern U0 ACTaskAlt(I64 sc,I64 last_sc,	CTask *,CTask *original_focus_task);
extern U0 ACTaskEndCB();
extern U0 ACTask(I64);
extern Bool Copy(U8 *src_files_find_mask,U8 *dst_files_find_mask=".");
extern Bool Move(U8 *f1,U8 *f2);
extern I64 CopyTree2(CDirEntry *tmpde,I64 src_dir_len,I64 dst_dir_len,U8 *dst_dir);
extern I64 CopyTree(U8 *src_files_find_mask,U8 *dst_files_find_mask,	Bool no_mask=TRUE);
extern I64 DelTreeDirs(CDirEntry *tmpde1);
extern I64 DelTreeFiles(CDirEntry *tmpde1);
extern I64 DelTree(U8 *files_find_mask,U8 *fu_flags=NULL);
extern U0 AiwniosMakeShortJmps(CCmpCtrl *cc) ;
extern U8 *AiwniosCompile(CCmpCtrl *cc,I64 *res_sz=NULL,CDbgInfo **info=NULL) ;
extern U8 *COCCompile(CCmpCtrl *cc,I64 *_code_size,CDbgInfo **_dbg,I64 *_type) ;
extern U0 PrsBindCSymbol(U8 *as,U8 *fptr) ;
extern CTask *PolyFillFs() ;
extern U0 PolyFillSetFs(CTask *t) ;
extern U0 PrsBindCSymbols() ;
extern U0 Poopacle() ;
extern U0 AiwniosWriteDbgInfo(CTask *universe,U8 *to) ;
extern Bool IsPtrNode(CRPN *rpn) ;
extern U0 RPNDel(CRPN *rpn) ;
extern CHashClass *DerefType(CHashClass *cls) ;
extern CHashClass *AddrOfType(CHashClass *cls) ;
extern I64 RPNPtrWidth(CRPN *r) ;
extern CHashClass *AssignRawTypeToNode(CRPN *r) ;
extern U0 PrsOffsetOf(CCmpCtrl *cc);
extern U0 PrsSizeOf(CCmpCtrl *cc);
extern U0 RPNAdd(CCmpCtrl *cc,CRPN *rpn,Bool add_to_prs_stk=TRUE) ;
extern CRPN *RPNAddNew(CCmpCtrl *cc,I64 type,I64 data=0,CHashClass *cls=NULL,Bool add_to_prs_stk=TRUE) ;
extern U0 PushOpers(CCmpCtrl *cc,I64 cur_prec,Bool fin=FALSE) ;
extern I64 ImplicitFunCall(CCmpCtrl *cc,CHashFun *fun,I64 start_idx=0) ;
extern CCodeMisc *CodeMiscHashNew(CCmpCtrl *cc,CHash* h) ;
extern U0 DbgPrint(U8 *fmt,...) ;
extern CRPN *DumpRPN(CRPN *rpn,I64 indent=0) ;
extern U0 PrsMembers(CCmpCtrl *cc) ;
extern Bool PrsExpression(CCmpCtrl *cc,U8 **ul=NULL,I64 flags=0,CPrsStk *_ps=NULL) ;
extern U0 ParserTest() ;
extern U8 *LexExpression2Bin(CCmpCtrl *cc,I64 *_type=NULL);
extern Bool IsLexExpression2Bin(CCmpCtrl *cc,U8 **_machine_code);
extern I64 LexExpressionI64(CCmpCtrl *cc);
extern F64 LexExpressionF64(CCmpCtrl *cc);
extern I64 LexExpression(CCmpCtrl *cc);
extern CRPN *RPNNext(CRPN *rpn) ;
extern CRPN *RPNArgN(CRPN *rpn,I64 arg) ;
extern U0 AOTStoreCodeU8(CCmpCtrl *cc,U8 b);
extern U0 AOTStoreCodeU32(CCmpCtrl *cc,U32 d);
extern U0 AOTStoreCodeU64(CCmpCtrl *cc,U64 q);
extern U0 AOTStoreCodeU8At(CCmpCtrl *cc,I64 rip,...);
extern U0 AOTOrBytesU8At(CCmpCtrl *cc,I64 rip,...);
extern U0 AOTGlblsResolve(CCmpCtrl *cc,CAOT *tmpaot);
extern U0 LexPutToken(CCmpCtrl *cc);
extern U8 *LexPutLine(CCmpCtrl *cc,U8 *start);
extern U0 LexPutPos(CCmpCtrl *cc);
extern U0 LexWarn(CCmpCtrl *cc,U8 *str=NULL);
extern U0 LexExcept(CCmpCtrl *cc,U8 *str=NULL);
extern U0 UndefinedExtern();
extern U0 UnusedExternWarning(CCmpCtrl *cc,CHashClass *tmpc);
extern U0 ParenWarning(CCmpCtrl *cc);
extern U0 ICClassPut(CHashClass *c);
extern U0 ICArgPut(CICArg *a,I64 type_pointed_to);
extern U0 ICPut(CCmpCtrl *cc,CIntermediateCode *tmpi);
extern U0 CmpAddKw(CHashTable *t,U8 *str,I64 tok) ;
extern U0 CmpLoadDefines();
extern U0 CmpFillTables();
extern U0 CMiscInit() ;
extern CAOT *CmpJoin(CCmpCtrl *cc,I64 cmp_flags,U8 *map_name=NULL,U8 mapfile_drv_let=0);
extern I64 ExePutS(U8 *buf,U8 *filename=NULL,	I64 ccf_flags=0,CLexHashTableContext *htc=NULL);
extern I64 ExeFile(U8 *name,I64 ccf_flags=0);
extern I64 RunFile(U8 *name,I64 ccf_flags=0,...);
extern I64 ExePutS2(U8 *buf,U8 *filename=NULL,I64 ccf_flags=0);
extern I64 ExePrint2(U8 *fmt,...);
extern I64 ExeFile2(U8 *name,I64 ccf_flags=0);
extern I64 RunFile2(U8 *name,I64 ccf_flags=0,...);
extern I64 StreamExePrint(U8 *fmt,...);
extern U0 FillInShortCalls(CCmpCtrl *cc) ;
extern Bool Option(I64 num,Bool val);
extern Bool GetOption(I64 num);
extern U8 *CmdLinePmt();
extern U0 QueInit(CQue *head) ;
extern U0 QueIns(CQue *entry,CQue *pred);
extern U0 QueInsRev(CQue *entry,CQue *succ);
extern U0 QueRem(CQue *entry) ;
extern U0 BFieldOrU32(U8 *data,I64 bit,U64 t) ;
extern U32 BFieldExtU32(U8 *data,I64 bit,U32 width) ;
extern U0 ArcEntryGet(CArcCtrl *c);
extern I64 ArcDetermineCompressionType(U8 *src,I64 size);
extern U0 ArcCompressBuf(CArcCtrl *c);
extern Bool ArcFinishCompression(CArcCtrl *c);
extern U0 ArcExpandBuf(CArcCtrl *c);
extern CArcCtrl *ArcCtrlNew(Bool expand,I64 compression_type=CT_8_BIT);
extern U0 ArcCtrlDel(CArcCtrl *c);
extern U8 *ExpandBuf(CArcCompress *arc,CTask *mem_task=NULL);
extern CArcCompress *CompressBuf(U8 *src,I64 size,CTask *mem_task=NULL);
extern U0 WinDerivedValsUpdate(CTask *task);
extern Bool WinInside(I64 x,I64 y,CTask *task=NULL,I64 border=0);
extern CDocBin *DocBinFindNum(CDoc *haystack_doc,I64 needle_num);
extern CDocBin *DocBinFindTag(CDoc *haystack_doc,U8 *needle_tag);
extern I64 DocBinPtrRst(CDoc *doc,CDocEntry *doc_e);
extern I64 EdCurU8(CDoc *doc);
extern U0 EdCursorLeft(CDoc *doc,I64 sc=I64_MIN);
extern U0 EdCursorRight(CDoc *doc,I64 sc=I64_MIN);
extern U0 EdLineUp(CDoc *doc,I64 sc=I64_MIN);
extern U0 EdCharDel(CDoc *doc);
extern U0 ChkDollarBufSize(CDoc *doc);
extern U0 EdCharIns(I64 ch,I64 sc,CDoc *doc);
extern U0 EdLineDel(CDoc *doc);
extern U0 ClipCopy(CDoc *doc);
extern U0 ClipCut(CDoc *doc);
extern U0 ClipPaste(CDoc *doc);
extern U0 DocCut(CDoc *doc,CDocEntry *start,CDocEntry *end);
extern CDoc *DocCopy(CDoc *doc,CDocEntry *start,CDocEntry *end);
extern U0 EdReplaceTroubleOne(CDoc *doc,U8 *st_original,U8 *st_safe,I64 num,	Bool to_safe,Bool sel);
extern U0 EdReplaceTroubleAll(CDoc *doc,Bool to_safe,Bool sel);
extern I64 PopUpEdFmt();
extern I64 EdRILex(CRILex *rx);
extern U0 EdRIExp(CRILex *rx);
extern U0 EdRIStmt(CRILex *rx,Bool indent);
extern CQueVectU8 *EdRICode(CDoc *doc);
extern U0 EdRemFunLeadingSpace(CDoc *doc);
extern I64 EdRAGetU8(CDoc *doc);
extern U0 EdRACollect(CDoc *doc,CRenum *head);
extern U0 EdRenumAsm(CDoc *doc);
extern U0 EdCodeTools2(CDoc *doc,I64 tool_action,Bool beep=TRUE);
extern U0 EdPopUpChSC(I64 *_ch,I64 *_sc);
extern U0 EdChSC(CDoc *doc);
extern U0 DocFormFwd(CDoc *doc,Bool giveup=FALSE);
extern U0 DocFormBwd(CDoc *doc,Bool giveup=FALSE);
extern U0 DocDataScan(CDoc *doc,CDocEntry *doc_e);
extern U0 DrawIt(CTask *task,CDC *dc);
extern U8 *DocLinkFile(U8 *link_st,CTask *mem_task=NULL);
extern Bool DocTreeFind(CDoc *haystack_doc,U8 *needle_path,  CDocEntry **_tree_entry=NULL,  CDocEntry **_start_indent=NULL, CDocEntry **_end_indent=NULL);
extern Bool DocTreeFFind(U8 *name,U8 *path);
extern Bool DocTreeMake(CDoc *doc,U8 *path);
extern Bool DocTreeWriteJoin(CDoc *doc,U8 *path,Bool write,U8 *fmt,I64 argc,I64 *argv);
extern Bool DocTreeAppendJoin(CDoc *doc,U8 *path,Bool write,U8 *fmt,I64 argc,I64 *argv);
extern Bool DocTreeWrite(CDoc *doc,U8 *path,Bool write=TRUE,U8 *fmt,...);
extern Bool DocTreeAppend(CDoc *doc,U8 *path,Bool write=TRUE,U8 *fmt,...);
extern Bool DocTreeFWrite(U8 *name,U8 *path,U8 *fmt,...);
extern Bool DocTreeFAppend(U8 *name,U8 *path,U8 *fmt,...);
extern I64 DocTreeExe(CDoc *doc,U8 *path);
extern I64 DocTreeFExe(U8 *name,U8 *path);
extern I64 PopUpColorType();
extern I64 PopUpPageSettingType();
extern U0 EdInsColor();
extern U0 EdInsText();
extern U0 EdInsSong();
extern U0 EdInsHtml();
extern U0 DVDImageWriteTask(CDualBuf *d);
extern U0 DVDImageWrite(U8 dvd_drv_let,U8 *in_name=NULL,I64 media_type=MT_DVD);
extern U0 DskCacheInit(I64 size_in_U8s);
extern I64 DskCacheHash(I64 blk);
extern U0 DskCacheQueRem(CCacheBlk *tmpc);
extern U0 DskCacheQueIns(CCacheBlk *tmpc);
extern CCacheBlk *DskCacheFind(CDrv *dv,I64 blk);
extern U0 DskCacheAdd(CDrv *dv,U8 *buf, I64 blk, I64 cnt);
extern U0 DskCacheInvalidate2(CDrv *dv);
extern U0 RCache(CDrv *dv,U8 **_buf, I64 *_blk, I64 *_cnt);
extern I64 ClusNumNext(CDrv *dv,I64 c,I64 cnt=1);
extern I64 Clus2Blk(CDrv *dv,I64 c);
extern I64 ClusBlkRead(CDrv *dv,U8 *buf,I64 c,I64 blks);
extern I64 ClusRead(CDrv *dv,U8 *buf,I64 c,I64 cnt);
extern I64 ClusBlkWrite(CDrv *dv,U8 *buf,I64 c,I64 blks);
extern I64 ClusWrite(CDrv *dv,U8 *buf,I64 c,I64 cnt);
extern I64 ClusAlloc(CDrv *dv,I64 c=0,I64 cnt=1,Bool contiguous=FALSE);
extern U8 *FileExtDot(U8 *src);
extern U8 *FileExtRem(U8 *src,U8 *dst=NULL);
extern Bool IsDotZ(U8 *filename);
extern Bool IsDotC(U8 *filename);
extern Bool FilesFindMatch(U8 *_test_name,U8 *files_find_mask,I64 fuf_flags=0);
extern U8 *DirNameAbs(U8 *_dirname);
extern U8 *FileNameAbs(U8 *_filename,I64 fuf_flags=0);
extern U8 *ExtChg(U8 *filename,U8 *extension);
extern U8 *ExtDft(U8 *filename,U8 *extension);
extern CDirEntry *Cd2DirEntry(CDirEntry *tmpde,U8 *abs_name);
extern I64 FileAttr(U8 *name,I64 attr=0);
extern Bool FileNameChk(U8 *filename);
extern U8 *ToggleZorNotZ(U8 *name);
extern U8 *FileNameTmpTxt();
extern U8 *DirCur(CTask *task=NULL,CTask *mem_task=NULL);
extern U8 *DirFile(U8 *dirname,U8 *name=NULL,U8 *_extension=NULL);
extern I64 Name2DirClus(CDrv *dv,U8 *dirname);
extern I64 Name2ParentDirClus(CDrv *dv,U8 *dirname);
extern U0 ToFileLine(U8 *_fl_file_line,U8 **_filename,I64 *_linenum);
extern U8 *StrNew(U8 *str,CTask *task=NULL) ;
extern U8 *MAlloc(I64 cnt,CTask *task=NULL) ;
extern U8 *CAlloc(I64 cnt,CTask *task=NULL) ;
extern U8 *AStrNew(U8 *str) ;
extern U8 *AMAlloc(I64 cnt,CTask *task=NULL) ;
extern U8 *ACAlloc(I64 cnt) ;
extern U8 *MAllocIdent(U8 *ptr,CTask *task=NULL) ;
extern U8 *AMAllocIdent(U8 *ptr) ;
extern U0 SwapU8(U8 *a,U8 *b) ;
extern U0 SwapU16(U16 *a,U16 *b) ;
extern U0 SwapU32(I32 *a,I32 *b) ;
extern U0 SwapI64(I64 *a,I64 *b) ;
extern U0 InitCPUs() ;
extern U0 ImportSymbolsCB(U8 *name,U8 *addr) ;
extern U0 InitSymbols() ;
extern U0 Poodacle(I64) ;
extern U0 CDate2Dos(U16 *t,U16 *d,CDate cdt);
extern CDate Dos2CDate(U16 t,U16 d);
extern U0 FAT32Fmt(U8 drv_let,Bool quick=TRUE);
extern Bool FATNameTo(U8 *dst,U8 *src);
extern I64 FATNameXSum(U8 *src);
extern Bool FATFromName(U8 *dst,U8 *src);
extern Bool DirLongNameFill(CDirEntry *tmpde,CFAT32DirEntryLong *de,I64 *xsum);
extern Bool FAT32CDirFill(CDirEntry *tmpde,	CFAT32DirEntry *de,CDate _local_time_offset);
extern Bool FAT32DirFill(CFAT32DirEntry *de,	CDirEntry *tmpde,I64 *_de_cnt,CDate _local_time_offset);
extern U8 *FAT32FileRead(CDrv *dv,U8 *cur_dir,U8 *filename,I64 *_size,I64 *_attr);
extern Bool FAT32Cd(U8 *name,I64 cur_dir_clus);
extern U0 FAT32FreeClus(CDrv *dv,I64 c);
extern I64 FAT32FilesDel(CDrv *dv,U8 *cur_dir,U8 *files_find_mask,I64 fuf_flags,		     Bool del_dir,Bool print_msg);
extern I64 FAT32FileWrite(CDrv *dv,U8 *cur_dir,U8 *name,U8 *buf,I64 size,	CDate cdt,I64 attr);
extern CDirEntry *FAT32FilesFind(U8 *files_find_mask,	I64 fuf_flags,CDirEntry *parent=NULL,I64 *_dir_size=NULL);
extern Bool FAT32MkDir(CDrv *dv,U8 *cur_dir,U8 *name,I64 entry_cnt);
extern U0 RedSeaFreeLstBuild(CDrv *dv);
extern U8 *RedSeaFileRead(CDrv *dv,U8 *cur_dir,U8 *filename,I64 *_size,I64 *_attr);
extern Bool RedSeaCd(U8 *name,I64 cur_dir_clus);
extern U0 RedSeaFreeClus(CDrv *dv,I64 c,I64 cnt);
extern I64 RedSeaFilesDel(CDrv *dv,U8 *cur_dir,U8 *files_find_mask,I64 fuf_flags,		     Bool del_dir,Bool print_msg);
extern I64 RedSeaFileWrite(CDrv *dv,U8 *cur_dir,U8 *name,U8 *buf,I64 size,	CDate cdt,I64 attr);
extern CDirEntry *RedSeaFilesFind(U8 *files_find_mask,I64 fuf_flags,	CDirEntry *parent=NULL);
extern Bool RedSeaMkDir(CDrv *dv,U8 *cur_dir,U8 *name,I64 entry_cnt);
extern U0 VirtInit(CDrv *dv);
extern Bool VirtFileFind(CDrv *dv,U8 *cur_dir,U8 *name,	CDirEntry *_res,I64 fuf_flags=0);
extern U8 *VirtFileRead(CDrv *dv,U8 *cur_dir,U8 *filename,I64 *_size,I64 *_attr);
extern Bool VirtCd(U8 *name,U8 *cur_dir);
extern I64 VirtFilesDel(CDrv *dv,U8 *cur_dir,U8 *files_find_mask,I64 fuf_flags,		     Bool del_dir,Bool print_msg);
extern I64 VirtFileWrite(CDrv *dv,U8 *cur_dir,U8 *name,U8 *buf,I64 size,	CDate cdt,I64 attr);
extern CDirEntry *VirtFilesFind(U8 *files_find_mask,I64 fuf_flags,	CDirEntry *parent=NULL);
extern Bool VirtMkDir(CDrv *dv,U8 *cur_dir,U8 *name,I64 entry_cnt);
extern I64 HasLower(U8 *src);
extern U0 HashFunSegFind(CHashTable *h,U8 *addr,	Bool *_has_lower,U64 *_best,CHash **_res);
extern CHash *FunSegFind(U8 *addr,I64 *_offset);
extern U0 FunSegCacheAdd(CHash *tmps,U8 *addr);
extern U8 *FunSegCacheFind(U8 *addr,I64 *_offset);
extern I64 SrcLineNum(U8 *addr,I64 cnt=1);
extern U8 *SrcFileName(U8 *addr,I64 cnt=1,CTask *mem_task=NULL);
extern U8 *SrcEdLink(U8 *addr,I64 cnt=1,CTask *mem_task=NULL);
extern Bool PutSrcLink(U8 *addr,I64 cnt=1,U8 *buf=NULL);
extern Bool IsPixCovered0(CTask *task,I64 x,I64 y) ;
extern U0 GrRopEquU8NoClipping(I64 ch,U8 *dst,I64 width_internal) ;
extern I64 GrPeek0(CDC *dc=0,I64 x,I64 y);
extern I64 GrBlot(CDC *dc=0,I64 x,I64 y,CDC *img);
extern U8 *GrBitMap4ToBitMap8(U8 *dst,U8 *src,I64 src_size,I64 bkcolor);
extern U8 *GrBitMap1ToBitMap8(U8 *dst,U8 *src,I64 src_size,I64 bkcolor);
extern CDC *DCExt(CDC *dc=0,I64 x1,I64 y1,I64 x2,I64 y2,	CTask *task=NULL);
extern CDC *DCDiff(CDC *base,CDC *update);
extern I64 GrPutChar(CDC *dc=0,I64 x,I64 y,U8 ch);
extern I64 GrPutS(CDC *dc=0,I64 x,I64 y,U8 *_s);
extern I64 GrVPutS(CDC *dc=0,I64 x,I64 y,U8 *_s);
extern I64 GrPrint(CDC *dc=0,I64 x,I64 y,U8 *fmt,...);
extern I64 GrVPrint(CDC *dc=0,I64 x,I64 y,U8 *fmt,...);
extern I64 GrRect(CDC *dc=0,I64 x,I64 y,I64 w,I64 h);
extern I64 GrRayLenMinus(CDC *dc,I64 x,I64 y);
extern I64 GrRayLen(CDC *dc,I64 *x1,I64 y,I64 z=0,I32 *db=NULL);
extern I64 GrHLine(CDC *dc=0,I64 x1,I64 x2,I64 y,I64 z1=0,I64 z2=0);
extern I64 GrVLine(CDC *dc=0,I64 x,I64 y1,I64 y2,I64 z1=0,I64 z2=0);
extern I64 GrFillPoly3(CDC *dc=0,I64 n,CD3I32 *poly);
extern I64 GrRectB(CDC *dc=0,I64 x1,I64 y1,I64 x2,I64 y2);
extern I64 GrRect3(CDC *dc=0,I64 x,I64 y,I64 z,I64 w,I64 h);
extern U0 GrBorder(CDC *dc=0,I64 x1,I64 y1,I64 x2,I64 y2,	I64 step=1,I64 start=0);
extern Bool GrArrow3(CDC *dc=0,I64 x1,I64 y1,I64 z1,	I64 x2,I64 y2,I64 z2,F64 w=2.75,I64 step=1,I64 start=0);
extern Bool GrTextDiamond3(CDC *dc=0,	I64 x1,I64 y1,I64 z1,U8 *_s,I64 border=2);
extern I64 Gr3Mesh(CDC *dc=0,I64 vertex_cnt,CD3I32 *p,	I64 tri_cnt,CMeshTri *tri);
extern U0 DrawStdMs(CDC *dc,I64 x,I64 y);
extern U0 DrawWaitMs(CDC *dc,I64 x,I64 y);
extern Bool GRScrnCaptureRead(U8 *filename,CDC *dc=0,I64 x=0,I64 y=0);
extern I64 GRScrnCaptureWrite(U8 *filename,Bool include_zoom=TRUE);
extern U0 Mat4x4MulXYZ(I64 *r,I64 *_x,I64 *_y,I64 *_z);
extern U0 DCTransform(CDC *dc,I64 *_x,I64 *_y,I64 *_z);
extern I64 *Mat4x4IdentEqu(I64 *r);
extern I64 *Mat4x4IdentNew(CTask *mem_task=NULL);
extern I64 Mat4x4NormSqr65536(I64 *r);
extern U0 DCMat4x4Set(CDC *dc=NULL,I64 *r);
extern U0 DCLighting(CDC *dc,	CD3I32 *p1,CD3I32 *p2,CD3I32 *p3,CColorROPU32 color);
extern U0 DCFill(CDC *dc=NULL,CColorROPU32 val=TRANSPARENT);
extern U0 DCClear(CDC *dc=NULL);
extern U0 DCRst(CDC *dc);
extern U0 DCExtentsInit(CDC *dc=NULL);
extern CDC *DCAlias(CDC *dc=NULL,CTask *task=NULL);
extern CDC *DCNew(I64 width,I64 height,CTask *task=NULL,Bool null_bitmap=FALSE);
extern U0 DCDel(CDC *dc);
extern I64 DCSize(CDC *dc);
extern I32 *DCDepthBufRst(CDC *dc);
extern I32 *DCDepthBufAlloc(CDC *dc);
extern CDC *DCCopy(CDC *dc,CTask *task=NULL);
extern U0 DCMono(CDC *dc,  I64 quest=TRANSPARENT,I64 true_color=0,I64 false_color=COLOR_MONO);
extern I64 DCColorChg(CDC *dc,I64 src_color,I64 dst_color=TRANSPARENT);
extern U8 *DCSave(CDC *dc,I64 *_size=NULL,I64 dcsf_flags=DCSF_COMPRESSED);
extern CDC *DCLoad(U8 *src,I64 *_size=NULL,CTask *task=NULL);
extern I64 GRWrite(U8 *filename,CDC *dc,I64 dcsf_flags=DCSF_COMPRESSED);
extern CDC *GRRead(U8 *filename,CTask *task=NULL);
extern U0 DocGR(CDoc *doc=NULL,U8 *filename);
extern CDC *DCScrnCapture(Bool include_zoom=TRUE,CTask *task=NULL);
extern U0 CtrlAltZ(I64 sc);
extern U0 Scrn2Clip(I64);
extern U0 CtrlAltS(I64);
extern U0 GrInit1();
extern U0 GrSetUpTables();
extern U0 WinZBufFill(CTask *task);
extern U0 GrInit2();
extern I64 GR2MV(U8 *print_fmt="VID548212302816.MV",	U8 *files_find_mask,U8 *fu_flags=NULL);
extern Bool Line(U8 *aux_data,I64 x1,I64 y1,I64 z1,I64 x2,I64 y2,I64 z2,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),I64 step=1,I64 start=0);
extern I64 *Mat4x4MulMat4x4Equ(I64 *dst,I64 *m1,I64 *m2);
extern I64 *Mat4x4MulMat4x4New(I64 *m1,I64 *m2,CTask *mem_task=NULL);
extern I64 *Mat4x4Equ(I64 *dst,I64 *src);
extern I64 *Mat4x4New(I64 *src,CTask *mem_task=NULL);
extern I64 *Mat4x4RotX(I64 *m,F64 a);
extern I64 *Mat4x4RotY(I64 *m,F64 a);
extern I64 *Mat4x4RotZ(I64 *m,F64 a);
extern I64 *Mat4x4Scale(I64 *m,F64 s);
extern U0 DCThickScale(CDC *dc=0);
extern I64 *Mat4x4TranslationEqu(I64 *r,I64 x,I64 y,I64 z);
extern I64 *Mat4x4TranslationAdd(I64 *r,I64 x,I64 y,I64 z);
extern Bool DCSymmetrySet(CDC *dc=0,I64 x1,I64 y1,I64 x2,I64 y2);
extern Bool DCSymmetry3Set(CDC *dc=0,I64 x1,I64 y1,I64 z1,	I64 x2,I64 y2,I64 z2,I64 x3,I64 y3,I64 z3);
extern U0 DCReflect(CDC *dc,I64 *_x,I64 *_y,I64 *_z);
extern Bool Circle(U8 *aux_data,I64 cx,I64 cy,I64 cz,I64 radius,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),	I64 step=1,F64 start_radians=0,F64 len_radians=2*pi);
extern Bool Ellipse(U8 *aux_data,I64 cx,I64 cy,I64 cz,	I64 x_radius,I64 y_radius,Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),	F64 rot_angle=0,I64 step=1,F64 start_radians=0,F64 len_radians=2*pi);
extern Bool RegPoly(U8 *aux_data,I64 cx,I64 cy,I64 cz,	I64 x_radius,I64 y_radius,I64 sides,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),	F64 rot_angle=0,I64 step=1,F64 start_radians=0,F64 len_radians=2*pi);
extern F64 D3I32Dist(CD3I32 *p1,CD3I32 *p2);
extern I64 D3I32DistSqr(CD3I32 *p1,CD3I32 *p2);
extern F64 D3I32Norm(CD3I32 *p);
extern I64 D3I32NormSqr(CD3I32 *p);
extern Bool Bezier2(U8 *aux_data,CD3I32 *ctrl,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),Bool first=TRUE);
extern Bool Bezier3(U8 *aux_data,CD3I32 *ctrl,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),Bool first=TRUE);
extern Bool BSpline2(U8 *aux_data,CD3I32 *ctrl,I64 cnt,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),Bool closed=FALSE);
extern Bool BSpline3(U8 *aux_data,CD3I32 *ctrl,I64 cnt,	Bool (*fp_plot)(U8 *aux,I64 x,I64 y,I64 z),Bool closed=FALSE);
extern Bool ClipLine(I64 *_x1,I64 *_y1,I64 *_x2,I64 *_y2,	I64 left,I64 top,I64 right,I64 bottom);
extern U0 GrPaletteColorSet(I64 color_num,CBGR48 bgr48);
extern CBGR48 GrPaletteColorGet(I64 color_num);
extern U0 GrPaletteGet(CBGR48 *bgr48);
extern U0 GrPaletteSet(CBGR48 *bgr48);
extern U0 PaletteSetStd();
extern Bool GrClamp(CDC *dc=NULL,I64 *left,I64 *top,I64 *right,I64 *bottom,	I64 width=0,I64 height=0);
extern Bool DCClipLine(CDC *dc=NULL,I64 *x1,I64 *y1,I64 *x2,I64 *y2,	I64 width=0,I64 height=0);
extern Bool GrPlot(CDC *dc=NULL,I64 x,I64 y);
extern Bool GrPlot1(CDC *dc=NULL,I64 x,I64 y);
extern I64 GrPeek(CDC *dc=NULL,I64 x,I64 y);
extern I64 GrFloodFillRay(CDC *dc,I64 x,I64 y,I64 z,I32 *db);
extern I64 GrFloodFillRay(CDC *dc,I64 x,I64 y,I64 z,I32 *db);
extern I64 GrFloodFill(CDC *dc=NULL,I64 x,I64 y,	Bool not_color=FALSE,I64 z=0,I32 *db=NULL);
extern I64 GrFillSemiCircle(CDC *dc=NULL,I64 cx,I64 cy,I64 z=0,I64 diameter,I64 n);
extern I64 GrFillCircle(CDC *dc=NULL,I64 cx,I64 cy,I64 z=0,I64 diameter);
extern Bool GrPlot3B(CDC *dc=NULL,I64 x,I64 y,I64 z);
extern Bool GrPlot3(CDC *dc=NULL,I64 x,I64 y,I64 z);
extern Bool GrLinePlot0(CDC *dc,I64 x,I64 y,I64 z);
extern Bool GrLinePlot(CDC *dc=NULL,I64 x,I64 y,I64 z);
extern Bool GrLine(CDC *dc=NULL,I64 x1,I64 y1,I64 x2,I64 y2,	I64 step=1,I64 start=0);
extern Bool GrCircle(CDC *dc=NULL,I64 cx,I64 cy,I64 radius,  I64 step=1,F64 start_radians=0,F64 len_radians=2*pi);
extern Bool GrEllipse(CDC *dc=NULL,		I64 cx,I64 cy,		I64 x_radius,I64 y_radius,		F64 rot_angle=0,		I64 step=1,		F64 start_radians=0,		F64 len_radians=2*pi);
extern Bool GrRegPoly(CDC *dc=NULL,		I64 cx,I64 cy,		I64 x_radius,I64 y_radius,I64 sides,		F64 rot_angle=0,		I64 step=1,		F64 start_radians=0,		F64 len_radians=2*pi);
extern Bool Gr2Bezier(CDC *dc=NULL,CD3I32 *ctrl);
extern Bool Gr3Bezier(CDC *dc=0,CD3I32 *ctrl);
extern Bool Gr2BSpline(CDC *dc=0,CD3I32 *ctrl,I64 cnt,Bool closed=FALSE);
extern Bool Gr3BSpline(CDC *dc=0,CD3I32 *ctrl,I64 cnt,Bool closed=FALSE);
extern I64 GrLineFat3(CDC *dc=0,I64 x1,I64 y1,I64 z1,I64 x2,I64 y2,I64 z2,	I64 width,I64 start=0);
extern Bool GrLine3(CDC *dc=0,I64 x1,I64 y1,I64 z1,I64 x2,I64 y2,I64 z2,	I64 step=1,I64 start=0);
extern Bool GrPutChar3(CDC *dc=0,I64 x,I64 y,I64 z,U8 ch);
extern I64 GrPrint3(CDC *dc=0,I64 x,I64 y,I64 z,U8 *fmt,...);
extern I64 GrVPrint3(CDC *dc=0,I64 x,I64 y,I64 z,U8 *fmt,...);
extern Bool GrEllipse3(CDC *dc=0,		I64 cx,I64 cy,I64 cz,		I64 x_radius,I64 y_radius,		F64 rot_angle=0,		I64 step=1,		F64 start_radians=0,		F64 len_radians=2*pi);
extern Bool GrCircle3(CDC *dc=0,I64 cx,I64 cy,I64 cz,I64 radius,  I64 step=1,F64 start_radians=0,F64 len_radians=2*pi);
extern Bool GrRegPoly3(CDC *dc=0,		I64 cx,I64 cy,I64 cz,		I64 x_radius,I64 y_radius,I64 sides,		F64 rot_angle=0,		I64 step=1,		F64 start_radians=0,		F64 len_radians=2*pi);
extern I64 GrFloodFill3(CDC *dc=0,I64 x1,I64 y1,I64 z1,Bool not_color=FALSE);
extern I64 GrBlot3(CDC *dc=0,I64 x1,I64 y1,I64 z1,CDC *img);
extern Bool Gr3Bezier3(CDC *dc=0,CD3I32 *ctrl);
extern I64 Gr2BSpline3(CDC *dc=0,CD3I32 *ctrl,I64 cnt,Bool closed=FALSE);
extern Bool Gr3BSpline3(CDC *dc=0,CD3I32 *ctrl,I64 cnt,Bool closed=FALSE);
extern I64 GrFillTri0(CDC *dc=0,CD3I32 *p1,CD3I32 *p2,CD3I32 *p4);
extern U0 GrUpdateTaskWin(CTask *task);
extern U0 GrUpdateTasks();
extern U0 GrFixZoomScale();
extern U0 GrScaleZoom(F64 scale);
extern U0 GrZoomInScrn();
extern U0 GrUpdateTextBG();
extern U0 GrUpdateTextFG();
extern U0 DCBlotColor8(CDC *dc,CDC *img);
extern U0 GrUpdateTextModeText();
extern U0 GrUpdateScrn();
extern U0 Sprite3(CDC *dc=0,I64 x,I64 y,I64 z,U8 *elems,	Bool just_one_elem=FALSE);
extern U0 Sprite3B(CDC *dc=0,I64 x,I64 y,I64 z,U8 *elems);
extern U0 Sprite3Mat4x4B(CDC *dc=0,I64 x,I64 y,I64 z,U8 *elems,I64 *m);
extern U0 Sprite3XB(CDC *dc=0,I64 x,I64 y,I64 z,U8 *elems,F64 angle=0);
extern U0 Sprite3YB(CDC *dc=0,I64 x,I64 y,I64 z,U8 *elems,F64 angle=0);
extern U0 Sprite3ZB(CDC *dc=0,I64 x,I64 y,I64 z,U8 *elems,F64 angle=0);
extern U0 SpriteExtents(U8 *elems,I64 *min_x=NULL,I64 *max_x=NULL,
				   I64 *min_y=NULL,I64 *max_y=NULL);
extern CDC *Sprite2DC(U8 *elems);
extern U8 *SpriteInterpolate(F64 t,U8 *elems0,U8 *elems1);
extern CDocEntry *Sprite(U8 *elems,U8 *fmt=NULL);
extern Bool TextChar(CTask *task,Bool allow_border=FALSE,I64 x,I64 y,I64 d) ;
extern Bool TextLenStr(CTask *task,I64 x,I64 y,I64 len,I64 attr,U8 *s) ;
extern Bool TextLenAttrStr(CTask *task,I64 x,I64 y,I64 len,U32 *attr_s) ;
extern Bool TextLenAttr(CTask *task,I64 x,I64 y,I64 len,I64 attr) ;
extern U0 TextPrint(CTask *task,I64 x,I64 y,I64 attr,U8 *fmt,...);
extern U0 TextBorder(CTask *task=NULL,	I64 l,I64 r,I64 t,I64 b,I64 attr,Bool solid);
extern U0 TextRect(I64 l,I64 r,I64 t,I64 b,I64 d);
extern U0 JobDel(CJob *tmpc);
extern CJob *TaskExe(CTask *srv,CTask *master,U8 *data,I64 flags);
extern CJob *TaskText(CTask *srv,CTask *master,U8 *data,I64 flags);
extern CJob *TaskMsg(CTask *_srv,CTask *master,	I64 msg_code,I64 arg1,I64 arg2,I64 flags);
extern Bool JobResScan(CJob *rqst=NULL,I64 *_res=NULL);
extern I64 JobResGet(CJob *rqst=NULL);
extern U0 PostMsg(CTask *task,I64 msg_code,I64 arg1,I64 arg2,I64 flags=0);
extern U0 PostMsgWait(CTask *task,I64 msg_code,I64 arg1,I64 arg2,I64 flags=0);
extern U0 Msg(I64 msg_code,I64 arg1,I64 arg2,I64 flags=0);
extern I64 PopUp(U8 *buf,CTask *parent=NULL,CTask **_pu_task=NULL);
extern I64 PopUpPrint(U8 *fmt,...);
extern I64 Adam(U8 *fmt,...);
extern U0 AdamLog(U8 *fmt,...);
extern U0 AdamErr(U8 *fmt,...);
extern U0 XTalkWait(CTask *task,U8 *fmt,...);
extern U0 InStr(U8 *fmt,...);
extern U0 InFile(U8 *filename);
extern U0 XTalkStr(CTask *task,U8 *fmt,...);
extern U0 XTalkStrWait(CTask *task,U8 *fmt,...);
extern CJob *JobQue(I64 (*fp_addr)(U8 *data),U8 *data=NULL,       I64 target_cpu=1,I64 flags=1<<JOBf_FREE_ON_COMPLETE,       I64 job_code=JOBT_CALL,U8 *aux_str=NULL,I64 aux1=0,I64 aux2=0);
extern CTask *SpawnQue(U0 (*fp_addr)(U8 *data),U8 *data=NULL,U8 *task_name=NULL,	I64 target_cpu, CTask *parent=NULL, 	I64 stk_size=0,I64 flags=1<<JOBf_ADD_TO_QUE);
extern U0 LinkedLstDel(U8 **_lst);
extern U8 *LinkedLstCopy(U8 **_lst,CTask *mem_task=NULL);
extern I64 LinkedLstCnt(U8 **_lst);
extern I64 LinkedLstSize(U8 **_lst);
extern U0 QueDel(CQue *head,Bool querem=FALSE);
extern CQue *QueCopy(CQue *head,CTask *mem_task=NULL);
extern I64 QueCnt(CQue *head);
extern I64 QueSize(CQue *head);
extern CQueVectU8 *QueVectU8New(I64 min_idx=0);
extern U0 QueVectU8Put(CQueVectU8 *v,I64 idx,U8 ch);
extern U0 QueVectU8Del(CQueVectU8 *v);
extern I64 QueVectU8Get(CQueVectU8 *v,I64 idx);
extern CFifoU8 *FifoU8New(I64 size,CTask *mem_task=NULL);
extern U0 FifoU8Del(CFifoU8 *f);
extern Bool FifoU8Ins(CFifoU8 *f,U8 b);
extern Bool FifoU8Rem(CFifoU8 *f,U8 *_b);
extern Bool FifoU8Peek(CFifoU8 *f,U8 *_b);
extern U0 FifoU8Flush(CFifoU8 *f);
extern I64 FifoU8Cnt(CFifoU8 *f);
extern U0 FifoI64Del(CFifoI64 *f);
extern Bool FifoI64Ins(CFifoI64 *f,I64 q);
extern Bool FifoI64Rem(CFifoI64 *f,I64 *_q);
extern Bool FifoI64Peek(CFifoI64 *f,I64 *_q);
extern U0 FifoI64Flush(CFifoI64 *f);
extern I64 FifoI64Cnt(CFifoI64 *f);
extern I64 CDate2Unix(CDate dt);
extern CDate Unix2CDate(I64 timestamp);
extern CDate Now() ;
extern I64 YearStartDate(I64 year);
extern CDate Struct2Date(CDateStruct *_ds);
extern I64 DayOfWeek(I64 i);
extern U0 Date2Struct(CDateStruct *_ds,CDate cdt);
extern I64 FirstDayOfMon(I64 i);
extern I64 LastDayOfMon(I64 i);
extern I64 FirstDayOfYear(I64 i);
extern I64 LastDayOfYear(I64 i);
extern I64 Bcd2Bin(U64 b);
extern CHashDefineStr *DefineLoad(U8 *dname,U8 *st);
extern CHashDefineStr *DefineLstLoad(U8 *dname,U8 *lst);
extern U0 UndefinedDefine(U8 *dname);
extern I64 DefineCnt(U8 *dname);
extern I64 DefineMatch(U8 *needle,U8 *haystack_lst_dname,I64 flags=0);
extern U0 DefinePrint(U8 *dname,U8 *src,...);
extern U0 SysDefinesLoad();
extern U8 *Color2Str(U8 *buf,CColorROPU32 c);
extern CColorROPU16 Str2ColorU16(U8 *st);
extern CColorROPU32 Str2ColorU32(U8 *st);
extern Bool BreakLock(CTask *task=NULL);
extern I64 HashStr(U8 *str);
extern CHash *HashFind(U8 *needle,CHashTable *table,I64 mask,I64 inst=1);
extern CHash *HashSingleTableFind(U8 *needle,CHashTable *table,I64 mask,I64 inst=1);
extern CHash **HashBucketFind(U8 *str,CHashTable *table);
extern U0 HashAddAfter(CHash *tmph,CHash *to,CHashTable *);
extern U0 HashAdd(CHash *h,CHashTable *table);
extern Bool HashRemDel(CHash *tmph,CHashTable *table,	I64 instance=1) ;
extern I64 HashTypeNum(CHash *tmph);
extern I64 HashVal(CHash *tmph);
extern U0 HashDel(CHashSrcSym *tmph);
extern U0 HashTableDel(CHashTable *table);
extern I64 HashTablePurge(CHashTable *table);
extern CHashGeneric *HashGenericAdd(U8 *name,I64 type,	I64 u0=0,I64 u1=0,I64 u2=0,CTask *task=NULL);
extern U0 HashSrcFileSet(CCmpCtrl *cc,CHashSrcSym *h,I64 line_num_offset=0);
extern CHashGeneric *HashPublic(U8 *st,I64 mask,Bool val=TRUE);
extern I64 HashLstAdd(U8 *lst,I64 type,CHashTable *table);
extern I64 HashDefineLstAdd(U8 *dname,I64 type,CHashTable *table);
extern I64 FramePtr(U8 *name,CTask *task=NULL);
extern CHashGeneric *FramePtrAdd(U8 *name,I64 val=0,CTask *task=NULL);
extern I64 FramePtrSet(U8 *name,I64 val,CTask *task=NULL);
extern I64 FramePtrDel(U8 *name,CTask *task=NULL);
extern U0 LoadOneImport(U8** _src, U8* module_base, I64 ld_flags);
extern U0 SysSymImportsResolve(U8* st_ptr, I64 ld_flags);
extern U0 LoadPass1(U8* src, U8* module_base, I64 ld_flags);
extern U0 LoadPass2(U8* src, U8* module_base, I64);
extern CBinFile* Load(U8* filename, I64 ld_flags = 0, CBinFile* bfh_addr = INVALID_PTR);
extern U0 SysGlblsInit();
extern U0 SysGrInit();
extern U0 KMain();
extern F64 Pow10I64(I64 i);
extern U64 FloorU64(U64 num,U64 to);
extern U64 CeilU64(U64 num,U64 to);
extern I64 RoundI64(I64 num,I64 to);
extern I64 FloorI64(I64 num,I64 to);
extern I64 CeilI64(I64 num,I64 to);
extern F64 ToF64(I64 i) ;
extern I64 ToI64(F64 i) ;
extern I64 ClampI64(I64 i,I64 lo,I64 hi) ;
extern I64 MinI64(I64 a,I64 b) ;
extern I64 MaxI64(I64 a,I64 b) ;
extern I64 SqrI64(I64 i) ;
extern I64 DistSqrI64(I64 x1,I64 y1,I64 x2,I64 y2);
extern U0 R2P(F64 *_mag=NULL,F64 *_arg=NULL,F64 x,F64 y);
extern U0 P2R(F64 *_x=NULL,F64 *_y=NULL,F64 mag,F64 arg);
extern F64 Abs(F64 a) ;
extern F64 Trunc(F64 a) ;
extern I64 SignI64(I64 a) ;
extern F64 Sign(F64 a) ;
extern F64 Sqr(F64 a) ;
extern F64 Wrap(F64 a,F64 base=-pi);
extern F64 Clamp(F64 d,F64 lo,F64 hi);
extern U64 ClampU64(U64 d,U64 lo,U64 hi);
extern F64 Min(F64 n1,F64 n2);
extern F64 Max(F64 n1,F64 n2);
extern U64 FloorU64(U64 num,U64 to);
extern U64 CeilU64(U64 num,U64 to);
extern I64 RoundI64(I64 num,I64 to);
extern I64 FloorI64(I64 num,I64 to);
extern I64 CeilI64(I64 num,I64 to);
extern I16 RandI16();
extern U16 RandU16();
extern I32 RandI32();
extern I64 RandI64();
extern U64 RandU64();
extern F64 Rand();
extern I64 Seed(I64 seed=0,CTask *task=NULL);
extern I64 AbsI64(I64 i) ;
extern Bool LBEqu(U8 *ptr,I64 bit,Bool b) ;
extern U16 EndianU16(U16 d);
extern U32 EndianU32(U32 d);
extern I64 EndianI64(I64 d);
extern I64 BCnt(I64 d);
extern Bool Blink(F64 Hz=2.5);
extern U0 SleepUntil(I64 wake_jiffy);
extern U0 Sleep(I64 mS);
extern F64 Ona2Freq(I8 ona);
extern I8 Freq2Ona(F64 freq);
extern U0 Snd(I8 ona=0);
extern Bool ScrnCast(Bool val=ON,Bool just_audio=FALSE,U8 *print_fmt="B:/Tmp/7FA3FFE3E0.GR");
extern U0 SndRst();
extern U0 Beep(I8 ona=62,Bool busy=FALSE);
extern Bool Mute(Bool val);
extern Bool IsMute();
extern Bool Silent(Bool val=ON);
extern Bool IsSilent();
extern Bool SysDbg(Bool val);
extern Bool IsSysDbg();
extern Bool Raw(Bool val);
extern Bool IsRaw();
extern Bool SingleUser(Bool val);
extern Bool IsSingleUser();
extern Bool DbgMode(Bool val);
extern Bool IsDbgMode();
extern U0 ProgressBarsRst(U8 *path=NULL);
extern U0 Exit();
extern I64 BirthWait(CTask **_task,I64 task_num=-1);
extern U0 DeathWait(CTask **_task,Bool send_exit=FALSE);
extern Bool Kill(CTask *task,Bool wait=TRUE,Bool just_break=FALSE);
extern Bool Suspend(CTask *task=NULL,Bool state=TRUE);
extern Bool IsSuspended(CTask *task=NULL);
extern I64 TaskInit(CTask *task,I64 stk_size);
extern U0 CallPooPoo() ;
extern CTask *Spawn(U0 (*fp_start_addr)(U8 *data),U8 *data=NULL,U8 *task_name=NULL,	I64 target_cpu=-1,		CTask *parent=NULL,		I64 stk_size=0,			I64 flags=1<<JOBf_ADD_TO_QUE);
extern U0 TaskDerivedValsUpdate(CTask *task=NULL,Bool update_z_buf=TRUE);
extern I64 ExeCmdLine(CCmpCtrl *cc);
extern U0 SrvTaskCont();
extern U0 UserTaskCont();
extern U0 SrvCmdLine(I64 dummy=0);
extern U0 UserCmdLine(I64 dummy=0);
extern CTask *User(U8 *fmt=NULL,...);
extern U0 TaskDel(CTask *task);
extern I64 TaskEnd();
extern U0 TaskKillDying();
extern U0 PutKey(I64 ch=0,I64 sc=0);
extern U0 KeyDescSet(U8 *fmt,...);
extern U0 KeyDevRem(CKeyDevEntry *tmpk);
extern CKeyDevEntry *KeyDevAdd(Bool (*fp_put_key)(I64 ch,I64 sc),	Bool (*fp_puts)(U8 *st),I64 priority,Bool key_descs=FALSE);
extern Bool KDRawPutKey(I64 ch,I64);
extern Bool KDRawPutS(U8 *st);
extern Bool KDInputFilterPutKey(I64 ch,I64 scan_code);
extern Bool KDInputFilterPutS(U8 *st);
extern U0 CtrlAltDel(I64);
extern U0 CtrlAltC(I64);
extern U0 CtrlAltD(I64);
extern U0 CtrlAltF(I64);
extern U0 CtrlAltM(I64);
extern U0 CtrlAltN(I64);
extern U0 CtrlAltT(I64);
extern U0 CtrlAltV(I64);
extern U0 CtrlAltX(I64);
extern U0 KeyDevInit();
extern I64 Char2ScanCode(I64 ch,I64 sc_flags=0);
extern U8 ScanCode2Char(I64 sc);
extern U8 *Char2KeyName(I64 ch,Bool include_ctrl=TRUE);
extern U8 *ScanCode2KeyName(I64 sc);
extern U0 KbdBuildSC(U8 raw_byte,Bool in_irq,U8 *_last_raw_byte,I64 *_last_sc);
extern U0 KbdInit() ;
extern I64 KbdMsgsQue();
extern I64 KbdMsEvtTime();
extern U0 KBCb(I64 c,I64 s) ;
extern CLexFile *LexFilePush(CCmpCtrl *cc);
extern CLexFile *LexFilePop(CCmpCtrl *cc);
extern CCmpCtrl *CmpCtrlNew(U8 *buf=NULL,I64 flags=0,U8 *filename=NULL);
extern U0 CmpCtrlDel(CCmpCtrl *cc);
extern I64 CmpCtrlSize(CCmpCtrl *cc);
extern Bool LexDollar(CCmpCtrl *cc,CDoc *doc,CDocEntry *doc_e);
extern I64 LexGetChar(CCmpCtrl *cc);
extern U0 LexSkipEol(CCmpCtrl *cc);
extern U8 *LexFirstRem(CCmpCtrl *cc,U8 *marker,I64 *_len=NULL);
extern U0 LexIncludeStr(CCmpCtrl *cc,U8 *abs_filename,U8 *src,Bool actual_file);
extern CDoc *LexDocRead(U8 *abs_filename,I64 flags);
extern U0 LexAttachDoc(CCmpCtrl *cc,CLexFile *tmpf=NULL,	CDoc *doc=NULL,U8 *abs_filename=NULL,CDocEntry *doc_e=NULL,I64 col=0);
extern I64 LexInStr(CCmpCtrl *cc,U8 *buf,I64 size,Bool *done);
extern I64 Lex(CCmpCtrl *cc);
extern U0 LexBackupLastChar(CCmpCtrl *cc);
extern U0 LexPush(CCmpCtrl *cc);
extern U0 LexPopRestore(CCmpCtrl *cc);
extern U0 LexPopNoRestore(CCmpCtrl *cc);
extern I64 MemberMetaData(U8 *needle_str,CMemberLst *haystack_member_lst);
extern CMemberLstMeta *MemberMetaFind(U8 *needle_str,CMemberLst *haystack_member_lst);
extern CMemberLst *MemberFind(U8 *needle_str,CHashClass *haystack_class);
extern CMemberLst *MemberClassBaseFind(CHashClass *needle_class,	CHashClass *haystack_class);
extern U0 MemberAdd(CCmpCtrl *cc,CMemberLst *tmpm,CHashClass *tmpc,I64 mode);
extern CMemberLst *MemberLstNew(I64 _reg);
extern Bool  MemberLstCmp(CMemberLst *tmpm1,CMemberLst *tmpm2,I64 cnt=I64_MAX);
extern U0 MemberLstDel(CMemberLst *tmpm);
extern U0 ClassMemberLstDel(CHashClass *tmpc);
extern I64 MemberLstSize(CHashClass *tmpc);
extern U8 *LexExtStr(CCmpCtrl *cc,I64 *_size=NULL,Bool lex_next=TRUE);
extern CTask *MenuTask();
extern CMenuEntry *MenuSubEntryFind(	CMenuEntry *haystack_first,U8 *needle_entry_name);
extern CMenuEntry *MenuNewSub(CCmpCtrl *cc,CTask *task);
extern CMenu *MenuNew(U8 *st,I64 flags=0,CTask *task=NULL);
extern CMenu *MenuFile(U8 *filename,I64 flags=0,CTask *task=NULL);
extern U0 MenuDelSub(CMenuEntry *tmpme);
extern U0 MenuDel(CMenu *m);
extern I64 MenuEntryWidth(CMenuEntry *tmpme);
extern U0 DrawMenu(CDC *dc);
extern I64 ScanMsg(I64 *_arg1=NULL,I64 *_arg2=NULL,I64 mask=~1,CTask *task=NULL);
extern I64 GetMsg(I64 *_arg1=NULL,I64 *_arg2=NULL,I64 mask=~1,CTask *task=NULL);
extern I64 ScanChar();
extern Bool ScanKey(I64 *_ch=NULL,I64 *_scan_code=NULL,Bool echo=FALSE);
extern I64 GetKey(I64 *_scan_code=NULL,Bool echo=FALSE,Bool raw_cursor=FALSE);
extern I64 GetChar(I64 *_scan_code=NULL,Bool echo=TRUE,Bool raw_cursor=FALSE);
extern I64 GetS(U8 *buf,I64 size,Bool allow_ext=TRUE);
extern U0 GridInit();
extern U0 MsUpdate(I64 x,I64 y,I64 z,Bool l,Bool r);
extern U0 MsSet(I64 x=I64_MAX,I64 y=I64_MAX,I64 z=I64_MAX,I64 l=I64_MAX,I64 r=I64_MAX);
extern U0 MsInit();
extern U0 MsHardSpeedSet();
extern U0 MsHardSetPre();
extern U0 MsHardSetPost();
extern U0 MsHardHndlr();
extern U0 KbdMsRst();
extern U0 MsInit2();
extern U0 HMSSet4(I64 x,I64 y,I64 z,I64 lr) ;
extern U0 CoreAPSethTask();
extern CHashClass *OptClassFwd(CHashClass *tmpc);
extern I64 OptMVCompare(COptMemberVar *mv1,COptMemberVar *mv2);
extern U8 *COCCompile(CCmpCtrl *cc,I64 *_code_size,CDbgInfo **_dbg,I64 *_type) ;
extern U0 PrsPush(CPrsStk *ps,I64 val);
extern I64 PrsPop(CPrsStk *ps);
extern U0 PrsPush2(CPrsStk *ps,I64 val);
extern I64 PrsPop2(CPrsStk *ps);
extern U0 PrsPush3(CPrsStk *ps,I64 val);
extern I64 PrsPop3(CPrsStk *ps);
extern I64 PrsKeyWord(CCmpCtrl *cc);
extern CHashClass *PrsClassNew();
extern CHashFun *PrsFunNew();
extern U0 COCInit(CCmpCtrl *cc);
extern U0 COCPush(CCmpCtrl *cc);
extern CCmpCtrl *COCPopNoFree(CCmpCtrl *cc);
extern U0 COCPop(CCmpCtrl *cc);
extern U0 COCAppend(CCmpCtrl *cc, CCodeCtrl *tmpcbh);
extern CCodeMisc *COCMiscNew(CCmpCtrl *cc,I64 ty);
extern CCodeMisc *COCGoToLabelFind(CCmpCtrl *cc,U8 *name);
extern I64 COCFloatConstFind(CCmpCtrl *cc,F64 d);
extern U0 COCDel(CCmpCtrl *cc,CCodeCtrl *coc);
extern U0 COCHeaderPut(CCmpCtrl *cc,I64 pass,Bool put);
extern CHashClass *PrsClass(CCmpCtrl *cc,I64 keyword,I64 fsp_flags,Bool is_extern);
extern CHashFun *PrsFunJoin(CCmpCtrl *cc,CHashClass *tmp_return,	U8 *name,I64 fsp_flags);
extern U0 PrsFun(CCmpCtrl *cc,CHashClass *tmp_return,U8 *name,I64 fsp_flags);
extern U0 PrsGlblVarLst(CCmpCtrl *cc,I64 saved_mode,CHashClass *saved_tmpc,  I64 saved_val,I64 fsp_flags);
extern U0 PrsIf(CCmpCtrl *cc,I64 try_cnt,CCodeMisc *lb_break);
extern U0 PrsWhile(CCmpCtrl *cc,I64 try_cnt);
extern U0 PrsDoWhile(CCmpCtrl *cc,I64 try_cnt);
extern U0 PrsFor(CCmpCtrl *cc,I64 try_cnt);
extern U0 PrsSwitch(CCmpCtrl *cc,I64 try_cnt);
extern U0 PrsNoWarn(CCmpCtrl *cc);
extern U0 PrsPutStr(CCmpCtrl *cc);
extern U0 PrsStreamBlk(CCmpCtrl *cc);
extern U0 PrsTryBlk(CCmpCtrl *cc,I64 try_cnt);
extern Bool PrsStmt(CCmpCtrl *cc,I64 try_cnt=0,  CCodeMisc *lb_break=NULL,I64 cmp_flags=CMPF_PRS_SEMICOLON);
extern U0 PrsVarInit(CCmpCtrl *cc,U8 **_dst,CHashClass *tmpc,CArrayDim *tmpad,	U8 *data_addr_rip,U8 **_base,Bool data_heap,I64 pass);
extern U0 PrsVarInit2(CCmpCtrl *cc,U8 **_dst,CHashClass *tmpc,	CArrayDim *tmpad,U8 *data_addr_rip,U8 **_base,Bool data_heap,I64 pass);
extern U0 PrsGlblInit(CCmpCtrl *cc,CHashGlblVar *tmpg,I64 pass);
extern U0 PrsStaticInit(CCmpCtrl *cc,CMemberLst *tmpm,I64 pass);
extern U0 PrsArrayDims(CCmpCtrl *cc,I64 mode,CArrayDim *dim);
extern CHashClass *PrsType(CCmpCtrl *cc,CHashClass **_tmpc1,  I64 *_mode,CMemberLst *tmpm,U8 **_ident,CHashFun **_fun_ptr,  CHashExport **_tmpex,CArrayDim *tmpad,I64 fsp_flags);
extern U0 PrsDotDotDot(CCmpCtrl *cc,CHashFun *tmpf,I64 _reg);
extern U0 PrsVarLst(CCmpCtrl *cc,CHashClass *tmpc,I64 mode,I64 union_base=0);
extern U0 QSortI64(I64 *base,I64 num, I64 (*fp_compare)(I64 e1,I64 e2));
extern U0 QSort2a(U8 **base,I64 num,I64 (*fp_compare)(U8 **_e1,U8 **_e2));
extern U0 QSort2b(U8 *base,I64 num, I64 width,	I64 (*fp_compare)(U8 *e1,U8 *e2),U8 *tmp);
extern U0 QSort(U8 *base,I64 num, I64 width, I64 (*fp_compare)(U8 *e1,U8 *e2));
extern Bool BreakLock(CTask *task=NULL);
extern U0 Break();
extern U0 TaskContextRestore(CTask *task) ;
extern U0 Yield() ;
extern U0 TaskQueIns(CTask *task,CTask *pred=NULL);
extern U0 TaskQueRem(CTask *task);
extern U0 TaskQueInsChild(CTask *task);
extern I64 GR2MV(U8 *print_fmt="VID548212302816.MV",	U8 *files_find_mask,U8 *fu_flags=NULL);
extern U0 SndShift(CSndData *head,F64 dt=0);
extern I64 AUWrite(U8 *filename,CSndData *head,CDate *t0_now,F64 t0_tS);
extern U0 GrInit4();
extern I64 PopUpSpriteBitMap(CColorROPU32 color,I64 width);
extern U0 GrBitMapEdPrepPersistentDC(CDC *dc,I64 xx1,I64 yy1,CDC *img);
extern U0 GrBitMapEdTrimToExtents(CDC **_img,I64 *_xx1,I64 *_yy1,	I64 *_xx2,I64 *_yy2,CColorROPU32 bkcolor);
extern U0 GrBitMapEdAddOutline(CDC *img,I64 width,	CColorROPU32 color,CColorROPU32 bkcolor);
extern U0 GrBitMapEdEtch(CDC *img,I64 width,CColorROPU32 bkcolor);
extern I64 SpriteBitMapEd(CDoc *,CDocEntry *doc_e,CDC *dc,I64 *_xx1,I64 *_yy1,	I64 *_xx2,I64 *_yy2,CDC **_img,CColorROPU32 bkcolor);
extern U0 SpriteElem2Code(CDoc *doc,CSprite *tmpg);
extern U0 Sprite2Code(CDoc *doc=NULL,U8 *elems);
extern CSprite *Code2SpriteElem(CCmpCtrl *cc,I64 type);
extern U8 *Code2Sprite(CDoc *doc,I64 *_size=NULL);
extern CSprite *SpriteSetSettings(CDC *dc=NULL,CSprite *head,I64 elem_num,	I64 x=0,I64 y=0,CColorROPU32 *_color=NULL,I64 *_thick=NULL,	I64 *_xx=NULL,I64 *_yy=NULL);
extern Bool SpritePolyPtPlot(CSprite *head,I64 x,I64 y,I64);
extern CSprite *Sprite2SpriteQue(U8 *elems);
extern U8 *SpriteQue2Sprite(CSprite *head,I64 *_size=NULL);
extern U0 SpriteEdUpdate(CDoc *doc,CDocEntry *doc_ce,CSprite *head);
extern U0 SpriteSetOrigin(CSprite *head,I64 dx,I64 dy,I64 dz);
extern CSprite *SpriteTransformCircle(I64 *r,CSprite *tmpg);
extern CSprite *SpriteTransformEllipse(I64 *r,CSprite *tmpg);
extern CSprite *SpriteTransformRect(I64 *r,CSprite *tmpg,F64 angle);
extern CSprite *SpriteTransformBitMap(I64 *r,CSprite *tmpg);
extern U0 SpriteTransformQue(CSprite *head,I64 *r);
extern I64 SpriteQueSelCnt(CSprite *head,Bool val=TRUE);
extern I64 SpriteQueSelAll(CSprite *head,Bool val=TRUE);
extern Bool SpriteEdText(CSprite **_head,I64 *_cur_elem_num);
extern U0 GrInit3();
extern I64 PopUpSpriteEd(CSprite **_head,I64 *_cur_elem_num);
extern CEdSprite *EdSpriteNew(I64 type,CSprite *tmpg);
extern U0 SpritePtQueNew(U8 *elems,I64 x,I64 y,CEdSprite *head);
extern U0 SpriteCtrlPtsDraw(CDC *dc,CEdSprite *head);
extern U0 SpriteCtrlPtsMove(CEdSprite *head,I64 dx,I64 dy);
extern Bool SpriteSelUnselShiftPts(U8 *elems,I64 x,I64 y,I64 *_cur_elem_num,I64 mode);
extern I64 SpriteEd(CDoc *doc,CDocEntry *doc_ce,I64 x,I64 y,	CSprite **_head,I64 *_cur_elem_num);
extern U8 *SpriteTransform(U8 *elems,I64 *r);
extern I64 PopUpSpriteMain(CSprite **_head,I64 *_cur_elem_num,	CDoc *_doc,CDocEntry *_doc_e);
extern Bool PopUpExtents(I64 *_x1,I64 *_x2,I64 *_y1,I64 *_y2);
extern U0 SpriteScrnInit(CDC *dc,I64,I64);
extern CSprite *SMArrow(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color);
extern CSprite *SMPlanarSymmetry(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2);
extern CSprite *SMRect(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color);
extern CSprite *SMScrnBitMap(I64 eletype,CDC *dc,CDC *dc2,I64 x,I64 y,	I64 arg1,I64 arg2,CColorROPU32 bm_bkcolor);
extern CSprite *SMCircle(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color);
extern CSprite *SMEllipse(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color);
extern CSprite *SMPolygon(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,I64 sides,	CColorROPU32 color);
extern CSprite *SMPolyPoint(CDC *dc,I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color);
extern U0 SMTextFamily(I64 eletype,CDoc *doc,CDocEntry *doc_ce,CSprite *head,CDC *dc,	I64 x,I64 y,I64 arg1,I64 arg2,CColorROPU32 color,I64 *_cur_elem_num,	I64 old_de_flags);
extern I64 SMBitMap(I64 eletype,CDoc *doc,CDocEntry *doc_ce,CSprite *head,	CDC *dc,I64 xx,I64 yy,I64 arg1,I64 arg2,CColorROPU32 bm_bkcolor,	Bool sel,I64 xx1=0,I64 yy1=0,I64 xx2=0,I64 yy2=0,I64 *_cur_elem_num);
extern U0 SMMesh(CDoc *doc,CDocEntry *doc_ce,CSprite *head,I64 *_cur_elem_num);
extern U0 SMShiftableMesh(CDoc *doc,CDocEntry *doc_ce,CSprite *head,	I64 x,I64 y,I64 arg1,I64 arg2,I64 *_cur_elem_num);
extern U0 SMTaskTitleSet(I64 eletype);
extern I64 SpriteMainEd(CDoc *doc);
extern U0 EdSpriteIns(CDoc *doc);
extern U0 EdSpriteEd(CDoc *doc);
extern CMeshEdVertex *MeshVertexNew(CMeshFrame *e,I64 x,I64 y,I64 z);
extern CMeshEdTri *MeshTriNew(CMeshFrame *e,CColorROPU32 color,	CMeshEdVertex *v1,CMeshEdVertex *v2,CMeshEdVertex *v3);
extern CMeshEdVertex *MeshVertexFindScrPt(CMeshFrame *e,I64 x,I64 y);
extern CMeshEdVertex *MeshVertexFindNum(CMeshFrame *haystack_e,I64 needle_num);
extern U0 MeshTriDel(CMeshFrame *e,CMeshEdTri *tmpt);
extern U0 MeshVertexDel(CMeshFrame *e,CMeshEdVertex *tmpv);
extern U0 MeshFence(CMeshFrame *e);
extern U0 MeshPolygon(CMeshFrame *e,CMeshEdVertex *start,CMeshEdVertex *end,Bool rev);
extern U0 MeshPrism(CMeshFrame *e);
extern U0 MeshVertexSelAll(CMeshFrame *e,Bool val);
extern U0 MeshTriSelAll(CMeshFrame *e,Bool val);
extern U0 MeshVertexIgnoreSet(CMeshFrame *e,Bool val);
extern U0 MeshP0Capture(CMeshFrame *e);
extern U0 MeshP0Offset(CMeshFrame *e,I64 dx,I64 dy,I64 dz);
extern U0 MeshVertexSelRect(CMeshFrame *e,I64 sel_mode,I64 x1,I64 x2,I64 y1,I64 y2);
extern U0 MeshTriSelRect(CMeshFrame *e,I64 sel_mode,I64 x1,I64 x2,I64 y1,I64 y2);
extern I64 MeshSelCnt(CMeshFrame *e);
extern U0 MeshSwapAxes(CMeshFrame *e,I64 o1,I64 o2);
extern U0 MeshInvertAxis(CMeshFrame *e,I64 o);
extern U0 MeshTransformSel(CMeshFrame *e);
extern U0 MeshColorTris(CMeshFrame *e);
extern U0 MeshRevTris(CMeshFrame *e);
extern U0 MeshRecalcCxCy(CTask *task,CMeshFrame *e);
extern U0 MeshCurSnap(CMeshFrame *e);
extern U0 MeshScaleZoom(CMeshFrame *e,F64 scale);
extern U0 MPDrawIt(CMeshFrame *e);
extern I64 *MeshW2S(CMeshFrame *e,CTask *task);
extern I64 *MeshS2W(CMeshFrame *e,CTask *task);
extern I64 *MeshSetW2S(CMeshFrame *e,CTask *task);
extern U0 MeshCursorW(CMeshFrame *e,CTask *task,I64 *_x,I64 *_y,I64 *_z);
extern U0 MeshClipInit();
extern U0 MeshClipRst();
extern U0 MeshClipCopy(CMeshFrame *e);
extern U0 MeshClipCut(CMeshFrame *e);
extern U0 MeshClipDel(CMeshFrame *e);
extern U0 MeshClipPaste(CMeshFrame *e);
extern U0 DrawIt(CTask *task,CDC *dc);
extern U0 MeshInit(CMeshFrame *e,Bool flip_y);
extern U0 MeshLoad(CMeshFrame *e,U8 *src);
extern I64 MeshSize(CMeshFrame *e);
extern I32 *MeshSave(CMeshFrame *e,I64 *_size=NULL);
extern U0 MeshCleanUp(CMeshFrame *e);
extern U0 MeshUpdateMenu(CMeshFrame *e);
extern I32 *SpriteMeshEd(I32 *head=NULL,I64 *_size=NULL,Bool flip_y=FALSE);
extern I64 SpriteElemQuedBaseSize(I64 type);
extern I64 SpriteElemSize(CSprite *tmpg);
extern I64 SpriteSize(U8 *elems);
extern I64 SpriteTypeMask(U8 *elems);
extern U0 SpriteSelAll(U8 *elems,Bool val);
extern U8 *SpriteElem2Summary(CSprite *tmpg);
extern CSprite *SpriteSideBar2SpriteQue(CDoc *doc,CSprite *head,I64 *_cur_elem_num);
extern U0 SpriteSideBarPickNew(CDoc *doc,CSprite *head,I64 old_num);
extern U0 SpriteSideBarTask(CTask *parent,CSprite **_head,I64 *_cur_elem_num);
extern U8 *StrPrintHex(U8 *dst,I64 num,I64 width);
extern U0 PutHex(I64 num,I64 width);
extern U0 PutHexU64(U64 u) ;
extern U0 PutHexU32(U64 u) ;
extern U0 PutHexU16(U64 u) ;
extern U0 PutHexU18(U64 u) ;
extern U0 StrCpy(U8 *a,U8 *b) ;
extern I64 StrNCmp(U8 *a,U8 *b,I64 cnt) ;
extern I64 StrNICmp(U8 *a,U8 *b,I64 cnt) ;
extern U8 *StrMatch(U8 *needle,U8 *heystack) ;
extern U8 *StrIMatch(U8 *needle,U8 *heystack) ;
extern U8 *LstSub(I64 sub, U8 *lst);
extern I64 LstMatch(U8 *needle, U8 *haystack_lst,I64 flags=0);
extern I64 StrOcc(U8 *src, I64 ch);
extern I64 Spaces2Tabs(U8 *dst,U8 *src);
extern U8 *StrUtil(U8 *_src,I64 flags);
extern U8 *StrFirstOcc(U8 *src,U8 *marker);
extern U8 *StrFirstRem(U8 *src,U8 *marker,U8 *dst=NULL);
extern U8 *StrLastOcc(U8 *src,U8 *marker);
extern U8 *StrLastRem(U8 *src,U8 *marker,U8 *dst=NULL);
extern U8 *StrFind(U8 *needle,U8 *haystack_str,I64 flags=0);
extern Bool WildMatch(U8 *test_str,U8 *wild_str);
extern U8 *Tabs2Spaces(U8 *src);
extern U8 *ScaleIndent(U8 *src,F64 indent_scale_factor);
extern U8 *MStrUtil(U8 *src,I64 flags,F64 indent_scale_factor=0);
extern Bool YorN();
extern Bool AreYouSure();
extern U0 Help();
extern U0 ScanFlags(U8 *_dst_flags,U8 *lst,U8 *src);
extern U8 *StrPrintFlags(U8 *dst,U8 *lst,I64 flags);
extern U0 OutStr(U8 *ptr,U8 **_buf,U8 **_dst,I64 len,I64 flags);
extern U8 *MPrintTime(CDate cdt);
extern U8 *MPrintDate(CDate cdt);
extern U64 ModU64(U64 *m,U64 div) ;
extern U8 *MPrintQ(U8 *ptr,I64 flags);
extern U8 *MPrintq(U8 *ptr,I64 flags);
extern U8 *StrPrintJoin(U8 *dst,U8 *fmt,I64 argc,I64 *argv);
extern U8 *CatPrint(U8 *_dst,U8 *fmt,...);
extern U0 PrintErr(U8 *fmt,...);
extern U0 PrintWarn(U8 *fmt,...);
extern F64 Str2F64(U8 *src,U8 **_end_ptr=NULL);
extern U8 *StrScan(U8 *src,U8 *fmt,...);
extern U8 *KeyMapKeyMStrPrint(I64 sc,U0 (*fp_hndlr)(I64 sc),	U8 *desc,CTask *task=NULL);
extern U0 KeyMapKeyPrint(I64 sc,U0 (*fp_hndlr)(I64 sc),U8 *desc,CTask *task=NULL);
extern U0 KeyMapCtrlAltFamily(Bool no_shift,Bool shift);
extern U0 KMComparePrepare(U8 *buf,I64 *src);
extern U0 KeyMapFamily2(U8 **entries,CTask *task,I64 scf);
extern U0 KeyMapFamily(CTask *task,I64 scf,Bool no_shift,Bool shift);
extern U0 KeyMap(CTask *task=NULL);
extern U0 TipOfDay(U8 *tip_file="::/Doc/Tips.DD");
extern U0 ProgressBarsRegTf(U8 *path=NULL);
extern U0 DrawProgressBars(CDC *dc);
extern U0 DrawWinGrid(CDC *dc);
extern U0 WinGrid(Bool val);
extern U0 CtrlAltG(I64 sc);
extern U0 ExtendedASCII();
extern U0 CtrlAltA(I64);
extern U0 DrawMs(CDC *dc);
extern U0 WinFinalUpdate(CDC *dc);
extern U0 WinMsUpdate();
extern CTask *WinRefocus(CTask *task=NULL);
extern I64 WinOnTopWindows();
extern CTask *WinFocus(CTask *task=NULL);
extern U0 WinTileHorz();
extern U0 WinTileVert();
extern I64 WinQueIPMsgs(Bool que);
extern U0 WinCalcIdles();
extern I64 WinMgrSleep(Bool flush_msgs=FALSE);
extern Bool WinKeyNavMenu();
extern U0 WinMgrTask(I64);
extern U0 TrimComment(U8 *str) ;
extern Bool NextLine(CDoc *doc) ;
extern U0 GenHeadersForFile(U8 *file) ;
extern U0 BibleInit();
extern U8 *BibleLine2Verse(I64 line,I64 separate_ch=CH_SPACE);
extern U0 BookLines(CDoc *doc_out=NULL,I64 start,I64 lines,	U8 *book_filename=BIBLE_FILENAME);
extern U0 BibleVerse(CDoc *doc_out=NULL,U8 *verse,I64 lines);
extern CDoc *BibleDoc();
extern U0 BibleView();
extern U0 CtrlAltB(I64);
extern U0 GodDoodleDraw(CTask *task,CDC *dc);
extern U0 GodDoodleSmooth(I64 num);
extern U0 GodDoodleBitsIns(I64 num_bits,I64 n);
extern U0 GodDoodleHexIns(U8 *st);
extern I64 GodDoodleBits(I64 num_bits);
extern U8 *GodDoodleSprite(U8 *hex=NULL);
extern U0 GodDoodle(U8 *hex=NULL);
extern U0 InsNote(CMakeSongSettings *mss,U8 *buf,I64 k,I64 *j);
extern U8 *GodSongStr();
extern U0 GodSong();
extern U8 *TimeStampCB(CDoc *,CDocEntry *,CTask *mem_task);
extern U8 *KbdMsTimeCB(CDoc *,CDocEntry *,CTask *mem_task);
extern I64 PopUpTimerOk(U8 *header=NULL,U8 *footer=NULL);
extern I64 GodPick(U8 *msg=NULL);
extern U0 GodBitsIns(I64 num_bits,I64 n);
extern U0 GodHexIns(U8 *st);
extern I64 GodBits(I64 num_bits,U8 *msg=NULL);
extern I64 GodInit(U8 *files_find_mask,U8 *fu_flags=NULL);
extern U8 *GodWordStr(I64 bits=17);
extern U0 GodWord(I64 bits=17);
extern U0 GodBiblePassage(I64 num_lines=20);
extern CTask *Sweep(I64 mS,F64 ona1,F64 ona2);
extern U0 SndTaskEndCB();
extern F64 Saw(F64 t,F64 period);
extern F64 FullSaw(F64 t,F64 period);
extern F64 Caw(F64 t,F64 period);
extern F64 FullCaw(F64 t,F64 period);
extern F64 Tri(F64 t,F64 period);
extern F64 FullTri(F64 t,F64 period);
extern F64 Beat();
extern U8 *MusicSetOctave(U8 *st);
extern U8 *MusicSetMeter(U8 *st);
extern U8 *MusicSetNoteLen(U8 *st);
extern I8 Note2Ona(I64 note,I64 octave=4);
extern I8 Ona2Note(I8 ona);
extern I8 Ona2Octave(I8 ona);
extern U0 Play(U8 *st,U8 *words=NULL);
extern U0 MusicSettingsRst();
extern U0 CurSongTask();
extern U0 SoundEffectEndTaskCB();
extern U0 SoundEffectTask(CSoundEffectFrame *ns);
extern U0 StreamPrint(U8 *fmt,...);
extern U0 StreamDir();
extern CD2I32 *LexD2I32(CCmpCtrl *cc,CD2I32 *p);
extern CD3I32 *LexD3I32(CCmpCtrl *cc,CD3I32 *p);
extern CTaskSettings *SettingsPush(CTask *task=NULL,I64 flags=0);
extern U0 SettingsPop(CTask *task=NULL,I64 flags=0);
extern U0 SettingsPop2(CTask *task,CTaskSettings *tmpse);
extern U0 CtrlsUpdate(CTask *task);
extern Bool CtrlInsideRect(CCtrl *c,I64 x,I64 y);
extern U0 DrawWinScroll(CDC *dc,CCtrl *c);
extern U0 WinDerivedScrollValsUpdate(CCtrl *c);
extern U0 LeftClickHWinScroll(CCtrl *c,I64 x,I64,Bool down);
extern U0 LeftClickVWinScroll(CCtrl *c,I64,I64 y,Bool down);
extern U0 WheelChangeWinScroll(CCtrl *c,I64 delta);
extern U0 DrawViewAnglesCtrl(CDC *dc,CCtrl *c);
extern U0 UpdateDerivedViewAnglesCtrl(CCtrl *c);
extern U0 LeftClickViewAngles(CCtrl *c,I64 x,I64 y,Bool);
extern U0 DrawCtrlBttn(CDC *dc,CCtrl *c);
extern U0 LeftClickCtrlBttn(CCtrl *c,I64,I64,Bool down);
extern CCtrl *CtrlBttnNew(I64 x,I64 y,I64 width=-1,I64 height=-1,	I64 num_states=1,U8 *state_texts,	I32 *state_colors,CCtrlBttnState *_s=NULL);
extern U0 CtrlBttnDel(CCtrl *c);
extern CTemplateCS *CtrlSliderGet();
extern I64 PopUpFindMenu();
extern I64 FindFile(U8 *needle_str,U8 *haystack_filename,	I64 *_fuf_flags,U8 *replace_text);
extern I64 Find(U8 *needle_str,U8 *files_find_mask="*",	U8 *fu_flags=NULL,U8 *replace_text=NULL);
extern I64 FileOcc(U8 *needle_str,	U8 *files_find_mask="*",U8 *fu_flags="+r+i+l");
extern U8 *FileMgr(I64 mode=FM_NORMAL,CTask *mem_task=NULL);
extern U0 DirFileDoc(CDoc *doc,CDirEntry *tmpde);
extern CFMUncollapsedLst *FMCollectUncollapsedLst(CDoc *doc);
extern U0 FMMarkUncollapsed(CDoc *doc,CFMUncollapsedLst *tmpc,	U8 *cur_entry,U8 *next_entry);
extern U0 FMDelUncollapsedLst(CFMUncollapsedLst *tmpc);
extern CDirEntry *FMRebuildDocDrv(U8 drv_let,CDoc *doc,CDirEntry **_head,Bool init);
extern U0 FMRebuildDoc(CDoc **_doc,CDirEntry **_head,I64 mode);
extern U0 FMRename(CDoc *doc);
extern U0 FMMkDir(CDoc *doc);
extern U0 FMDelete(CDoc *doc);
extern U0 FMChgDsk(CDoc *doc);
extern U0 FMMountISO(CDoc *doc);
extern U0 FMUnmount(CDoc *doc);
extern U0 FMFmtDrv(CDoc *doc);
extern U0 FMMakeISO(CDoc *doc);
extern U0 FMBurnISO(CDoc *doc);
extern U0 FMCopy(CDoc *doc);
extern I64 PopUpFMRight(U8 *header=NULL,U8 *footer=NULL);
extern U0 FMRightClick();
extern U0 FMFinalScrnUpdate(CDC *dc);
extern I64 DirTreeSerializeSize(CDirEntry *tmpde);
extern I64 DirTreeSerializeFill(CDirEntry *tmpde,U8 *dst);
extern U8 *DirTreeSerialize(CDirEntry *tmpde,I64 *_size=NULL);
extern U8 *DirTreeUnserialize2(U8 *src,CDirEntry **tmpde);
extern CDirEntry *DirTreeUnserialize(U8 *src);
extern U0 FOFlatten(CDirEntry *tmpde,CDirEntry **a,I64 *i);
extern I64 Size1(CDirEntry *tmpde,I64 *_fuf_flags,I64 round_to);
extern I64 Size(U8 *files_find_mask="/*",U8 *fu_flags=NULL,I64 round_to=0);
extern I64 FileCnt(CDirEntry *tmpde);
extern I64 FF(U8 *files_find_mask,U8 *fu_flags=NULL);
extern I64 Zip(U8 *files_find_mask="*",U8 *fu_flags=NULL);
extern I64 Unzip(U8 *files_find_mask="*.Z",U8 *fu_flags=NULL);
extern U0 DbgInfoWrite(CHashTable *h,U8 *name);
extern U0 DbgInfoRead(U8 *name);
extern Bool ChkOnStk(U8 *ptr,CTask *task=NULL) ;
extern U8 *TaskCaller(CTask *task=NULL,I64 num=0,Bool saved_context=FALSE);
extern CTask *GetDebuggedProcess() ;
extern U0 CallerRep(U8 **x29=NULL,CTask *task=NULL);
extern U0 DebuggerSpawn(CTask *debugee) ;
extern U0 AiwniosDbgCB(I64 *gps) ;
extern CBpt *BptFind(U8 *needle_addr,CTask *haystack_task=NULL,Bool rem=FALSE);
extern Bool BptS(U32 *addr,CTask *task=NULL,Bool live=TRUE);
extern Bool BptR(U8 *addr,CTask *task=NULL,Bool live=TRUE,Bool rem=TRUE);
extern Bool B(U8 *addr,CTask *task=NULL,Bool live=TRUE);
extern I64 B2(CTask *task=NULL,Bool live=TRUE);
extern U0 G(U8 *ip=INVALID_PTR,CTask *task=NULL);
extern U0 G2(U8 *ip=INVALID_PTR,CTask *task=NULL);
extern U0 BList(CTask *task=NULL) ;
extern I64 *TaskRegAddr(CTask *t,I64 r,I64 raw_type) ;
extern Bool ClassRep2(CDoc *doc,U8 *_d,U8 *class_name=lastclass,	I64 depth,I64 max_depth,Bool dynamic,I64 types=HTT_CLASS,I64 offset=0);
extern U0 ClassRep(U8 *_d,U8 *class_name=lastclass,	I64 max_depth=2,Bool fun=FALSE,I64 offset=0);
extern U0 ClassRepD(U8 *_d,U8 *class_name=lastclass,	I64 max_depth=2,Bool fun=FALSE,I64 offset=0);
extern U0 UpdateRegVarImg(CHashFun *tmpf,U8 *_b,CTask *task);
extern U0 FunRep(U8 *st,U8 *rbp=NULL,I64 max_depth=2,CTask *task=NULL);
extern Bool ViewFrameVars(I64 frame=0,I64 depth=2);
#define TEXT_ROWS text.rows
#define TEXT_COLS text.cols
extern CJob sys_macro_head;
extern CTask *sys_macro_task;
extern CDoc *sys_clip_doc;

extern CTask *adam_task,*sys_focus_task;
extern I64 sys_num_spawned_tasks;

extern CTask *sys_winmgr_task,*sys_task_being_scrn_updated;
extern U8 *rev_bits_table, //Table with U8 bits revd
   *set_bits_table; //Table with count of set bits in a U8
extern CDate local_time_offset;
extern F64	*pow10_I64,
	sys_os_version;

extern CAutoCompleteDictGlbls acd;
extern CAutoCompleteGlbls ac;
extern CBlkDevGlbls	blkdev;
extern CDbgGlbls	dbg;
extern CDevGlbls	dev;
extern CGridGlbls	ms_grid; //See $LK,"::/Demo/Graphics/Grid.HC"$.
extern CMsStateGlbls	ms,ms_last;
extern CKbdStateGlbls	kbd;
extern CKeyDevGlbls	keydev;
extern CMsHardStateGlbls ms_hard,ms_hard_last;
extern CScrnCastGlbls	scrncast;
extern CTextGlbls	text;

extern CProgress sys_progresses[4];
#define progress1 sys_progresses[0].val
#define progress1_max sys_progresses[0].max
#define progress1_t0 sys_progresses[0].t0
#define progress1_tf sys_progresses[0].tf
#define progress1_desc sys_progresses[0].desc

#define progress2 sys_progresses[1].val
#define progress2_max sys_progresses[1].max
#define progress2_t0 sys_progresses[1].t0
#define progress2_tf sys_progresses[1].tf
#define progress2_desc sys_progresses[1].desc

#define progress3 sys_progresses[2].val
#define progress3_max sys_progresses[2].max
#define progress3_t0 sys_progresses[2].t0
#define progress3_tf sys_progresses[2].tf
#define progress3_desc sys_progresses[2].desc

#define progress4 sys_progresses[3].val
#define progress4_max sys_progresses[3].max
#define progress4_t0 sys_progresses[3].t0
#define progress4_tf sys_progresses[3].tf
#define progress4_desc sys_progresses[3].desc
extern CCPU cpu_structs[64];;
extern Bool RegCache();
extern Bool RegDft(U8 *path,U8 *val,Bool is_adam_entry=FALSE);
extern I64 RegExe(U8 *path);
extern I64 RegCnt(U8 *path);
extern Bool RegAppend(U8 *path,U8 *fmt,...);
extern Bool OneTimePopUp(U8 *_flags,I64 flag_num,U8 *msg);
extern U0 RegInit();
extern U0 AOnceFlush();
extern U0 OnceFlush();
extern U0 AOnce(U8 *fmt,...);
extern U0 Once(U8 *fmt,...);
extern U0 AOnceDrv(U8 drv_let=0,U8 *fmt,...);
extern U0 OnceDrv(U8 drv_let=0,U8 *fmt,...);
extern U0 OnceExe();
extern U0 SCRoutine() ;
extern F64 D3Norm(CD3 *norm) ;
extern F64 D3NormSqr(CD3 *norm) ;
extern CD3 *D3Zero(CD3 *z) ;
extern CD3 *D3MulEqu(CD3 *z,F64 s) ;
extern CD3 *D3Sub(CD3 *a,CD3*b,CD3 *c) ;
extern CD3 *D3Equ(CD3 *a,F64 x=0.,F64 y=0.,F64 z=0.) ;
extern CD3 *D3Mul(CD3 *a,F64 s,CD3 *c) ;
extern CD3 *D3SubEqu(CD3 *a,CD3*b) ;
extern CD3 *D3Div(CD3 *a,CD3 *c,F64 s) ;
extern CD3 *D3DivEqu(CD3 *a,F64 s) ;
extern F64 D3Dist(CD3 *a,CD3 *b) ;
extern F64 D3DistSqr(CD3 *a,CD3 *b) ;
extern CD3 *D3Add(CD3 *a,CD3*b,CD3 *c) ;
extern CD3 *D3AddEqu(CD3 *a,CD3 *b) ;
extern CD3 *D3Copy(CD3 *a,CD3*b) ;
extern CD3 *D3Cross(CD3 *cross,CD3 *a,CD3*b) ;
extern F64 D3Dot(CD3*a,CD3 *b) ;
extern F64 D3Unit(CD3 *unit) ;
class CWho
{
  CHashGeneric *h;
  U8 *idx;
};
extern I64 HashEntriesCompare(CWho *h1,CWho *h2);
extern I64 HashEntriesCompare2(CWho *h1,CWho *h2);
extern I64 HelpIndexCntgr(U8 *ptr,U8 *idx);
extern U8 *HelpIndexStr(U8 **_ptr,U8 *idx);
extern U8 *HelpComment(CTask *task,CHash *tmph,U8 *_src_link);
extern I64 HashEntriesCompare3(CWho *h1,CWho *h2);
extern U0 Who(U8 *fu_flags=NULL,CHashTable *h=NULL,U8 *idx=NULL,CDoc *doc=NULL);
extern I64 HashDepthRep(CHashTable *table=NULL);
extern U0 PopUpHelpIndex(U8 *idx,CTask *parent=NULL);
extern U0 MapFileLoad(U8 *filename);
extern U0 CheckForKBData();
extern I64 HashEntrySize(CHashSrcSym *tmph);
extern I64 HashEntrySize2(CHashSrcSym *tmph);
extern I64 HashTableSize2(CHashTable *table);
extern I64 gr_x_offsets[8],
	   gr_y_offsets[8],
	  gr_x_offsets2[4],
	  gr_y_offsets2[4];
extern I64 HelpIndexCnt(U8 *ptr,U8 *idx);
extern F64 Sinh(F64 x);
extern F64 Cosh(F64 x);
extern Complex *CAdd(Complex *sum,Complex *n1,Complex *n2);
extern Complex *CSub(Complex *diff,Complex *n1,Complex *n2);
extern Complex *CMul(Complex *prod,Complex *n1,Complex *n2);
extern Complex *CDiv(Complex *quot,Complex *n1,Complex *n2);
extern Complex *CScale(Complex *dst,F64 s);
extern Complex *CCopy(Complex *dst,Complex *src);
extern Complex *CEqu(Complex *dst,F64 x,F64 y);
extern Complex *CPoly(Complex *dst,I64 n,Complex *zeros,Complex *x);
extern F64 LowPass1(F64 a,F64 y0,F64 y,F64 dt=1.0);
extern U0 ODERstPtrs(CMathODE *ode);
extern CMathODE *ODENew(I64 n,F64 max_tolerance=1e-6,I64 flags=0);
extern Bool ODEPause(CMathODE *ode,Bool val=ON);
extern U0 ODEDel(CMathODE *ode);
extern I64 ODESize(CMathODE *ode);
extern U0 ODESetMassesPtrs(CMathODE *ode,F64 *state,F64 *DstateDt);
extern U0 ODEState2Internal(CMathODE *ode);
extern U0 ODEInternal2State(CMathODE *ode);
extern U0 ODERenum(CMathODE *ode);
extern CMass *MassFind(CMathODE *ode,F64 x,F64 y,F64 z=0);
extern CSpring *SpringFind(CMathODE *ode,F64 x,F64 y,F64 z=0);
extern U0 MassOrSpringFind(	CMathODE *ode,CMass **res_mass,CSpring **res_spring,	F64 x,F64 y,F64 z=0);
extern CMass *MassFindNum(CMathODE *ode,I64 num);
extern U0 ODERstInactive(CMathODE *ode);
extern U0 ODECalcSprings(CMathODE *ode);
extern U0 ODECalcDrag(CMathODE *ode);
extern U0 ODEApplyAccelerationLimit(CMathODE *ode);
extern U0 ODEMPTask(CMathODE *ode);
extern U0 ODEMPWake(CMathODE *ode);
extern U0 ODEMPSleep(CMathODE *ode);
extern U0 ODECallMPDerivative(CMathODE *ode,F64 t,F64 *state,F64 *DstateDt);
extern U0 ODECallDerivative(CMathODE *ode,F64 t,F64 *state,F64 *DstateDt);
extern U0 ODEOneStep(CMathODE *ode);
extern U0 ODERK4OneStep(CMathODE *ode);
extern U0 ODECashKarp(CMathODE *ode);
extern U0 ODERK5OneStep(CMathODE *ode);
extern U0 ODEsUpdate(CTask *task);
extern F64 ode_alloced_factor;
#define CMP_AIWN Cd("T:/Src");Cmp("STAGE1.HC","HCRT2.DBG.Z","HCRT2.BIN");
#define PROGRESS_BAR_HEIGHT	20
#define PROGRESS_BAR_WIDTH	(3*GR_WIDTH/4)
#define SEL_MESH_EQU	0
#define SEL_MESH_OR	1
#define SEL_MESH_AND	2
#define TF_SEL	1
#define TF_COPIED	2
#define VF_SEL		1
#define VF_COPIED	2
#define VF_IGNORE	4
#define SPT_MENU	-2
#define SPT_INS_SCRN_BITMAP		-3
#define SPT_INS_TRANSPARENT_SCRN_BITMAP	-4
#define SPT_ED_MENU	-5
#define SPT_EXIT	-6
#define SPEDT_SIMPLE_PT		0
#define SPEDT_WIDTH_HEIGHT	1
#define SPEDF_SEL		1
#define SPED_SEL_UNSEL_ALL	0
#define SPED_SEL		2
#define SPED_SEL_RECTS		3
#define SPED_UNSEL		4
#define SPED_UNSEL_RECTS	5
#define SPED_SHIFT_PTS		6
#define SPED_SHIFT_RECTS	7
#define SPED_SHIFT_SEL		8
#define SPED_TRANSFORM_SEL	9
#define SPED_SET_ORIGIN		10
#define SPED_SHIFT_SUB_ORIGIN	11
#define SPED_TEXT_ED		12
#define SPED_INS_CLIP		13
#define SPED_MAIN_MENU		14
#define SPED_EXIT		15
#define SPBM_EXIT		0
#define SPBM_MAIN_MENU		1
#define SPBM_COLOR		2
#define SPBM_DITHER_COLOR	3
#define SPBM_WIDTH		4
#define SPBM_PT			5
#define SPBM_LINE		6
#define SPBM_ARROW		7
#define SPBM_RECT		8
#define SPBM_CIRCLE		9
#define SPBM_TEXT		10
#define SPBM_TEXT_BOX		11
#define SPBM_TEXT_DIAMOND	12
#define SPBM_FLOOD_FILL		13
#define SPBM_FLOOD_FILL_NOT	14
#define SPBM_POLYLINE		15
#define SPBM_POLYPT		16
#define SPBM_COPY		17
#define SPBM_DELETE		18
#define SPBM_PASTE		19
#define SPBM_PASTE_TRANSPARENT	20
#define SPBM_FIND_AND_REPLACE	21
#define SPBM_TRIM_TO_EXTENTS	22
#define SPBM_ADD_OUTLINE	23
#define SPBM_ETCH		24
#define SPBM_UNDO		25
#define SPBM_SAVE_GR		26
#define SPE_ABORT	(-1)
#define SPE_EXIT	0
#define SPE_CONT	1
#define DHT_DOC_CMD	1
#define DHT_DOC_FLAG	2
#define DHT_COLOR	4
#define JOB_DONE	0
#define JOB_CONT	1
#define JOB_EXIT	2
#define EF_REINDENT	0
#define EF_CMP_CHK	1
#define EF_RENUM_ASM	2
#define EF_CTRL_SLIDER	3
#define EF_CH_SC	4
#define DS_USE_FILE1	0
#define DS_USE_FILE2	1
#define DS_REMAINDER_1	2
#define DS_REMAINDER_2	3
#define DS_ABORT_FILE	4
#define DF_MODIFIED			0x01
#define DF_DONT_MODIFIED		0x02
#define DF_REMAINDER_ALL_FILE1		0x04
#define DF_REMAINDER_ALL_FILE2		0x08
#define DF_ABORT_FILE			0x10
#define DF_ABORT_ALL_FILES		0x20
#define DF_NO_MORE_PMTS_THIS_FILE	0x40
extern I64 PopUpDiffMenu();
extern I64 DiffEntriesCompare(CDocEntry *doc_e1,CDocEntry *doc_e2);
extern U0 DiffSel(CDoc *doc,I64 *_df_flags,I64 j1_lo,I64 j1_hi,	I64 j2_lo,I64 j2_hi,I64 cnt1,I64 cnt2,	CDocEntry **doc_unsorted1,CDocEntry **doc_unsorted2);
extern Bool DiffSub(CDoc *doc,I64 *_df_flags,I64 j1_lo,I64 j1_hi,I64 j2_lo,I64 j2_hi,	I64 cnt1,I64 cnt2,CDocEntry **doc_sorted1,CDocEntry **doc_sorted2,	CDocEntry **doc_unsorted1,CDocEntry **doc_unsorted2);
extern Bool DiffBins(CDoc *doc1,CDoc *doc2);
extern Bool Diff(U8 *dst_file,U8 *src_file,I64 *_df_flags=NULL);
extern I64 ZRepCompare(CDirEntry *e1,CDirEntry *e2);
extern U0 ZipRep(U8 *files_find_mask="/*",U8 *fu_flags=NULL,  Bool just_text_not_graphics=TRUE);
extern U0 CursorRemFile(U8 *filename);
extern U0 CursorRem(U8 *files_find_mask="*");
extern U0 CollapseFile(U8 *filename,Bool collapse=TRUE);
extern U0 Collapse(U8 *files_find_mask="*",	Bool collapse=TRUE,U8 *fu_flags=NULL);
extern I64 DocOptEntry(CDoc *,CDocEntry *doc_e,I64 fuf_flags);
extern I64 DocOptDoc(CDoc *doc,I64 fuf_flags);
extern I64 DocOptFile(U8 *filename,I64 fuf_flags);
extern I64 DocOptLst(CDirEntry *tmpde,I64 fuf_flags);
extern I64 DocOpt(U8 *files_find_mask="*",U8 *fu_flags=NULL);
extern U0 InGetStr(U8 *st);
extern U0 InPrint(I64 mS=100,U8 *fmt,...);
extern U0 InGetKey(I64 scan_code,I64 sc_mask=0xFF|SCF_SHIFT|SCF_CTRL|SCF_ALT);
extern I64 InGetChar(...);
extern U0 InUntilKey(I64 scan_code,I64 sc_mask=0xFF|SCF_SHIFT|SCF_CTRL|SCF_ALT);
extern I64 InUntilChar(...);
extern Bool InView();
extern Bool InSetMsPlot(I64 mS,I64 x,I64 y,I64 z);
extern U0 InSetMs(I64 mS=7,I64 x=I64_MAX,I64 y=I64_MAX,I64 z=I64_MAX,		I64 l=I64_MAX,I64 r=I64_MAX);
extern CDirEntry MGFind(CDirEntry *needle_entry,CDirEntry *haystack_lst);
extern U0 Merge2(CDirEntry *tmpde1,CDirEntry *tmpde2,I64 *_fuf_flags,I64 *_df_flags);
extern U0 Merge(U8 *dst_files_find_mask="/*",U8 *src_files_find_mask="/*",  U8 *fu_flags=NULL);
extern U0 NewFiles(U8 *files_find_mask="/*",CDate cdt=0,U8 *fu_flags=NULL);
extern U0 TaskRepTask(CTask *task,I64 indent);
extern U0 TaskRep();
extern class CLine;
extern U0 EdLiteUpdate(CLine *head,CLine *cur_line,I64 cur_col,I64 line_start_col);
extern Bool EdLite(U8 *filename,I64 num=1,I64 edf_dof_flags=0);
extern Bool EdLiteFileLine(U8 *fl_file_line,I64 edf_dof_flags=0);
extern U0 FixSet(U8 *filename,I64 line);
extern Bool Fix(I64 edf_dof_flags=0);

class CMeshTri
{
  I32 color;	//Give one of 0-7 colors.
//Colors 8-15 are 0-7 with intensity bit set.
  I32 nums[3];	//Vertex number
};

class CQueMeshTri
{
  CQueMeshTri *next,*last;
  U0 start;
  I32 color;
  I32 nums[3];
};

class CSpriteBase
{
  U8 type;
};

class CSpriteColor : CSpriteBase
{
  U8 color;
};

class CSpriteDitherColor : CSpriteBase
{
  U16 dither_color;
};

class CSpriteT : CSpriteBase
{
  I32 thick;
};

class CSpritePt : CSpriteBase
{
  I32 x1;
  I32 y1;
};

class CSpritePtRad : CSpritePt
{
  I32 radius;
};

class CSpritePtPt : CSpritePt
{
  I32 x2;
  I32 y2;
};

class CSpritePtPtAng : CSpritePtPt
{
  F64 angle;
};

class CSpritePtWH : CSpritePt
{
  I32 width;
  I32 height;
};

class CSpritePtWHU8s : CSpritePtWH
{
  U8 u[0];
};

class CSpritePtWHAng : CSpritePtWH
{
  F64 angle;
};

class CSpritePtWHAngSides : CSpritePtWHAng
{
  I32 sides;
};

class CSpriteNumU8s : CSpriteBase
{
  I32 num;
  U8  u[0];
};

class CSpriteNumPtU8s : CSpriteBase
{
  I32 num;
  I32 x;
  I32 y;
  U8  u[0];
};

class CSpritePtStr : CSpritePt
{
  U8  st[0];
};

class CSpriteMeshU8s : CSpriteBase
{
  I32 vertex_cnt;
  I32 tri_cnt;
  U8  u[0];
};

class CSpritePtMeshU8s : CSpriteBase
{
  I32 x;
  I32 y;
  I32 z;
  I32 vertex_cnt;
  I32 tri_cnt;
  U8  u[0];
};

#define SPF_SEL			128
#define SPf_SEL			7

#define SPT_END			0	//$LK,"CSpriteBase",A="MN:CSpriteBase"$
#define SPT_COLOR		1	//$LK,"CSpriteColor",A="MN:CSpriteColor"$
#define SPT_DITHER_COLOR	2	//$LK,"CSpriteDitherColor",A="MN:CSpriteDitherColor"$
#define SPT_THICK		3	//$LK,"CSpriteT",A="MN:CSpriteT"$
#define SPT_PLANAR_SYMMETRY	4	//$LK,"CSpritePtPt",A="MN:CSpritePtPt"$
#define SPT_TRANSFORM_ON	5	//$LK,"CSpriteBase",A="MN:CSpriteBase"$
#define SPT_TRANSFORM_OFF	6	//$LK,"CSpriteBase",A="MN:CSpriteBase"$
#define SPT_SHIFT		7	//$LK,"CSpritePt",A="MN:CSpritePt"$
#define SPT_PT			8	//$LK,"CSpritePt",A="MN:CSpritePt"$
#define SPT_POLYPT		9	//$LK,"CSpriteNumPtU8s",A="MN:CSpriteNumPtU8s"$
#define SPT_LINE		10	//$LK,"CSpritePtPt",A="MN:CSpritePtPt"$
#define SPT_POLYLINE		11	//$LK,"CSpriteNumU8s",A="MN:CSpriteNumU8s"$
#define SPT_RECT		12	//$LK,"CSpritePtPt",A="MN:CSpritePtPt"$
#define SPT_ROTATED_RECT	13	//$LK,"CSpritePtPtAng",A="MN:CSpritePtPtAng"$
#define SPT_CIRCLE		14	//$LK,"CSpritePtRad",A="MN:CSpritePtRad"$
#define SPT_ELLIPSE		15	//$LK,"CSpritePtWHAng",A="MN:CSpritePtWHAng"$
#define SPT_POLYGON		16	//$LK,"CSpritePtWHAngSides",A="MN:CSpritePtWHAngSides"$
#define SPT_BSPLINE2		17	//$LK,"CSpriteNumU8s",A="MN:CSpriteNumU8s"$
#define SPT_BSPLINE2_CLOSED	18	//$LK,"CSpriteNumU8s",A="MN:CSpriteNumU8s"$
#define SPT_BSPLINE3		19	//$LK,"CSpriteNumU8s",A="MN:CSpriteNumU8s"$
#define SPT_BSPLINE3_CLOSED	20	//$LK,"CSpriteNumU8s",A="MN:CSpriteNumU8s"$
#define SPT_FLOOD_FILL		21	//$LK,"CSpritePt",A="MN:CSpritePt"$
#define SPT_FLOOD_FILL_NOT	22	//$LK,"CSpritePt",A="MN:CSpritePt"$
#define SPT_BITMAP		23	//$LK,"CSpritePtWHU8s",A="MN:CSpritePtWHU8s"$
#define SPT_MESH		24	//$LK,"CSpriteMeshU8s",A="MN:CSpriteMeshU8s"$ See $MA-X+PU,"::/Apps/GrModels",LM="Cd(\"::/Apps/GrModels\");Dir;View;\n"$.
#define SPT_SHIFTABLE_MESH	25	//$LK,"CSpritePtMeshU8s",A="MN:CSpritePtMeshU8s"$ See $MA-X+PU,"::/Apps/GrModels",LM="Cd(\"::/Apps/GrModels\");Dir;View;\n"$.
#define SPT_ARROW		26	//$LK,"CSpritePtPt",A="MN:CSpritePtPt"$
#define SPT_TEXT		27	//$LK,"CSpritePtStr",A="MN:CSpritePtStr"$
#define SPT_TEXT_BOX		28	//$LK,"CSpritePtStr",A="MN:CSpritePtStr"$
#define SPT_TEXT_DIAMOND	29	//$LK,"CSpritePtStr",A="MN:CSpritePtStr"$
#define SPT_TYPES_NUM		30
#define SPG_TYPE_MASK		0x7F

extern I64 sprite_elem_base_sizes[SPT_TYPES_NUM];
#include "Headers.HH";

#ifndef BOOTSTRAP
#define IC_BT			0x77
#define IC_BTS			0x78
#define IC_BTR			0x79
#define IC_BTC			0x7A
#define IC_LBTS			0x7B
#define IC_LBTR			0x7C
#define IC_LBTC			0x7D
#define IC_TO_I64		0x1B
#define IC_TO_F64		0x1C
_intern IC_TO_I64 I64 ToI64(F64);
_intern IC_TO_F64 F64 ToF64(I64);
#ifdef TARGET_X86
_intern IC_BT Bool Bt(U8*,I64);
_intern IC_BTS Bool Bts(U8*,I64);
_intern IC_BTC Bool Btc(U8*,I64);
_intern IC_BTR Bool Btr(U8*,I64);
_intern IC_LBTS Bool LBts(U8*,I64);
_intern IC_LBTC Bool LBtc(U8*,I64);
_intern IC_LBTR Bool LBtr(U8*,I64);
#endif
#endif
extern CCmpGlbls cmp;
//Added by Mr nrootconauto
extern U8 *DisasOpc(CDoc *doc,U8 *data);
extern U0 Uf(U8 *st); 
extern I64 CallExtStr(U8 *,...);
extern U8 *PrsAsmBlk(CCmpCtrl *cc,I64 flags=0);
class CAiwniosAOTBlob {
  CQue *asm_patches;
  CQue *to_fill;
  I64 len;
  U8 *data;
  //private,used when placing ->data into it's final location
  U8 **final_start_addr;
};
extern U0 AiwniosAOTBlobDel(CAiwniosAOTBlob *b);
extern U0 JITFixupAiwniosAOTBlob(CCmpCtrl *cc,CAiwniosAOTBlob *blob,U8 *buf);
extern U0 AsmResolvePatches(CCmpCtrl *cc,CQue *patches);
extern I64 X86EncodeOpcode(I64 rip,U8 *opc,U8 **modes,U8 *to,CQue *asm_patches);

#define HDR_NUM	16
#define REGISTRY_FILENAME "~/Registry.HC.Z"
#define SE_NOISE	0
#define SE_SWEEP	1
#define INTERNAL_TYPES_NUM	17
#define WIN_SCROLL_SIZE		8
#define WIN_SCROLL_BORDER_BONUS	4
#define VIEWANGLES_SPACING	22
#define VIEWANGLES_RANGE	48
#define VIEWANGLES_BORDER	2
#define VIEWANGLES_SNAP		2
#define C_INDENT_SPACES		2
#define ASM_RENUM_SPACING	5
#define PU_SPACING	10
#define WIZ_HIGHLIGHT_ON	(DOCT_ERROR+1)
#define WIZ_HIGHLIGHT_OFF	(DOCT_ERROR+2)
#define DEF2_PROCESSED		1
#define DEF2_NOT_INITIALIZED	2
#define FMR_INCLUDE		0
#define FMR_ADAM_INCLUDE	1
#define FMR_DELETE		2
#define FMR_RENAME		3
#define FMR_MKDIR		4
#define FMR_PLAIN		5
#define FMR_PASTE		6
#define FMR_CHG_DSK		7
#define FMR_FORMAT		8
#define FMR_MOUNT_REDSEA_ISO_C	9
#define FMR_UNMOUNT		10
#define FMR_MAKE_REDSEA_ISO_C	11
#define FMR_BURN_ISO		12
#define FMR_HELP		13
#define GOD_BAD_BITS	4
#define GOD_GOOD_BITS	24
#define DUR_4		0
#define DUR_8_8		1
#define DUR_3_3_3	2
#define DUR_16_16_16_16	3
#define DUR_8DOT_16	4
#define DUR_8_16_16	5
#define DUR_16_16_8	6
#define GR_FILE_MAX	(offset(CDC.end)-offset(CDC.start)+\
	COLORS_NUM*sizeof(CBGR48)+sizeof(CArcCtrl)+GR_WIDTH*GR_HEIGHT)
#define GR_SCALE1_BITS	24
#define GR_SCALE2_BITS	8
#define CC_LEFT		1
#define CC_RIGHT	2
#define CC_TOP		4
#define CC_BOTTOM	8
#define MV_FILE_MAX	0x007FF000
#define IS_0_ARG	0
#define IS_1_ARG	1
#define IS_2_ARG	2
#define IS_V_ARG	3 //Variable Arg Cnt

#define IST_NULL	0
#define IST_DEREF	1
#define IST_ASSIGN	2
#define IST_CMP		3
#define IC_END			0x00
#define IC_NOP1			0x01
#define IC_END_EXP		0x02
#define IC_NOP2			0x03
#define IC_LABEL		0x04
#define IC_CALL_START		0x05
#define IC_CALL_END		0x06
#define IC_CALL_END2		0x07
#define IC_RETURN_VAL		0x08
#define IC_RETURN_VAL2		0x09
#define IC_IMM_I64		0x0A
#define IC_IMM_F64		0x0B
#define IC_STR_CONST		0x0C
#define IC_ABS_ADDR		0x0D
#define IC_ADDR_IMPORT		0x0E
#define IC_HEAP_GLBL		0x0F
#define IC_SIZEOF		0x10
#define IC_TYPE			0x11
#define IC_GET_LABEL		0x12
#define IC_RBP			0x13
#define IC_REG			0x14
#define IC_FS			0x15
#define IC_MOV_FS		0x16
#define IC_GS			0x17
#define IC_MOV_GS		0x18

#define IC_LEA			0x19
#define IC_MOV			0x1A

#define IC_TO_I64		0x1B
#define IC_TO_F64		0x1C
#define IC_TO_BOOL		0x1D
#define IC_TOUPPER		0x1E
#define IC_HOLYC_TYPECAST	0x1F

#define IC_ADDR			0x20
#define IC_COM			0x21 //Bitwise COMplement
#define IC_NOT			0x22
#define IC_UNARY_MINUS		0x23

#define IC_DEREF		0x24
#define IC_DEREF_PP		0x25
#define IC_DEREF_MM		0x26
#define IC__PP			0x27
#define IC__MM			0x28
#define IC_PP_			0x29
#define IC_MM_			0x2A

#define IC_SHL			0x2B
#define IC_SHR			0x2C
#define IC_SHL_CONST		0x2D
#define IC_SHR_CONST		0x2E
#define IC_POWER		0x2F

#define IC_MUL			0x30
#define IC_DIV			0x31
#define IC_MOD			0x32

#define IC_AND			0x33

#define IC_OR			0x34
#define IC_XOR			0x35

#define IC_ADD			0x36
#define IC_SUB			0x37
#define IC_ADD_CONST		0x38
#define IC_SUB_CONST		0x39

#define IC_EQU_EQU		0x3A
#define IC_NOT_EQU		0x3B
#define IC_LESS			0x3C
#define IC_GREATER_EQU		0x3D
#define IC_GREATER		0x3E
#define IC_LESS_EQU		0x3F
#define IC_PUSH_CMP		0x40

#define IC_AND_AND		0x41

#define IC_OR_OR		0x42
#define IC_XOR_XOR		0x43

#define IC_ASSIGN		0x44
#define IC_ASSIGN_PP		0x45
#define IC_ASSIGN_MM		0x46

#define IC_SHL_EQU		0x47
#define IC_SHR_EQU		0x48
#define IC_MUL_EQU		0x49
#define IC_DIV_EQU		0x4A
#define IC_MOD_EQU		0x4B
#define IC_AND_EQU		0x4C
#define IC_OR_EQU		0x4D
#define IC_XOR_EQU		0x4E
#define IC_ADD_EQU		0x4F
#define IC_SUB_EQU		0x50

#define IC_JMP			0x51
#define IC_SUB_CALL		0x52
#define IC_SWITCH		0x53
#define IC_NOBOUND_SWITCH		0x54

#define IC_ADD_RSP		0x55
#define IC_ADD_RSP1		0x56
#define IC_ENTER		0x57
#define IC_PUSH_REGS		0x58
#define IC_POP_REGS		0x59
#define IC_LEAVE		0x5A
#define IC_RET			0x5B

#define IC_CALL			0x5C
#define IC_CALL_INDIRECT	0x5D
#define IC_CALL_INDIRECT2	0x5E
#define IC_CALL_IMPORT		0x5F
#define IC_CALL_EXTERN		0x60

#define IC_ASM			0x61
#define IC_PUSH			0x62
#define IC_POP			0x63

#define IC_CLFLUSH		0x64
#define IC_INVLPG		0x65

#define IC_IN_U8		0x66
#define IC_IN_U16		0x67
#define IC_IN_U32		0x68
#define IC_OUT_U8		0x69
#define IC_OUT_U16		0x6A
#define IC_OUT_U32		0x6B

#define IC_GET_RFLAGS		0x6C
#define IC_CARRY		0x6D
#define IC_SET_RFLAGS		0x6E
#define IC_GET_RAX		0x6F
#define IC_SET_RAX		0x70
#define IC_GET_RBP		0x71
#define IC_SET_RBP		0x72
#define IC_GET_RSP		0x73
#define IC_SET_RSP		0x74
#define IC_RIP			0x75

#define IC_RDTSC		0x76

#define IC_BT			0x77
#define IC_BTS			0x78
#define IC_BTR			0x79
#define IC_BTC			0x7A
#define IC_LBTS			0x7B
#define IC_LBTR			0x7C
#define IC_LBTC			0x7D
#define IC_BSF			0x7E
#define IC_BSR			0x7F

#define IC_QUE_INIT		0x80
#define IC_QUE_INS		0x81
#define IC_QUE_INS_REV		0x82
#define IC_QUE_REM		0x83

#define IC_STRLEN		0x84

#define IC_BR_ZERO		0x85
#define IC_BR_NOT_ZERO		0x86
#define IC_BR_CARRY		0x87
#define IC_BR_NOT_CARRY		0x88

#define IC_BR_EQU_EQU		0x89
#define IC_BR_NOT_EQU		0x8A
#define IC_BR_LESS		0x8B
#define IC_BR_GREATER_EQU	0x8C
#define IC_BR_GREATER		0x8D
#define IC_BR_LESS_EQU		0x8E

#define IC_BR_EQU_EQU2		0x8F
#define IC_BR_NOT_EQU2		0x90
#define IC_BR_LESS2		0x91
#define IC_BR_GREATER_EQU2	0x92
#define IC_BR_GREATER2		0x93
#define IC_BR_LESS_EQU2		0x94

#define IC_BR_AND_ZERO		0x95
#define IC_BR_AND_NOT_ZERO	0x96
#define IC_BR_MM_ZERO		0x97
#define IC_BR_MM_NOT_ZERO	0x98
#define IC_BR_AND_AND_ZERO	0x99
#define IC_BR_AND_AND_NOT_ZERO	0x9A
#define IC_BR_OR_OR_ZERO	0x9B
#define IC_BR_OR_OR_NOT_ZERO	0x9C

#define IC_BR_BT		0x9D
#define IC_BR_BTS		0x9E
#define IC_BR_BTR		0x9F
#define IC_BR_BTC		0xA0
#define IC_BR_NOT_BT		0xA1
#define IC_BR_NOT_BTS		0xA2
#define IC_BR_NOT_BTR		0xA3
#define IC_BR_NOT_BTC		0xA4

#define IC_SWAP_U8		0xA5
#define IC_SWAP_U16		0xA6
#define IC_SWAP_U32		0xA7
#define IC_SWAP_I64		0xA8

#define IC_ABS_I64		0xA9
#define IC_SIGN_I64		0xAA
#define IC_MIN_I64		0xAB
#define IC_MIN_U64		0xAC
#define IC_MAX_I64		0xAD
#define IC_MAX_U64		0xAE
#define IC_MOD_U64		0xAF
#define IC_SQR_I64		0xB0
#define IC_SQR_U64		0xB1
#define IC_SQR			0xB2
#define IC_ABS			0xB3
#define IC_SQRT			0xB4
#define IC_SIN			0xB5
#define IC_COS			0xB6
#define IC_TAN			0xB7
#define IC_ATAN			0xB8
#define IC_COMMA  0xB9 //Added by nroot
#define IC_SUB_RET  0xBA //Added by nroot
#define IC_FRAME  0xBB //Added by nroot
#define IC_VARGS  0xBC //Added by nroot
#define IC_STATIC  0xBD //Added by nroot

#define IC_ICS_NUM		0xBE

#define KW_INCLUDE	0
#define KW_DEFINE	1
#define KW_UNION	2
#define KW_CATCH	3
#define KW_CLASS	4
#define KW_TRY		5
#define KW_IF		6
#define KW_ELSE		7
#define KW_FOR		8
#define KW_WHILE	9
#define KW_EXTERN	10
#define KW__EXTERN	11
#define KW_RETURN	12
#define KW_SIZEOF	13
#define KW__INTERN	14
#define KW_DO		15
#define KW_ASM		16
#define KW_GOTO		17
#define KW_EXE		18
#define KW_BREAK	19
#define KW_SWITCH	20
#define KW_START	21
#define KW_END		22
#define KW_CASE		23
#define KW_DFT		24
#define KW_PUBLIC	25
#define KW_OFFSET	26
#define KW_IMPORT	27
#define KW__IMPORT	28
#define KW_IFDEF	29
#define KW_IFNDEF	30
#define KW_IFAOT	31
#define KW_IFJIT	32
#define KW_ENDIF	33
#define KW_ASSERT	34
#define KW_REG		35
#define KW_NOREG	36
#define KW_LASTCLASS	37
#define KW_NO_WARN	38
#define KW_HELP_INDEX	39
#define KW_HELP_FILE	40
#define KW_STATIC	41
#define KW_LOCK		42
#define KW_DEFINED	43
#define KW_INTERRUPT	44
#define KW_HASERRCODE	45
#define KW_ARGPOP	46
#define KW_NOARGPOP	47

#define AKW_ALIGN	64
#define AKW_ORG		65
#define AKW_I0		66
#define AKW_I8		67
#define AKW_I16		68
#define AKW_I32		69
#define AKW_I64		70
#define AKW_U0		71
#define AKW_U8		72
#define AKW_U16		73
#define AKW_U32		74
#define AKW_U64		75
#define AKW_F64		76
#define AKW_DU8		77
#define AKW_DU16	78
#define AKW_DU32	79
#define AKW_DU64	80
#define AKW_DUP		81
#define AKW_USE16	82
#define AKW_USE32	83
#define AKW_USE64	84
#define AKW_IMPORT	85
#define AKW_LIST	86
#define AKW_NOLIST	87
#define AKW_BINFILE	88
#define KW_KWS_NUM	89

#define CMP_TEMPLATE_INC	0x00
#define CMP_TEMPLATE_DEC	0x01
#define CMP_TEMPLATE_MOD	0x02
#define CMP_TEMPLATE_LESS	0x03
#define CMP_TEMPLATE_GREATER	0x04
#define CMP_TEMPLATE_LESS_EQU	0x05
#define CMP_TEMPLATE_GREATER_EQU 0x06
#define CMP_TEMPLATE_STRLEN	0x07
#define CMP_TEMPLATE_RDTSC	0x08
#define CMP_TEMPLATE_SIGN_I64	0x09
#define CMP_TEMPLATE_FSTP	0x0A
#define CMP_TEMPLATE_FLD	0x0B
#define CMP_TEMPLATE_SQR	0x0C
#define CMP_TEMPLATE_ABS	0x0D
#define CMP_TEMPLATE_SQRT	0x0E
#define CMP_TEMPLATE_SIN	0x0F
#define CMP_TEMPLATE_COS	0x10
#define CMP_TEMPLATE_TAN	0x11
#define CMP_TEMPLATE_ATAN	0x12

#define ASSOCF_LEFT	1
#define ASSOCF_RIGHT	2
#define ASSOC_MASK	3

#define PREC_NULL		0x00
#define PREC_TERM		0x04
#define PREC_UNARY_POST		0x08
#define PREC_UNARY_PRE		0x0C
#define PREC_EXP		0x10
#define PREC_MUL		0x14
#define PREC_AND		0x18
#define PREC_XOR		0x1C
#define PREC_OR			0x20
#define PREC_ADD		0x24
#define PREC_CMP		0x28
#define PREC_CMP2		0x2C
#define PREC_AND_AND		0x30
#define PREC_XOR_XOR		0x34
#define PREC_OR_OR		0x38
#define PREC_ASSIGN		0x3C

#define PREC_MAX		0x40

//Function/static/public flags
#define FSF_PUBLIC		0x01
#define FSF_ASM			0x02
#define FSF_STATIC		0x04
#define FSF__			0x08
#define FSF_INTERRUPT		(1<<Ff_INTERRUPT)
#define FSF_HASERRCODE		(1<<Ff_HASERRCODE)
#define FSF_ARGPOP		(1<<Ff_ARGPOP)
#define FSF_NOARGPOP		(1<<Ff_NOARGPOP)
#define FSG_FUN_FLAGS1 (FSF_INTERRUPT|FSF_HASERRCODE|FSF_ARGPOP|FSF_NOARGPOP)
#define FSG_FUN_FLAGS2 (FSG_FUN_FLAGS1|FSF_PUBLIC)

//Byte 0
#define PRS0_NULL		0x000000
#define PRS0__EXTERN		0x000001
#define PRS0__INTERN		0x000002
#define PRS0__IMPORT		0x000003
#define PRS0_EXTERN		0x000004
#define PRS0_IMPORT		0x000005
#define PRS0_TYPECAST		0x000006

//Byte 1
#define PRS1B_NULL		0
#define PRS1_NULL		0x000000
#define PRS1B_LOCAL_VAR		1
#define PRS1_LOCAL_VAR		0x000100
#define PRS1B_FUN_ARG		2
#define PRS1_FUN_ARG		0x000200
#define PRS1B_CLASS		3
#define PRS1_CLASS		0x000300
#define PRS1B_STATIC_LOCAL_VAR	4
#define PRS1_STATIC_LOCAL_VAR	0x000400
#define PRS1B__EXTERN_IMPORT	5
#define PRS1_NOT_REALLY__EXTERN	0x000500

#define PRSF_UNION		0x010000

extern U8 *WhineOOB(U8 *ptr);
public extern U0 Prof(I64 depth=0,I64 cpu_num=0);
public extern U0 ProfRep(I64 filter_cnt=1,Bool leave_it=OFF);
#define __AIWNIOS__

extern U32 char_bmp_alpha[16];
extern U32 char_bmp_alpha_numeric[16];
extern U32 char_bmp_alpha_numeric_no_at[16];
extern U32 char_bmp_word[16];
extern U32 char_bmp_filename[16];
extern U32 char_bmp_hex_numeric[16];
extern U32 char_bmp_dec_numeric[16];
extern U32 char_bmp_white_space[16];
extern U32 char_bmp_non_eol_white_space[16];
extern U32 char_bmp_zero_cr_nl_cursor[16];
extern U32 char_bmp_zero_tab_cr_nl_cursor[16];
extern U32 char_bmp_zero_tab_cr_nl_cursor_dollar[16];
extern U32 char_bmp_macro[16];
extern U32 char_bmp_printable[16];
extern U32 char_bmp_displayable[16];
extern U32 char_bmp_safe_dollar[16];
extern U32 char_bmp_non_eol[16];

extern class CNetAddr;
extern CNetAddr *NetAddrNew(U8 *hn=NULL,I64);
extern U0 NetAddrDel(CNetAddr *);
extern I64 NetPollForHangup(I64 argc,I64 *argv);
extern I64 NetPollForWrite(I64 argc,I64 *argv);
extern I64 NetPollForRead(I64 argc,I64 *argv);
extern I64 NetWrite(I64 s,U8 *data,I64 len);
extern I64 NetRead(I64 s,U8 *data,I64 len);
extern U0 NetClose(I64 s);
extern I64 NetAccept(I64 socket,CNetAddr **addr);
extern U0 NetListen(I64 socket,I64 max);
extern U0 NetBindIn(I64 socket,CNetAddr *);
extern I64 NetSocketNew(); 
extern U0 NetShutdown(I64); 
